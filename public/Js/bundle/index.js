// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"f2QDv":[function(require,module,exports) {
/* eslint-disable */ var _login = require("./login");
var _updateData = require("./updateData");
var _mapbox = require("./mapbox");
var _stripe = require("./stripe");
var _alerts = require("./alerts");
// console.log('Hello world');
const loginForm = document.querySelector(".form--login");
const updateForm = document.querySelector(".form-user-data");
const updateSettingF = document.querySelector(".form-user-settings");
const mapDiv = document.getElementById("map");
const logOutBtn = document.querySelector(".nav__el--logout");
const bookBtn = document.getElementById("book-tour");
if (loginForm) loginForm.addEventListener("submit", (e)=>{
    e.preventDefault();
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;
    (0, _login.login)(email, password);
});
if (mapDiv) {
    const locations = JSON.parse(document.getElementById("map").dataset.locations);
    (0, _mapbox.displayMap)(locations);
}
if (logOutBtn) logOutBtn.addEventListener("click", (0, _login.logOut));
if (updateForm) updateForm.addEventListener("submit", (e)=>{
    e.preventDefault();
    const form = new FormData();
    form.append("email", document.getElementById("email").value);
    form.append("name", document.getElementById("name").value);
    form.append("photo", document.getElementById("photo").files[0]);
    (0, _updateData.updateMe)(form);
});
if (updateSettingF) updateSettingF.addEventListener("submit", (e)=>{
    e.preventDefault();
    const oldPassword = document.getElementById("password-current").value;
    const newPassword = document.getElementById("password").value;
    const newPasswordconfirm = document.getElementById("password-confirm").value;
    (0, _updateData.updateSetting)(oldPassword, newPassword, newPasswordconfirm);
});
if (bookBtn) bookBtn.addEventListener("click", (e)=>{
    e.target.textContent = "Processing...";
    const tourId = e.target.dataset.tourId;
    (0, _stripe.bookTour)(tourId);
});

},{"./login":"7yHem","./updateData":"85FCu","./mapbox":"3zDlz","./stripe":"10tSC","./alerts":"6Mcnf"}],"7yHem":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "login", ()=>login);
parcelHelpers.export(exports, "logOut", ()=>logOut);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alerts = require("./alerts");
const login = async (email, password)=>{
    try {
        const res = await (0, _axiosDefault.default)({
            method: "POST",
            url: "/api/v1/users/login",
            data: {
                email,
                password
            }
        });
        if (res.data.message === "success") {
            (0, _alerts.showAlerts)("success", "You are Successful login");
            window.setTimeout(()=>{
                location.assign("/");
            }, 1500);
        }
    } catch (err) {
        (0, _alerts.showAlerts)("error", err.response.data.message);
    }
};
const logOut = async ()=>{
    try {
        const res = await (0, _axiosDefault.default)({
            method: "GET",
            url: "/api/v1/users/logout"
        });
        if (res.data.message === "success") location.reload(true);
    } catch (err) {
        (0, _alerts.showAlerts)("error", "Error logging out");
    }
};

},{"axios":"jo6P5","./alerts":"6Mcnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jo6P5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _axiosJsDefault.default));
parcelHelpers.export(exports, "Axios", ()=>Axios);
parcelHelpers.export(exports, "AxiosError", ()=>AxiosError);
parcelHelpers.export(exports, "CanceledError", ()=>CanceledError);
parcelHelpers.export(exports, "isCancel", ()=>isCancel);
parcelHelpers.export(exports, "CancelToken", ()=>CancelToken);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "Cancel", ()=>Cancel);
parcelHelpers.export(exports, "isAxiosError", ()=>isAxiosError);
parcelHelpers.export(exports, "spread", ()=>spread);
parcelHelpers.export(exports, "toFormData", ()=>toFormData);
parcelHelpers.export(exports, "AxiosHeaders", ()=>AxiosHeaders);
parcelHelpers.export(exports, "HttpStatusCode", ()=>HttpStatusCode);
parcelHelpers.export(exports, "formToJSON", ()=>formToJSON);
parcelHelpers.export(exports, "getAdapter", ()=>getAdapter);
parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig);
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = (0, _axiosJsDefault.default);

},{"./lib/axios.js":"63MyY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63MyY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("./adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new (0, _axiosJsDefault.default)(defaultConfig);
    const instance = (0, _bindJsDefault.default)((0, _axiosJsDefault.default).prototype.request, context);
    // Copy axios.prototype to instance
    (0, _utilsJsDefault.default).extend(instance, (0, _axiosJsDefault.default).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, _utilsJsDefault.default).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance((0, _indexJsDefault.default));
// Expose Axios class to allow class inheritance
axios.Axios = (0, _axiosJsDefault.default);
// Expose Cancel & CancelToken
axios.CanceledError = (0, _canceledErrorJsDefault.default);
axios.CancelToken = (0, _cancelTokenJsDefault.default);
axios.isCancel = (0, _isCancelJsDefault.default);
axios.VERSION = (0, _dataJs.VERSION);
axios.toFormData = (0, _toFormDataJsDefault.default);
// Expose AxiosError class
axios.AxiosError = (0, _axiosErrorJsDefault.default);
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = (0, _spreadJsDefault.default);
// Expose isAxiosError
axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
// Expose mergeConfig
axios.mergeConfig = (0, _mergeConfigJsDefault.default);
axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
axios.formToJSON = (thing)=>(0, _formDataToJSONJsDefault.default)((0, _utilsJsDefault.default).isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
axios.default = axios;
// this module should only have a default export
exports.default = axios;

},{"./utils.js":"5By4s","./helpers/bind.js":"haRQb","./core/Axios.js":"cpqD8","./core/mergeConfig.js":"b85oP","./defaults/index.js":"hXfHM","./helpers/formDataToJSON.js":"01RfH","./cancel/CanceledError.js":"9PwCG","./cancel/CancelToken.js":"45wzn","./cancel/isCancel.js":"a0VmF","./env/data.js":"h29L9","./helpers/toFormData.js":"ajoez","./core/AxiosError.js":"3u8Tl","./helpers/spread.js":"dyQ8N","./helpers/isAxiosError.js":"eyiLq","./core/AxiosHeaders.js":"cgSSx","./adapters/adapters.js":"d7JxI","./helpers/HttpStatusCode.js":"fdR61","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5By4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
"use strict";
// utils is a library of generic helper functions non-specific to axios
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === "object";
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== "object") return false;
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest("URLSearchParams");
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys = false } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({}, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys } = {})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) a[key] = (0, _bindJsDefault.default)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{};
const toFiniteNumber = (value, defaultValue)=>{
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{
    let str = "";
    const { length } = alphabet;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing)=>thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
exports.default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};

},{"./helpers/bind.js":"haRQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"haRQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>bind);
"use strict";
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"cpqD8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const validators = (0, _validatorJsDefault.default).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, _interceptorManagerJsDefault.default)(),
            response: new (0, _interceptorManagerJsDefault.default)()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
        } else config = configOrUrl || {};
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== undefined) (0, _validatorJsDefault.default).assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
        if (paramsSerializer != null) {
            if ((0, _utilsJsDefault.default).isFunction(paramsSerializer)) config.paramsSerializer = {
                serialize: paramsSerializer
            };
            else (0, _validatorJsDefault.default).assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
            }, true);
        }
        // Set config.method
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        // Flatten headers
        let contextHeaders = headers && (0, _utilsJsDefault.default).merge(headers.common, headers[config.method]);
        headers && (0, _utilsJsDefault.default).forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (method)=>{
            delete headers[method];
        });
        config.headers = (0, _axiosHeadersJsDefault.default).concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                (0, _dispatchRequestJsDefault.default).bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = (0, _dispatchRequestJsDefault.default).call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        return (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
            method,
            url,
            data: (config || {}).data
        }));
    };
});
(0, _utilsJsDefault.default).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
                method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"./../utils.js":"5By4s","../helpers/buildURL.js":"3bwC2","./InterceptorManager.js":"1VRIM","./dispatchRequest.js":"6sjJ6","./mergeConfig.js":"b85oP","./buildFullPath.js":"1I5TW","../helpers/validator.js":"9vgkY","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bwC2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildURL);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(params) ? params.toString() : new (0, _axiosURLSearchParamsJsDefault.default)(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}

},{"../utils.js":"5By4s","../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hz84m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\x00"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, _toFormDataJsDefault.default)(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"ajoez","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajoez":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var _formDataJs = require("../platform/node/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("adfd9b103875c2dd").Buffer;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return (0, _utilsJsDefault.default).isPlainObject(thing) || (0, _utilsJsDefault.default).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return (0, _utilsJsDefault.default).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable);
}
const predicates = (0, _utilsJsDefault.default).toFlatObject((0, _utilsJsDefault.default), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, _formDataJsDefault.default) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, _utilsJsDefault.default).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, _utilsJsDefault.default).isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
    if (!(0, _utilsJsDefault.default).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, _utilsJsDefault.default).isDate(value)) return value.toISOString();
        if (!useBlob && (0, _utilsJsDefault.default).isBlob(value)) throw new (0, _axiosErrorJsDefault.default)("Blob is not supported. Use a Buffer instead.");
        if ((0, _utilsJsDefault.default).isArrayBuffer(value) || (0, _utilsJsDefault.default).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, _utilsJsDefault.default).isArray(value) && isFlatArray(value) || ((0, _utilsJsDefault.default).isFileList(value) || (0, _utilsJsDefault.default).endsWith(key, "[]")) && (arr = (0, _utilsJsDefault.default).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if ((0, _utilsJsDefault.default).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
            const result = !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && visitor.call(formData, el, (0, _utilsJsDefault.default).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"adfd9b103875c2dd":"fCgem","../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","../platform/node/classes/FormData.js":"aFlee","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"3u8Tl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, _utilsJsDefault.default).inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, _utilsJsDefault.default).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    (0, _utilsJsDefault.default).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFlee":[function(require,module,exports) {
// eslint-disable-next-line strict
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VRIM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        (0, _utilsJsDefault.default).forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
exports.default = InterceptorManager;

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sjJ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dispatchRequest);
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, _canceledErrorJsDefault.default)(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = (0, _axiosHeadersJsDefault.default).from(config.headers);
    // Transform request data
    config.data = (0, _transformDataJsDefault.default).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    const adapter = (0, _adaptersJsDefault.default).getAdapter(config.adapter || (0, _indexJsDefault.default).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, response);
        response.headers = (0, _axiosHeadersJsDefault.default).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, _isCancelJsDefault.default)(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, _axiosHeadersJsDefault.default).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}

},{"./transformData.js":"eRqJY","../cancel/isCancel.js":"a0VmF","../defaults/index.js":"hXfHM","../cancel/CanceledError.js":"9PwCG","../core/AxiosHeaders.js":"cgSSx","../adapters/adapters.js":"d7JxI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eRqJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>transformData);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
function transformData(fns, response) {
    const config = this || (0, _indexJsDefault.default);
    const context = response || config;
    const headers = (0, _axiosHeadersJsDefault.default).from(context.headers);
    let data = context.data;
    (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}

},{"./../utils.js":"5By4s","../defaults/index.js":"hXfHM","../core/AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXfHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if ((0, _utilsJsDefault.default).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, _utilsJsDefault.default).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: (0, _transitionalJsDefault.default),
    adapter: [
        "xhr",
        "http"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || "";
            const hasJSONContentType = contentType.indexOf("application/json") > -1;
            const isObjectPayload = (0, _utilsJsDefault.default).isObject(data);
            if (isObjectPayload && (0, _utilsJsDefault.default).isHTMLForm(data)) data = new FormData(data);
            const isFormData = (0, _utilsJsDefault.default).isFormData(data);
            if (isFormData) {
                if (!hasJSONContentType) return data;
                return hasJSONContentType ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data)) : data;
            }
            if ((0, _utilsJsDefault.default).isArrayBuffer(data) || (0, _utilsJsDefault.default).isBuffer(data) || (0, _utilsJsDefault.default).isStream(data) || (0, _utilsJsDefault.default).isFile(data) || (0, _utilsJsDefault.default).isBlob(data)) return data;
            if ((0, _utilsJsDefault.default).isArrayBufferView(data)) return data.buffer;
            if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, _toURLEncodedFormJsDefault.default)(data, this.formSerializer).toString();
                if ((isFileList = (0, _utilsJsDefault.default).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, _toFormDataJsDefault.default)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === "json";
            if (data && (0, _utilsJsDefault.default).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, _axiosErrorJsDefault.default).from(e, (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, _indexJsDefault.default).classes.FormData,
        Blob: (0, _indexJsDefault.default).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (method)=>{
    defaults.headers[method] = {};
});
exports.default = defaults;

},{"../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","./transitional.js":"lM32f","../helpers/toFormData.js":"ajoez","../helpers/toURLEncodedForm.js":"9hjry","../platform/index.js":"7tDev","../helpers/formDataToJSON.js":"01RfH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lM32f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hjry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toURLEncodedForm);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
function toURLEncodedForm(data, options) {
    return (0, _toFormDataJsDefault.default)(data, new (0, _indexJsDefault.default).classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if ((0, _indexJsDefault.default).isNode && (0, _utilsJsDefault.default).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}

},{"../utils.js":"5By4s","./toFormData.js":"ajoez","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tDev":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("./common/utils.js");
exports.default = {
    ..._utilsJs,
    ...(0, _indexJsDefault.default)
};

},{"./node/index.js":"cVeqE","./common/utils.js":"iIwkL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVeqE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var _blobJs = require("./classes/Blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: (0, _urlsearchParamsJsDefault.default),
        FormData: (0, _formDataJsDefault.default),
        Blob: (0, _blobJsDefault.default)
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};

},{"./classes/URLSearchParams.js":"5cIHE","./classes/FormData.js":"7i1jd","./classes/Blob.js":"8chF6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cIHE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
exports.default = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, _axiosURLSearchParamsJsDefault.default);

},{"../../../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7i1jd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof FormData !== "undefined" ? FormData : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8chF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof Blob !== "undefined" ? Blob : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iIwkL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasBrowserEnv", ()=>hasBrowserEnv);
parcelHelpers.export(exports, "hasStandardBrowserWebWorkerEnv", ()=>hasStandardBrowserWebWorkerEnv);
parcelHelpers.export(exports, "hasStandardBrowserEnv", ()=>hasStandardBrowserEnv);
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const hasStandardBrowserEnv = ((product)=>{
    return hasBrowserEnv && [
        "ReactNative",
        "NativeScript",
        "NS"
    ].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const hasStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01RfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, _utilsJsDefault.default).matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && (0, _utilsJsDefault.default).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, _utilsJsDefault.default).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, _utilsJsDefault.default).isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && (0, _utilsJsDefault.default).isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, _utilsJsDefault.default).isFormData(formData) && (0, _utilsJsDefault.default).isFunction(formData.entries)) {
        const obj = {};
        (0, _utilsJsDefault.default).forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgSSx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, _utilsJsDefault.default).isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, _utilsJsDefault.default).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, _utilsJsDefault.default).isString(value)) return;
    if ((0, _utilsJsDefault.default).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, _utilsJsDefault.default).isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = (0, _utilsJsDefault.default).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) throw new Error("header name must be a non-empty string");
            const key = (0, _utilsJsDefault.default).findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
        }
        const setHeaders = (headers, _rewrite)=>(0, _utilsJsDefault.default).forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if ((0, _utilsJsDefault.default).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if ((0, _utilsJsDefault.default).isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders((0, _parseHeadersJsDefault.default)(header), valueOrRewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if ((0, _utilsJsDefault.default).isFunction(parser)) return parser.call(this, value, key);
                if ((0, _utilsJsDefault.default).isRegExp(parser)) return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = (0, _utilsJsDefault.default).findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if ((0, _utilsJsDefault.default).isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            const key = (0, _utilsJsDefault.default).findKey(headers, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && (0, _utilsJsDefault.default).isArray(value) ? value.join(", ") : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        (0, _utilsJsDefault.default).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, _utilsJsDefault.default).reduceDescriptors(AxiosHeaders.prototype, ({ value }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"../utils.js":"5By4s","../helpers/parseHeaders.js":"kqDd5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqDd5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ exports.default = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0VmF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isCancel);
"use strict";
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PwCG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, _axiosErrorJsDefault.default).call(this, message == null ? "canceled" : message, (0, _axiosErrorJsDefault.default).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, _utilsJsDefault.default).inherits(CanceledError, (0, _axiosErrorJsDefault.default), {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"3u8Tl","../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7JxI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const knownAdapters = {
    http: (0, _httpJsDefault.default),
    xhr: (0, _xhrJsDefault.default)
};
(0, _utilsJsDefault.default).forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value
        });
    }
});
const renderReason = (reason)=>`- ${reason}`;
const isResolvedHandle = (adapter)=>(0, _utilsJsDefault.default).isFunction(adapter) || adapter === null || adapter === false;
exports.default = {
    getAdapter: (adapters)=>{
        adapters = (0, _utilsJsDefault.default).isArray(adapters) ? adapters : [
            adapters
        ];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) throw new (0, _axiosErrorJsDefault.default)(`Unknown adapter '${id}'`);
            }
            if (adapter) break;
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new (0, _axiosErrorJsDefault.default)(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: knownAdapters
};

},{"../utils.js":"5By4s","./http.js":"aFlee","./xhr.js":"ldm57","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ldm57":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _cookiesJs = require("./../helpers/cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildURLJs = require("./../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _speedometerJs = require("../helpers/speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
"use strict";
function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = (0, _speedometerJsDefault.default)(50, 250);
    return (e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = (0, _axiosHeadersJsDefault.default).from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener("abort", onCanceled);
        }
        let contentType;
        if ((0, _utilsJsDefault.default).isFormData(requestData)) {
            if ((0, _indexJsDefault.default).hasStandardBrowserEnv || (0, _indexJsDefault.default).hasStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it
            else if ((contentType = requestHeaders.getContentType()) !== false) {
                // fix semicolon duplication issue for ReactNative FormData implementation
                const [type, ...tokens] = contentType ? contentType.split(";").map((token)=>token.trim()).filter(Boolean) : [];
                requestHeaders.setContentType([
                    type || "multipart/form-data",
                    ...tokens
                ].join("; "));
            }
        }
        let request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = (0, _axiosHeadersJsDefault.default).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            (0, _settleJsDefault.default)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, _axiosErrorJsDefault.default)("Request aborted", (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || (0, _transitionalJsDefault.default);
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new (0, _axiosErrorJsDefault.default)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, _axiosErrorJsDefault.default).ETIMEDOUT : (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if ((0, _indexJsDefault.default).hasStandardBrowserEnv) {
            withXSRFToken && (0, _utilsJsDefault.default).isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOriginJsDefault.default)(fullPath)) {
                // Add xsrf header
                const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && (0, _cookiesJsDefault.default).read(config.xsrfCookieName);
                if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, _utilsJsDefault.default).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, _utilsJsDefault.default).isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, _canceledErrorJsDefault.default)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
        const protocol = (0, _parseProtocolJsDefault.default)(fullPath);
        if (protocol && (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1) {
            reject(new (0, _axiosErrorJsDefault.default)("Unsupported protocol " + protocol + ":", (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"./../utils.js":"5By4s","./../core/settle.js":"dD9aC","./../helpers/cookies.js":"4WJjt","./../helpers/buildURL.js":"3bwC2","../core/buildFullPath.js":"1I5TW","./../helpers/isURLSameOrigin.js":"lxXtv","../defaults/transitional.js":"lM32f","../core/AxiosError.js":"3u8Tl","../cancel/CanceledError.js":"9PwCG","../helpers/parseProtocol.js":"7NfWU","../platform/index.js":"7tDev","../core/AxiosHeaders.js":"cgSSx","../helpers/speedometer.js":"gQeo1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dD9aC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>settle);
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, _axiosErrorJsDefault.default)("Request failed with status code " + response.status, [
        (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}

},{"./AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4WJjt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (name, value, expires, path, domain, secure) {
        const cookie = [
            name + "=" + encodeURIComponent(value)
        ];
        (0, _utilsJsDefault.default).isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        (0, _utilsJsDefault.default).isString(path) && cookie.push("path=" + path);
        (0, _utilsJsDefault.default).isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
    },
    read (name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove (name) {
        this.write(name, "", Date.now() - 86400000);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1I5TW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildFullPath);
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
"use strict";
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL)) return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
    return requestedURL;
}

},{"../helpers/isAbsoluteURL.js":"jD6NM","../helpers/combineURLs.js":"brOWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jD6NM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAbsoluteURL);
"use strict";
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"brOWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>combineURLs);
"use strict";
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxXtv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = (0, _utilsJsDefault.default).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NfWU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parseProtocol);
"use strict";
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQeo1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b85oP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeConfig);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const headersToObject = (thing)=>thing instanceof (0, _axiosHeadersJsDefault.default) ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, _utilsJsDefault.default).isPlainObject(target) && (0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge.call({
            caseless
        }, target, source);
        else if ((0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge({}, source);
        else if ((0, _utilsJsDefault.default).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    (0, _utilsJsDefault.default).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (0, _utilsJsDefault.default).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}

},{"../utils.js":"5By4s","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vgkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
const validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
const deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, _dataJs.VERSION) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new (0, _axiosErrorJsDefault.default)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, _axiosErrorJsDefault.default).ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, _axiosErrorJsDefault.default)("options must be an object", (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, _axiosErrorJsDefault.default)("option " + opt + " must be " + result, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, _axiosErrorJsDefault.default)("Unknown option " + opt, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions,
    validators
};

},{"../env/data.js":"h29L9","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h29L9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
const VERSION = "1.6.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45wzn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, _canceledErrorJsDefault.default)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel
        };
    }
}
exports.default = CancelToken;

},{"./CanceledError.js":"9PwCG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyQ8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>spread);
"use strict";
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyiLq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAxiosError);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
function isAxiosError(payload) {
    return (0, _utilsJsDefault.default).isObject(payload) && payload.isAxiosError === true;
}

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdR61":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Mcnf":[function(require,module,exports) {
//HIDE ALERTS
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showAlerts", ()=>showAlerts);
const hideAlerts = ()=>{
    const el = document.querySelector(".alert");
    if (el) el.parentElement.removeChild(el);
};
const showAlerts = (type, msg)=>{
    hideAlerts();
    const markUp = `<div class="alert alert--${type}">${msg}</div>`;
    document.querySelector("body").insertAdjacentHTML("afterbegin", markUp);
    setTimeout(hideAlerts, 5000);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"85FCu":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "updateMe", ()=>updateMe);
parcelHelpers.export(exports, "updateSetting", ()=>updateSetting);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alerts = require("./alerts");
const updateMe = async (data)=>{
    try {
        const res = await (0, _axiosDefault.default)({
            method: "PATCH",
            url: "/api/v1/users/updateMe",
            data: data
        });
        if (res.data.message === "success") {
            (0, _alerts.showAlerts)("success", "You are Successful update");
            window.setTimeout(()=>{
                location.reload("/me");
            }, 1500);
        }
    } catch (err) {
        (0, _alerts.showAlerts)("error", err.response.data.message);
    }
};
const updateSetting = async (oldPassword, newPassword, newPasswordconfirm)=>{
    try {
        const res = await (0, _axiosDefault.default)({
            method: "PATCH",
            url: "/api/v1/users/updateMyPassword",
            data: {
                oldPassword,
                newPassword,
                newPasswordconfirm
            }
        });
        if (res.data.message === "success") {
            (0, _alerts.showAlerts)("success", "You are Successful update");
            window.setTimeout(()=>{
                location.reload("/me");
            }, 1500);
        }
    } catch (err) {
        (0, _alerts.showAlerts)("error", err.response.data.message);
    }
};

},{"axios":"jo6P5","./alerts":"6Mcnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3zDlz":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "displayMap", ()=>displayMap);
var _mapboxGl = require("mapbox-gl");
var _mapboxGlDefault = parcelHelpers.interopDefault(_mapboxGl);
const displayMap = (locations)=>{
    (0, _mapboxGlDefault.default).accessToken = "pk.eyJ1IjoicGFua2Fqc2V0aGptdCIsImEiOiJjbGw5b2t4NG4xbTJ1M2VvMWp3MHpnb2RyIn0.WkV0elZQzoiJGX35YQ9euQ";
    var map = new (0, _mapboxGlDefault.default).Map({
        container: "map",
        style: "mapbox://styles/pankajsethjmt/cll9pzlhi00pc01ph9pgcckct",
        scrollZoom: false
    });
    const bounds = new (0, _mapboxGlDefault.default).LngLatBounds();
    locations.forEach((loc)=>{
        //add a marker
        const el = document.createElement("div");
        el.className = "marker";
        new (0, _mapboxGlDefault.default).Marker({
            element: el,
            anchor: "bottom"
        }).setLngLat(loc.coordinates).addTo(map);
        new (0, _mapboxGlDefault.default).Popup({
            offset: 30,
            focusAfterOpen: false
        }).setLngLat(loc.coordinates).setHTML(`<p>Day ${loc.day} : ${loc.description}</p>`).addTo(map);
        bounds.extend(loc.coordinates);
    });
    map.fitBounds(bounds, {
        padding: {
            top: 200,
            bottom: 150,
            left: 100,
            right: 100
        }
    });
};

},{"mapbox-gl":"562rs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"562rs":[function(require,module,exports) {
/* Mapbox GL JS is Copyright  2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    module.exports = factory();
})(this, function() {
    "use strict";
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) shared = chunk;
        else if (!worker) worker = chunk;
        else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([
                workerBundleString
            ], {
                type: "text/javascript"
            }));
        }
    }
    define([
        "exports"
    ], function(t1) {
        "use strict";
        var e1 = "undefined" != typeof self ? self : {}, r = "2.15.0";
        let n;
        const i = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                if (null == n) {
                    const t1 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                        n = t1;
                    } catch (e1) {
                        n = t1;
                    }
                }
                return n;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                if (!i.API_URL) return null;
                try {
                    const t1 = new URL(i.API_URL);
                    return "api.mapbox.cn" === t1.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t1.hostname ? "https://events.mapbox.com/events/v2" : null;
                } catch (t1) {
                    return null;
                }
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            MAX_PARALLEL_IMAGE_REQUESTS: 16
        }, s = {
            supported: !1,
            testSupport: function(t1) {
                !l && o && (u ? c(t1) : a = t1);
            }
        };
        let a, o, l = !1, u = !1;
        function c(t1) {
            const e1 = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e1);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, o), t1.isContextLost()) return;
                s.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e1), l = !0;
        }
        e1.document && (o = e1.document.createElement("img"), o.onload = function() {
            a && c(a), a = null, u = !0;
        }, o.onerror = function() {
            l = !0, a = null;
        }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h = "01";
        function p(t1) {
            return t1 && t1.__esModule && Object.prototype.hasOwnProperty.call(t1, "default") ? t1.default : t1;
        }
        var d = f;
        function f(t1, e1, r, n) {
            this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e1, this.by = 3 * (n - e1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e1, this.p2x = r, this.p2y = n;
        }
        f.prototype = {
            sampleCurveX: function(t1) {
                return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
            },
            sampleCurveY: function(t1) {
                return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
            },
            sampleCurveDerivativeX: function(t1) {
                return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
            },
            solveCurveX: function(t1, e1) {
                if (void 0 === e1 && (e1 = 1e-6), t1 < 0) return 0;
                if (t1 > 1) return 1;
                for(var r = t1, n = 0; n < 8; n++){
                    var i = this.sampleCurveX(r) - t1;
                    if (Math.abs(i) < e1) return r;
                    var s = this.sampleCurveDerivativeX(r);
                    if (Math.abs(s) < 1e-6) break;
                    r -= i / s;
                }
                var a = 0, o = 1;
                for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e1)); n++)t1 > i ? a = r : o = r, r = .5 * (o - a) + a;
                return r;
            },
            solve: function(t1, e1) {
                return this.sampleCurveY(this.solveCurveX(t1, e1));
            }
        };
        var y = p(d), m = g;
        function g(t1, e1) {
            this.x = t1, this.y = e1;
        }
        g.prototype = {
            clone: function() {
                return new g(this.x, this.y);
            },
            add: function(t1) {
                return this.clone()._add(t1);
            },
            sub: function(t1) {
                return this.clone()._sub(t1);
            },
            multByPoint: function(t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint: function(t1) {
                return this.clone()._divByPoint(t1);
            },
            mult: function(t1) {
                return this.clone()._mult(t1);
            },
            div: function(t1) {
                return this.clone()._div(t1);
            },
            rotate: function(t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround: function(t1, e1) {
                return this.clone()._rotateAround(t1, e1);
            },
            matMult: function(t1) {
                return this.clone()._matMult(t1);
            },
            unit: function() {
                return this.clone()._unit();
            },
            perp: function() {
                return this.clone()._perp();
            },
            round: function() {
                return this.clone()._round();
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function(t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist: function(t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr: function(t1) {
                var e1 = t1.x - this.x, r = t1.y - this.y;
                return e1 * e1 + r * r;
            },
            angle: function() {
                return Math.atan2(this.y, this.x);
            },
            angleTo: function(t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith: function(t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep: function(t1, e1) {
                return Math.atan2(this.x * e1 - this.y * t1, this.x * t1 + this.y * e1);
            },
            _matMult: function(t1) {
                var e1 = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e1, this;
            },
            _add: function(t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub: function(t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult: function(t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div: function(t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint: function(t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint: function(t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit: function() {
                return this._div(this.mag()), this;
            },
            _perp: function() {
                var t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate: function(t1) {
                var e1 = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e1 * this.y;
                return this.x = e1 * this.x - r * this.y, this.y = n, this;
            },
            _rotateAround: function(t1, e1) {
                var r = Math.cos(t1), n = Math.sin(t1), i = e1.y + n * (this.x - e1.x) + r * (this.y - e1.y);
                return this.x = e1.x + r * (this.x - e1.x) - n * (this.y - e1.y), this.y = i, this;
            },
            _round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
        }, g.convert = function(t1) {
            return t1 instanceof g ? t1 : Array.isArray(t1) ? new g(t1[0], t1[1]) : t1;
        };
        var x = p(m);
        const v = Math.PI / 180, b = 180 / Math.PI;
        function w(t1) {
            return t1 * v;
        }
        function _(t1) {
            return t1 * b;
        }
        const A = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function S(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e1 = t1 * t1, r = e1 * t1;
            return 4 * (t1 < .5 ? r : 3 * (t1 - e1) + r - .75);
        }
        function k(t1, e1, r, n) {
            const i = new y(t1, e1, r, n);
            return function(t1) {
                return i.solve(t1);
            };
        }
        const I = k(.25, .1, .25, 1);
        function M(t1, e1, r) {
            return Math.min(r, Math.max(e1, t1));
        }
        function T(t1, e1, r) {
            return (r = M((r - t1) / (e1 - t1), 0, 1)) * r * (3 - 2 * r);
        }
        function z(t1, e1, r) {
            const n = r - e1, i = ((t1 - e1) % n + n) % n + e1;
            return i === e1 ? r : i;
        }
        function B(t1, e1, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let s = null;
            t1.forEach((t1, a)=>{
                e1(t1, (t1, e1)=>{
                    t1 && (s = t1), i[a] = e1, 0 == --n && r(s, i);
                });
            });
        }
        function E(t1) {
            const e1 = [];
            for(const r in t1)e1.push(t1[r]);
            return e1;
        }
        function C(t1, ...e1) {
            for (const r of e1)for(const e1 in r)t1[e1] = r[e1];
            return t1;
        }
        let P = 1;
        function D() {
            return P++;
        }
        function V() {
            return function t1(e1) {
                return e1 ? (e1 ^ Math.random() * (16 >> e1 / 4)).toString(16) : ([
                    1e7
                ] + -[
                    1e3
                ] + -4000 + -8000 + -100000000000).replace(/[018]/g, t1);
            }();
        }
        function L(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }
        function F(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }
        function R(t1, e1) {
            t1.forEach((t1)=>{
                e1[t1] && (e1[t1] = e1[t1].bind(e1));
            });
        }
        function U(t1, e1) {
            return -1 !== t1.indexOf(e1, t1.length - e1.length);
        }
        function $(t1, e1, r) {
            const n = {};
            for(const i in t1)n[i] = e1.call(r || this, t1[i], i, t1);
            return n;
        }
        function j(t1, e1, r) {
            const n = {};
            for(const i in t1)e1.call(r || this, t1[i], i, t1) && (n[i] = t1[i]);
            return n;
        }
        function O(t1) {
            return Array.isArray(t1) ? t1.map(O) : "object" == typeof t1 && t1 ? $(t1, O) : t1;
        }
        const q = {};
        function N(t1) {
            q[t1] || ("undefined" != typeof console && console.warn(t1), q[t1] = !0);
        }
        function G(t1, e1, r) {
            return (r.y - t1.y) * (e1.x - t1.x) > (e1.y - t1.y) * (r.x - t1.x);
        }
        function Z(t1) {
            let e1 = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e1 += (n.x - r.x) * (r.y + n.y);
            return e1;
        }
        function K() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function X(t1) {
            const e1 = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const s = n || i;
                return e1[r] = !s || s.toLowerCase(), "";
            }), e1["max-age"]) {
                const t1 = parseInt(e1["max-age"], 10);
                isNaN(t1) ? delete e1["max-age"] : e1["max-age"] = t1;
            }
            return e1;
        }
        let J = null;
        function H(t1) {
            if (null == J) {
                const e1 = t1.navigator ? t1.navigator.userAgent : null;
                J = !!t1.safari || !(!e1 || !(/\b(iPad|iPhone|iPod)\b/.test(e1) || e1.match("Safari") && !e1.match("Chrome")));
            }
            return J;
        }
        function Y(t1) {
            try {
                const r = e1[t1];
                return r.setItem("_mapbox_test_", 1), r.removeItem("_mapbox_test_"), !0;
            } catch (t1) {
                return !1;
            }
        }
        function W(t1, e1) {
            return [
                t1[4 * e1],
                t1[4 * e1 + 1],
                t1[4 * e1 + 2],
                t1[4 * e1 + 3]
            ];
        }
        const Q = "mapbox-tiles";
        let tt = 500, et = 50;
        let rt, nt;
        function it() {
            try {
                return e1.caches;
            } catch (t1) {}
        }
        function st() {
            it() && !rt && (rt = e1.caches.open(Q));
        }
        function at(t1) {
            const e1 = t1.indexOf("?");
            if (e1 < 0) return t1;
            const r = function(t1) {
                const e1 = t1.indexOf("?");
                return e1 > 0 ? t1.slice(e1 + 1).split("&") : [];
            }(t1), n = r.filter((t1)=>{
                const e1 = t1.split("=");
                return "language" === e1[0] || "worldview" === e1[0];
            });
            return n.length ? `${t1.slice(0, e1)}?${n.join("&")}` : t1.slice(0, e1);
        }
        let ot = 1 / 0;
        const lt = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image"
        };
        "function" == typeof Object.freeze && Object.freeze(lt);
        class ut extends Error {
            constructor(t1, e1, r){
                401 === e1 && bt(r) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e1, this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const ct = K() ? ()=>self.worker && self.worker.referrer : ()=>("blob:" === e1.location.protocol ? e1.parent : e1).location.href;
        const ht = function(t1, r) {
            if (!(/^file:/.test(n = t1.url) || /^file:/.test(ct()) && !/^\w+:/.test(n))) {
                if (e1.fetch && e1.Request && e1.AbortController && e1.Request.prototype.hasOwnProperty("signal")) return function(t1, r) {
                    const n = new e1.AbortController, i = new e1.Request(t1.url, {
                        method: t1.method || "GET",
                        body: t1.body,
                        credentials: t1.credentials,
                        headers: t1.headers,
                        referrer: ct(),
                        referrerPolicy: t1.referrerPolicy,
                        signal: n.signal
                    });
                    let s = !1, a = !1;
                    const o = (l = i.url).indexOf("sku=") > 0 && bt(l);
                    var l;
                    "json" === t1.type && i.headers.set("Accept", "application/json");
                    const u = (n, s, l)=>{
                        if (a) return;
                        if (n && "SecurityError" !== n.message && N(n.toString()), s && l) return c(s);
                        const u = Date.now();
                        e1.fetch(i).then((e1)=>{
                            if (e1.ok) {
                                const t1 = o ? e1.clone() : null;
                                return c(e1, t1, u);
                            }
                            return r(new ut(e1.statusText, e1.status, t1.url));
                        }).catch((e1)=>{
                            "AbortError" !== e1.name && r(new Error(`${e1.message} ${t1.url}`));
                        });
                    }, c = (n, o, l)=>{
                        ("arrayBuffer" === t1.type ? n.arrayBuffer() : "json" === t1.type ? n.json() : n.text()).then((t1)=>{
                            a || (o && l && function(t1, r, n) {
                                if (st(), !rt) return;
                                const i = {
                                    status: r.status,
                                    statusText: r.statusText,
                                    headers: new e1.Headers
                                };
                                r.headers.forEach((t1, e1)=>i.headers.set(e1, t1));
                                const s = X(r.headers.get("Cache-Control") || "");
                                if (s["no-store"]) return;
                                s["max-age"] && i.headers.set("Expires", new Date(n + 1e3 * s["max-age"]).toUTCString());
                                const a = i.headers.get("Expires");
                                a && (new Date(a).getTime() - n < 42e4 || function(t1, e1) {
                                    if (void 0 === nt) try {
                                        new Response(new ReadableStream), nt = !0;
                                    } catch (t1) {
                                        nt = !1;
                                    }
                                    nt ? e1(t1.body) : t1.blob().then(e1);
                                }(r, (r)=>{
                                    const n = new e1.Response(r, i);
                                    st(), rt && rt.then((e1)=>e1.put(at(t1.url), n)).catch((t1)=>N(t1.message));
                                }));
                            }(i, o, l), s = !0, r(null, t1, n.headers.get("Cache-Control"), n.headers.get("Expires")));
                        }).catch((t1)=>{
                            a || r(new Error(t1.message));
                        });
                    };
                    return o ? function(t1, e1) {
                        if (st(), !rt) return e1(null);
                        const r = at(t1.url);
                        rt.then((t1)=>{
                            t1.match(r).then((n)=>{
                                const i = function(t1) {
                                    if (!t1) return !1;
                                    const e1 = new Date(t1.headers.get("Expires") || 0), r = X(t1.headers.get("Cache-Control") || "");
                                    return e1 > Date.now() && !r["no-cache"];
                                }(n);
                                t1.delete(r), i && t1.put(r, n.clone()), e1(null, n, i);
                            }).catch(e1);
                        }).catch(e1);
                    }(i, u) : u(null, null), {
                        cancel: ()=>{
                            a = !0, s || n.abort();
                        }
                    };
                }(t1, r);
                if (K() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t1, r, void 0, !0);
            }
            var n;
            return function(t1, r) {
                const n = new e1.XMLHttpRequest;
                n.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (n.responseType = "arraybuffer");
                for(const e1 in t1.headers)n.setRequestHeader(e1, t1.headers[e1]);
                return "json" === t1.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === t1.credentials, n.onerror = ()=>{
                    r(new Error(n.statusText));
                }, n.onload = ()=>{
                    if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
                        let e1 = n.response;
                        if ("json" === t1.type) try {
                            e1 = JSON.parse(n.response);
                        } catch (t1) {
                            return r(t1);
                        }
                        r(null, e1, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"));
                    } else r(new ut(n.statusText, n.status, t1.url));
                }, n.send(t1.body), {
                    cancel: ()=>n.abort()
                };
            }(t1, r);
        }, pt = function(t1, e1) {
            return ht(C(t1, {
                type: "arrayBuffer"
            }), e1);
        };
        function dt(t1) {
            const r = e1.document.createElement("a");
            return r.href = t1, r.protocol === e1.document.location.protocol && r.host === e1.document.location.host;
        }
        const ft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let yt, mt;
        yt = [], mt = 0;
        const gt = function(t1, r) {
            if (s.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), mt >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
                const e1 = {
                    requestParameters: t1,
                    callback: r,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return yt.push(e1), e1;
            }
            mt++;
            let n = !1;
            const a = ()=>{
                if (!n) for(n = !0, mt--; yt.length && mt < i.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = yt.shift(), { requestParameters: e1, callback: r, cancelled: n } = t1;
                    n || (t1.cancel = gt(e1, r).cancel);
                }
            }, o = pt(t1, (t1, n, i, s)=>{
                a(), t1 ? r(t1) : n && (e1.createImageBitmap ? function(t1, r) {
                    const n = new e1.Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    e1.createImageBitmap(n).then((t1)=>{
                        r(null, t1);
                    }).catch((t1)=>{
                        r(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(n, (t1, e1)=>r(t1, e1, i, s)) : function(t1, r) {
                    const n = new e1.Image, i = e1.URL;
                    n.onload = ()=>{
                        r(null, n), i.revokeObjectURL(n.src), n.onload = null, e1.requestAnimationFrame(()=>{
                            n.src = ft;
                        });
                    }, n.onerror = ()=>r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const s = new e1.Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    n.src = t1.byteLength ? i.createObjectURL(s) : ft;
                }(n, (t1, e1)=>r(t1, e1, i, s)));
            });
            return {
                cancel: ()=>{
                    o.cancel(), a();
                }
            };
        }, xt = "NO_ACCESS_TOKEN";
        function vt(t1) {
            return 0 === t1.indexOf("mapbox:");
        }
        function bt(t1) {
            return i.API_URL_REGEX.test(t1);
        }
        function wt(t1) {
            return i.API_CDN_URL_REGEX.test(t1);
        }
        function _t(t1) {
            return i.API_STYLE_REGEX.test(t1) && !At(t1);
        }
        function At(t1) {
            return i.API_SPRITE_REGEX.test(t1);
        }
        const St = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function kt(t1) {
            const e1 = t1.match(St);
            if (!e1) throw new Error("Unable to parse URL object");
            return {
                protocol: e1[1],
                authority: e1[2],
                path: e1[3] || "/",
                params: e1[4] ? e1[4].split("&") : []
            };
        }
        function It(t1) {
            const e1 = t1.params.length ? `?${t1.params.join("&")}` : "";
            return `${t1.protocol}://${t1.authority}${t1.path}${e1}`;
        }
        const Mt = "mapbox.eventData";
        function Tt(t1) {
            if (!t1) return null;
            const r = t1.split(".");
            if (!r || 3 !== r.length) return null;
            try {
                return JSON.parse(decodeURIComponent(e1.atob(r[1]).split("").map((t1)=>"%" + ("00" + t1.charCodeAt(0).toString(16)).slice(-2)).join("")));
            } catch (t1) {
                return null;
            }
        }
        class zt {
            constructor(t1){
                this.type = t1, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t1) {
                const r = Tt(i.ACCESS_TOKEN);
                let n = "";
                return n = r && r.u ? e1.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, (t1, e1)=>String.fromCharCode(Number("0x" + e1)))) : i.ACCESS_TOKEN || "", t1 ? `${Mt}.${t1}:${n}` : `${Mt}:${n}`;
            }
            fetchEventData() {
                const t1 = Y("localStorage"), r = this.getStorageKey(), n = this.getStorageKey("uuid");
                if (t1) try {
                    const t1 = e1.localStorage.getItem(r);
                    t1 && (this.eventData = JSON.parse(t1));
                    const i = e1.localStorage.getItem(n);
                    i && (this.anonId = i);
                } catch (t1) {
                    N("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
                const t1 = Y("localStorage"), r = this.getStorageKey(), n = this.getStorageKey("uuid");
                if (t1) try {
                    e1.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && e1.localStorage.setItem(r, JSON.stringify(this.eventData));
                } catch (t1) {
                    N("Unable to write to LocalStorage");
                }
            }
            processRequests(t1) {}
            postEvent(t1, e1, r, n) {
                if (!i.EVENTS_URL) return;
                const s = kt(i.EVENTS_URL);
                s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);
                const a = {
                    event: this.type,
                    created: new Date(t1).toISOString()
                }, o = e1 ? C(a, e1) : a, l = {
                    url: It(s),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        o
                    ])
                };
                this.pendingRequest = function(t1, e1) {
                    return ht(C(t1, {
                        method: "POST"
                    }), e1);
                }(l, (t1)=>{
                    this.pendingRequest = null, r(t1), this.saveEventData(), this.processRequests(n);
                });
            }
            queueRequest(t1, e1) {
                this.queue.push(t1), this.processRequests(e1);
            }
        }
        const Bt = new class extends zt {
            constructor(t1){
                super("appUserTurnstile"), this._customAccessToken = t1;
            }
            postTurnstileEvent(t1, e1) {
                i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t1) && t1.some((t1)=>vt(t1) || bt(t1)) && this.queueRequest(Date.now(), e1);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const e1 = Tt(i.ACCESS_TOKEN), n = e1 ? e1.u : i.ACCESS_TOKEN;
                let s = n !== this.eventData.tokenU;
                F(this.anonId) || (this.anonId = V(), s = !0);
                const a = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const t1 = new Date(this.eventData.lastSuccess), e1 = new Date(a), r = (a - this.eventData.lastSuccess) / 864e5;
                    s = s || r >= 1 || r < -1 || t1.getDate() !== e1.getDate();
                } else s = !0;
                s ? this.postEvent(a, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: r,
                    skuId: h,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (t1)=>{
                    t1 || (this.eventData.lastSuccess = a, this.eventData.tokenU = n);
                }, t1) : this.processRequests();
            }
        }, Et = Bt.postTurnstileEvent.bind(Bt), Ct = new class extends zt {
            constructor(){
                super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t1, e1, r, n) {
                this.skuToken = e1, this.errorCb = n, i.EVENTS_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(xt)));
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e1, timestamp: n } = this.queue.shift();
                e1 && this.success[e1] || (this.anonId || this.fetchEventData(), F(this.anonId) || (this.anonId = V()), this.postEvent(n, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: r,
                    skuId: h,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (t1)=>{
                    t1 ? this.errorCb(t1) : e1 && (this.success[e1] = !0);
                }, t1));
            }
        }, Pt = Ct.postMapLoadEvent.bind(Ct), Dt = new class extends zt {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t1, e1) {
                i.EVENTS_URL && (t1 || i.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: e1
                }, t1);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: n, performanceData: i } = this.queue.shift(), s = function(t1) {
                    const n = e1.performance.getEntriesByType("resource"), i = e1.performance.getEntriesByType("mark"), s = function(t1) {
                        const e1 = {};
                        if (t1) {
                            for(const r in t1)if ("other" !== r) for (const n of t1[r]){
                                const t1 = `${r}ResolveRangeMin`, i = `${r}ResolveRangeMax`, s = `${r}RequestCount`, a = `${r}RequestCachedCount`;
                                e1[t1] = Math.min(e1[t1] || 1 / 0, n.startTime), e1[i] = Math.max(e1[i] || -1 / 0, n.responseEnd);
                                const o = (t1)=>{
                                    void 0 === e1[t1] && (e1[t1] = 0), ++e1[t1];
                                };
                                void 0 !== n.transferSize && 0 === n.transferSize && o(a), o(s);
                            }
                        }
                        return e1;
                    }(function(t1, e1) {
                        const r = {};
                        if (t1) for (const n of t1){
                            const t1 = e1(n);
                            void 0 === r[t1] && (r[t1] = []), r[t1].push(n);
                        }
                        return r;
                    }(n, jt)), a = e1.devicePixelRatio, o = e1.navigator.connection || e1.navigator.mozConnection || e1.navigator.webkitConnection, l = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, u = (t1, e1, r)=>{
                        null != r && t1.push({
                            name: e1,
                            value: r.toString()
                        });
                    };
                    for(const t1 in s)u(l.counters, t1, s[t1]);
                    if (t1.interactionRange[0] !== 1 / 0 && t1.interactionRange[1] !== -1 / 0 && (u(l.counters, "interactionRangeMin", t1.interactionRange[0]), u(l.counters, "interactionRangeMax", t1.interactionRange[1])), i) for (const t1 of Object.keys(Ut)){
                        const e1 = Ut[t1], r = i.find((t1)=>t1.name === e1);
                        r && u(l.counters, e1, r.startTime);
                    }
                    return u(l.counters, "visibilityHidden", t1.visibilityHidden), u(l.attributes, "style", function(t1) {
                        if (t1) for (const e1 of t1){
                            const t1 = e1.name.split("?")[0];
                            if (_t(t1)) {
                                const e1 = t1.split("/").slice(-2);
                                if (2 === e1.length) return `mapbox://styles/${e1[0]}/${e1[1]}`;
                            }
                        }
                    }(n)), u(l.attributes, "terrainEnabled", t1.terrainEnabled ? "true" : "false"), u(l.attributes, "fogEnabled", t1.fogEnabled ? "true" : "false"), u(l.attributes, "projection", t1.projection), u(l.attributes, "zoom", t1.zoom), u(l.metadata, "devicePixelRatio", a), u(l.metadata, "connectionEffectiveType", o ? o.effectiveType : void 0), u(l.metadata, "navigatorUserAgent", e1.navigator.userAgent), u(l.metadata, "screenWidth", e1.screen.width), u(l.metadata, "screenHeight", e1.screen.height), u(l.metadata, "windowWidth", e1.innerWidth), u(l.metadata, "windowHeight", e1.innerHeight), u(l.metadata, "mapWidth", t1.width / a), u(l.metadata, "mapHeight", t1.height / a), u(l.metadata, "webglRenderer", t1.renderer), u(l.metadata, "webglVendor", t1.vendor), u(l.metadata, "sdkVersion", r), u(l.metadata, "sdkIdentifier", "mapbox-gl-js"), l;
                }(i);
                for (const t1 of s.metadata);
                for (const t1 of s.counters);
                for (const t1 of s.attributes);
                this.postEvent(n, s, ()=>{}, t1);
            }
        }, Vt = Dt.postPerformanceEvent.bind(Dt), Lt = new class extends zt {
            constructor(){
                super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t1, e1, r, n) {
                if (!i.API_URL || !i.SESSION_PATH) return;
                const s = kt(i.API_URL + i.SESSION_PATH);
                s.params.push(`sku=${e1 || ""}`), s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);
                const a = {
                    url: It(s),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = function(t1, e1) {
                    return ht(C(t1, {
                        method: "GET"
                    }), e1);
                }(a, (t1)=>{
                    this.pendingRequest = null, r(t1), this.saveEventData(), this.processRequests(n);
                });
            }
            getSessionAPI(t1, e1, r, n) {
                this.skuToken = e1, this.errorCb = n, i.SESSION_PATH && i.API_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(xt)));
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e1, timestamp: r } = this.queue.shift();
                e1 && this.success[e1] || this.getSession(r, this.skuToken, (t1)=>{
                    t1 ? this.errorCb(t1) : e1 && (this.success[e1] = !0);
                }, t1);
            }
        }, Ft = Lt.getSessionAPI.bind(Lt), Rt = new Set, Ut = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, $t = {
            mark (t1) {
                e1.performance.mark(t1);
            },
            measure (t1, r, n) {
                e1.performance.measure(t1, r, n);
            }
        };
        function jt(t1) {
            const e1 = t1.name.split("?")[0];
            return wt(e1) && e1.includes("mapbox-gl.js") ? "javascript" : wt(e1) && e1.includes("mapbox-gl.css") ? "css" : function(t1) {
                return i.API_FONTS_REGEX.test(t1);
            }(e1) ? "fontRange" : At(e1) ? "sprite" : _t(e1) ? "style" : function(t1) {
                return i.API_TILEJSON_REGEX.test(t1);
            }(e1) ? "tilejson" : "other";
        }
        const Ot = e1.performance;
        function qt(t1) {
            const e1 = t1 ? t1.url.toString() : void 0;
            return Ot.getEntriesByName(e1);
        }
        let Nt, Gt, Zt, Kt;
        const Xt = {
            now: ()=>void 0 !== Zt ? Zt : e1.performance.now(),
            setNow (t1) {
                Zt = t1;
            },
            restoreNow () {
                Zt = void 0;
            },
            frame (t1) {
                const r = e1.requestAnimationFrame(t1);
                return {
                    cancel: ()=>e1.cancelAnimationFrame(r)
                };
            },
            getImageData (t1, r = 0) {
                const { width: n, height: i } = t1;
                Kt || (Kt = e1.document.createElement("canvas"));
                const s = Kt.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!s) throw new Error("failed to create canvas 2d context");
                return (n > Kt.width || i > Kt.height) && (Kt.width = n, Kt.height = i), s.clearRect(-r, -r, n + 2 * r, i + 2 * r), s.drawImage(t1, 0, 0, n, i), s.getImageData(-r, -r, n + 2 * r, i + 2 * r);
            },
            resolveURL: (t1)=>(Nt || (Nt = e1.document.createElement("a")), Nt.href = t1, Nt.href),
            get devicePixelRatio () {
                return e1.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!e1.matchMedia && (null == Gt && (Gt = e1.matchMedia("(prefers-reduced-motion: reduce)")), Gt.matches);
            }
        };
        function Jt(t1, e1, r) {
            r[t1] && -1 !== r[t1].indexOf(e1) || (r[t1] = r[t1] || [], r[t1].push(e1));
        }
        function Ht(t1, e1, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e1);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class Yt {
            constructor(t1, e1 = {}){
                C(this, e1), this.type = t1;
            }
        }
        class Wt extends Yt {
            constructor(t1, e1 = {}){
                super("error", C({
                    error: t1
                }, e1));
            }
        }
        class Qt {
            on(t1, e1) {
                return this._listeners = this._listeners || {}, Jt(t1, e1, this._listeners), this;
            }
            off(t1, e1) {
                return Ht(t1, e1, this._listeners), Ht(t1, e1, this._oneTimeListeners), this;
            }
            once(t1, e1) {
                return e1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Jt(t1, e1, this._oneTimeListeners), this) : new Promise((e1)=>this.once(t1, e1));
            }
            fire(t1, e1) {
                "string" == typeof t1 && (t1 = new Yt(t1, e1 || {}));
                const r = t1.type;
                if (this.listens(r)) {
                    t1.target = this;
                    const e1 = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
                    for (const r of e1)r.call(this, t1);
                    const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
                    for (const e1 of n)Ht(r, e1, this._oneTimeListeners), e1.call(this, t1);
                    const i = this._eventedParent;
                    i && (C(t1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t1));
                } else t1 instanceof Wt && console.error(t1.error);
                return this;
            }
            listens(t1) {
                return !!(this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1));
            }
            setEventedParent(t1, e1) {
                return this._eventedParent = t1, this._eventedParentData = e1, this;
            }
        }
        var te = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function ee(t1, ...e1) {
            for (const r of e1)for(const e1 in r)t1[e1] = r[e1];
            return t1;
        }
        function re(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function ne(t1) {
            if (Array.isArray(t1)) return t1.map(ne);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e1 = {};
                for(const r in t1)e1[r] = ne(t1[r]);
                return e1;
            }
            return re(t1);
        }
        class ie extends Error {
            constructor(t1, e1){
                super(e1), this.message = e1, this.key = t1;
            }
        }
        var se = ie;
        class ae {
            constructor(t1, e1 = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e1)this.bindings[t1] = r;
            }
            concat(t1) {
                return new ae(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        var oe = ae;
        const le = {
            kind: "null"
        }, ue = {
            kind: "number"
        }, ce = {
            kind: "string"
        }, he = {
            kind: "boolean"
        }, pe = {
            kind: "color"
        }, de = {
            kind: "object"
        }, fe = {
            kind: "value"
        }, ye = {
            kind: "collator"
        }, me = {
            kind: "formatted"
        }, ge = {
            kind: "resolvedImage"
        };
        function xe(t1, e1) {
            return {
                kind: "array",
                itemType: t1,
                N: e1
            };
        }
        function ve(t1) {
            if ("array" === t1.kind) {
                const e1 = ve(t1.itemType);
                return "number" == typeof t1.N ? `array<${e1}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e1}>`;
            }
            return t1.kind;
        }
        const be = [
            le,
            ue,
            ce,
            he,
            pe,
            me,
            de,
            xe(fe),
            ge
        ];
        function we(t1, e1) {
            if ("error" === e1.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e1.kind && (0 === e1.N && "value" === e1.itemType.kind || !we(t1.itemType, e1.itemType)) && ("number" != typeof t1.N || t1.N === e1.N)) return null;
            } else {
                if (t1.kind === e1.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of be)if (!we(t1, e1)) return null;
                }
            }
            return `Expected ${ve(t1)} but found ${ve(e1)} instead.`;
        }
        function _e(t1, e1) {
            return e1.some((e1)=>e1.kind === t1.kind);
        }
        function Ae(t1, e1) {
            return e1.some((e1)=>"null" === e1 ? null === t1 : "array" === e1 ? Array.isArray(t1) : "object" === e1 ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e1 === typeof t1);
        }
        var Se, ke = {
            transparent: [
                0,
                0,
                0,
                0
            ],
            aliceblue: [
                240,
                248,
                255,
                1
            ],
            antiquewhite: [
                250,
                235,
                215,
                1
            ],
            aqua: [
                0,
                255,
                255,
                1
            ],
            aquamarine: [
                127,
                255,
                212,
                1
            ],
            azure: [
                240,
                255,
                255,
                1
            ],
            beige: [
                245,
                245,
                220,
                1
            ],
            bisque: [
                255,
                228,
                196,
                1
            ],
            black: [
                0,
                0,
                0,
                1
            ],
            blanchedalmond: [
                255,
                235,
                205,
                1
            ],
            blue: [
                0,
                0,
                255,
                1
            ],
            blueviolet: [
                138,
                43,
                226,
                1
            ],
            brown: [
                165,
                42,
                42,
                1
            ],
            burlywood: [
                222,
                184,
                135,
                1
            ],
            cadetblue: [
                95,
                158,
                160,
                1
            ],
            chartreuse: [
                127,
                255,
                0,
                1
            ],
            chocolate: [
                210,
                105,
                30,
                1
            ],
            coral: [
                255,
                127,
                80,
                1
            ],
            cornflowerblue: [
                100,
                149,
                237,
                1
            ],
            cornsilk: [
                255,
                248,
                220,
                1
            ],
            crimson: [
                220,
                20,
                60,
                1
            ],
            cyan: [
                0,
                255,
                255,
                1
            ],
            darkblue: [
                0,
                0,
                139,
                1
            ],
            darkcyan: [
                0,
                139,
                139,
                1
            ],
            darkgoldenrod: [
                184,
                134,
                11,
                1
            ],
            darkgray: [
                169,
                169,
                169,
                1
            ],
            darkgreen: [
                0,
                100,
                0,
                1
            ],
            darkgrey: [
                169,
                169,
                169,
                1
            ],
            darkkhaki: [
                189,
                183,
                107,
                1
            ],
            darkmagenta: [
                139,
                0,
                139,
                1
            ],
            darkolivegreen: [
                85,
                107,
                47,
                1
            ],
            darkorange: [
                255,
                140,
                0,
                1
            ],
            darkorchid: [
                153,
                50,
                204,
                1
            ],
            darkred: [
                139,
                0,
                0,
                1
            ],
            darksalmon: [
                233,
                150,
                122,
                1
            ],
            darkseagreen: [
                143,
                188,
                143,
                1
            ],
            darkslateblue: [
                72,
                61,
                139,
                1
            ],
            darkslategray: [
                47,
                79,
                79,
                1
            ],
            darkslategrey: [
                47,
                79,
                79,
                1
            ],
            darkturquoise: [
                0,
                206,
                209,
                1
            ],
            darkviolet: [
                148,
                0,
                211,
                1
            ],
            deeppink: [
                255,
                20,
                147,
                1
            ],
            deepskyblue: [
                0,
                191,
                255,
                1
            ],
            dimgray: [
                105,
                105,
                105,
                1
            ],
            dimgrey: [
                105,
                105,
                105,
                1
            ],
            dodgerblue: [
                30,
                144,
                255,
                1
            ],
            firebrick: [
                178,
                34,
                34,
                1
            ],
            floralwhite: [
                255,
                250,
                240,
                1
            ],
            forestgreen: [
                34,
                139,
                34,
                1
            ],
            fuchsia: [
                255,
                0,
                255,
                1
            ],
            gainsboro: [
                220,
                220,
                220,
                1
            ],
            ghostwhite: [
                248,
                248,
                255,
                1
            ],
            gold: [
                255,
                215,
                0,
                1
            ],
            goldenrod: [
                218,
                165,
                32,
                1
            ],
            gray: [
                128,
                128,
                128,
                1
            ],
            green: [
                0,
                128,
                0,
                1
            ],
            greenyellow: [
                173,
                255,
                47,
                1
            ],
            grey: [
                128,
                128,
                128,
                1
            ],
            honeydew: [
                240,
                255,
                240,
                1
            ],
            hotpink: [
                255,
                105,
                180,
                1
            ],
            indianred: [
                205,
                92,
                92,
                1
            ],
            indigo: [
                75,
                0,
                130,
                1
            ],
            ivory: [
                255,
                255,
                240,
                1
            ],
            khaki: [
                240,
                230,
                140,
                1
            ],
            lavender: [
                230,
                230,
                250,
                1
            ],
            lavenderblush: [
                255,
                240,
                245,
                1
            ],
            lawngreen: [
                124,
                252,
                0,
                1
            ],
            lemonchiffon: [
                255,
                250,
                205,
                1
            ],
            lightblue: [
                173,
                216,
                230,
                1
            ],
            lightcoral: [
                240,
                128,
                128,
                1
            ],
            lightcyan: [
                224,
                255,
                255,
                1
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210,
                1
            ],
            lightgray: [
                211,
                211,
                211,
                1
            ],
            lightgreen: [
                144,
                238,
                144,
                1
            ],
            lightgrey: [
                211,
                211,
                211,
                1
            ],
            lightpink: [
                255,
                182,
                193,
                1
            ],
            lightsalmon: [
                255,
                160,
                122,
                1
            ],
            lightseagreen: [
                32,
                178,
                170,
                1
            ],
            lightskyblue: [
                135,
                206,
                250,
                1
            ],
            lightslategray: [
                119,
                136,
                153,
                1
            ],
            lightslategrey: [
                119,
                136,
                153,
                1
            ],
            lightsteelblue: [
                176,
                196,
                222,
                1
            ],
            lightyellow: [
                255,
                255,
                224,
                1
            ],
            lime: [
                0,
                255,
                0,
                1
            ],
            limegreen: [
                50,
                205,
                50,
                1
            ],
            linen: [
                250,
                240,
                230,
                1
            ],
            magenta: [
                255,
                0,
                255,
                1
            ],
            maroon: [
                128,
                0,
                0,
                1
            ],
            mediumaquamarine: [
                102,
                205,
                170,
                1
            ],
            mediumblue: [
                0,
                0,
                205,
                1
            ],
            mediumorchid: [
                186,
                85,
                211,
                1
            ],
            mediumpurple: [
                147,
                112,
                219,
                1
            ],
            mediumseagreen: [
                60,
                179,
                113,
                1
            ],
            mediumslateblue: [
                123,
                104,
                238,
                1
            ],
            mediumspringgreen: [
                0,
                250,
                154,
                1
            ],
            mediumturquoise: [
                72,
                209,
                204,
                1
            ],
            mediumvioletred: [
                199,
                21,
                133,
                1
            ],
            midnightblue: [
                25,
                25,
                112,
                1
            ],
            mintcream: [
                245,
                255,
                250,
                1
            ],
            mistyrose: [
                255,
                228,
                225,
                1
            ],
            moccasin: [
                255,
                228,
                181,
                1
            ],
            navajowhite: [
                255,
                222,
                173,
                1
            ],
            navy: [
                0,
                0,
                128,
                1
            ],
            oldlace: [
                253,
                245,
                230,
                1
            ],
            olive: [
                128,
                128,
                0,
                1
            ],
            olivedrab: [
                107,
                142,
                35,
                1
            ],
            orange: [
                255,
                165,
                0,
                1
            ],
            orangered: [
                255,
                69,
                0,
                1
            ],
            orchid: [
                218,
                112,
                214,
                1
            ],
            palegoldenrod: [
                238,
                232,
                170,
                1
            ],
            palegreen: [
                152,
                251,
                152,
                1
            ],
            paleturquoise: [
                175,
                238,
                238,
                1
            ],
            palevioletred: [
                219,
                112,
                147,
                1
            ],
            papayawhip: [
                255,
                239,
                213,
                1
            ],
            peachpuff: [
                255,
                218,
                185,
                1
            ],
            peru: [
                205,
                133,
                63,
                1
            ],
            pink: [
                255,
                192,
                203,
                1
            ],
            plum: [
                221,
                160,
                221,
                1
            ],
            powderblue: [
                176,
                224,
                230,
                1
            ],
            purple: [
                128,
                0,
                128,
                1
            ],
            rebeccapurple: [
                102,
                51,
                153,
                1
            ],
            red: [
                255,
                0,
                0,
                1
            ],
            rosybrown: [
                188,
                143,
                143,
                1
            ],
            royalblue: [
                65,
                105,
                225,
                1
            ],
            saddlebrown: [
                139,
                69,
                19,
                1
            ],
            salmon: [
                250,
                128,
                114,
                1
            ],
            sandybrown: [
                244,
                164,
                96,
                1
            ],
            seagreen: [
                46,
                139,
                87,
                1
            ],
            seashell: [
                255,
                245,
                238,
                1
            ],
            sienna: [
                160,
                82,
                45,
                1
            ],
            silver: [
                192,
                192,
                192,
                1
            ],
            skyblue: [
                135,
                206,
                235,
                1
            ],
            slateblue: [
                106,
                90,
                205,
                1
            ],
            slategray: [
                112,
                128,
                144,
                1
            ],
            slategrey: [
                112,
                128,
                144,
                1
            ],
            snow: [
                255,
                250,
                250,
                1
            ],
            springgreen: [
                0,
                255,
                127,
                1
            ],
            steelblue: [
                70,
                130,
                180,
                1
            ],
            tan: [
                210,
                180,
                140,
                1
            ],
            teal: [
                0,
                128,
                128,
                1
            ],
            thistle: [
                216,
                191,
                216,
                1
            ],
            tomato: [
                255,
                99,
                71,
                1
            ],
            turquoise: [
                64,
                224,
                208,
                1
            ],
            violet: [
                238,
                130,
                238,
                1
            ],
            wheat: [
                245,
                222,
                179,
                1
            ],
            white: [
                255,
                255,
                255,
                1
            ],
            whitesmoke: [
                245,
                245,
                245,
                1
            ],
            yellow: [
                255,
                255,
                0,
                1
            ],
            yellowgreen: [
                154,
                205,
                50,
                1
            ]
        };
        function Ie(t1) {
            return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
        }
        function Me(t1) {
            return Ie("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
        }
        function Te(t1) {
            var e1;
            return (e1 = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e1 > 1 ? 1 : e1;
        }
        function ze(t1, e1, r) {
            return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e1 - t1) * r * 6 : 2 * r < 1 ? e1 : 3 * r < 2 ? t1 + (e1 - t1) * (2 / 3 - r) * 6 : t1;
        }
        try {
            Se = ({}).parseCSSColor = function(t1) {
                var e1, r = t1.replace(/ /g, "").toLowerCase();
                if (r in ke) return ke[r].slice();
                if ("#" === r[0]) return 4 === r.length ? (e1 = parseInt(r.substr(1), 16)) >= 0 && e1 <= 4095 ? [
                    (3840 & e1) >> 4 | (3840 & e1) >> 8,
                    240 & e1 | (240 & e1) >> 4,
                    15 & e1 | (15 & e1) << 4,
                    1
                ] : null : 7 === r.length && (e1 = parseInt(r.substr(1), 16)) >= 0 && e1 <= 16777215 ? [
                    (16711680 & e1) >> 16,
                    (65280 & e1) >> 8,
                    255 & e1,
                    1
                ] : null;
                var n = r.indexOf("("), i = r.indexOf(")");
                if (-1 !== n && i + 1 === r.length) {
                    var s = r.substr(0, n), a = r.substr(n + 1, i - (n + 1)).split(","), o = 1;
                    switch(s){
                        case "rgba":
                            if (4 !== a.length) return null;
                            o = Te(a.pop());
                        case "rgb":
                            return 3 !== a.length ? null : [
                                Me(a[0]),
                                Me(a[1]),
                                Me(a[2]),
                                o
                            ];
                        case "hsla":
                            if (4 !== a.length) return null;
                            o = Te(a.pop());
                        case "hsl":
                            if (3 !== a.length) return null;
                            var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360, u = Te(a[1]), c = Te(a[2]), h = c <= .5 ? c * (u + 1) : c + u - c * u, p = 2 * c - h;
                            return [
                                Ie(255 * ze(p, h, l + 1 / 3)),
                                Ie(255 * ze(p, h, l)),
                                Ie(255 * ze(p, h, l - 1 / 3)),
                                o
                            ];
                        default:
                            return null;
                    }
                }
                return null;
            };
        } catch (t1) {}
        class Be {
            constructor(t1, e1, r, n = 1){
                this.r = t1, this.g = e1, this.b = r, this.a = n;
            }
            static parse(t1) {
                if (!t1) return;
                if (t1 instanceof Be) return t1;
                if ("string" != typeof t1) return;
                const e1 = Se(t1);
                return e1 ? new Be(e1[0] / 255 * e1[3], e1[1] / 255 * e1[3], e1[2] / 255 * e1[3], e1[3]) : void 0;
            }
            toString() {
                const [t1, e1, r, n] = this.toArray();
                return `rgba(${Math.round(t1)},${Math.round(e1)},${Math.round(r)},${n})`;
            }
            toArray() {
                const { r: t1, g: e1, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * t1 / n,
                    255 * e1 / n,
                    255 * r / n,
                    n
                ];
            }
            toArray01() {
                const { r: t1, g: e1, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    t1 / n,
                    e1 / n,
                    r / n,
                    n
                ];
            }
            toArray01PremultipliedAlpha() {
                const { r: t1, g: e1, b: r, a: n } = this;
                return [
                    t1,
                    e1,
                    r,
                    n
                ];
            }
        }
        Be.black = new Be(0, 0, 0, 1), Be.white = new Be(1, 1, 1, 1), Be.transparent = new Be(0, 0, 0, 0), Be.red = new Be(1, 0, 0, 1), Be.blue = new Be(0, 0, 1, 1);
        var Ee = Be;
        class Ce {
            constructor(t1, e1, r){
                this.sensitivity = t1 ? e1 ? "variant" : "case" : e1 ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e1) {
                return this.collator.compare(t1, e1);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class Pe {
            constructor(t1, e1, r, n, i){
                this.text = t1.normalize ? t1.normalize() : t1, this.image = e1, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class De {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new De([
                    new Pe(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || t1.image && 0 !== t1.image.name.length);
            }
            static factory(t1) {
                return t1 instanceof De ? t1 : De.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e1 of this.sections){
                    if (e1.image) {
                        t1.push([
                            "image",
                            e1.image.name
                        ]);
                        continue;
                    }
                    t1.push(e1.text);
                    const r = {};
                    e1.fontStack && (r["text-font"] = [
                        "literal",
                        e1.fontStack.split(",")
                    ]), e1.scale && (r["font-scale"] = e1.scale), e1.textColor && (r["text-color"] = [
                        "rgba"
                    ].concat(e1.textColor.toArray())), t1.push(r);
                }
                return t1;
            }
        }
        class Ve {
            constructor(t1){
                this.name = t1.name, this.available = t1.available;
            }
            toString() {
                return this.name;
            }
            static fromString(t1) {
                return t1 ? new Ve({
                    name: t1,
                    available: !1
                }) : null;
            }
            serialize() {
                return [
                    "image",
                    this.name
                ];
            }
        }
        function Le(t1, e1, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e1 && e1 >= 0 && e1 <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e1,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e1,
                r,
                n
            ] : [
                t1,
                e1,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Fe(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof Ee) return !0;
            if (t1 instanceof Ce) return !0;
            if (t1 instanceof De) return !0;
            if (t1 instanceof Ve) return !0;
            if (Array.isArray(t1)) {
                for (const e1 of t1)if (!Fe(e1)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e1 in t1)if (!Fe(t1[e1])) return !1;
                return !0;
            }
            return !1;
        }
        function Re(t1) {
            if (null === t1) return le;
            if ("string" == typeof t1) return ce;
            if ("boolean" == typeof t1) return he;
            if ("number" == typeof t1) return ue;
            if (t1 instanceof Ee) return pe;
            if (t1 instanceof Ce) return ye;
            if (t1 instanceof De) return me;
            if (t1 instanceof Ve) return ge;
            if (Array.isArray(t1)) {
                const e1 = t1.length;
                let r;
                for (const e1 of t1){
                    const t1 = Re(e1);
                    if (r) {
                        if (r === t1) continue;
                        r = fe;
                        break;
                    }
                    r = t1;
                }
                return xe(r || fe, e1);
            }
            return de;
        }
        function Ue(t1) {
            const e1 = typeof t1;
            return null === t1 ? "" : "string" === e1 || "number" === e1 || "boolean" === e1 ? String(t1) : t1 instanceof Ee || t1 instanceof De || t1 instanceof Ve ? t1.toString() : JSON.stringify(t1);
        }
        class $e {
            constructor(t1, e1){
                this.type = t1, this.value = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!Fe(t1[1])) return e1.error("invalid value");
                const r = t1[1];
                let n = Re(r);
                const i = e1.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new $e(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof Ee ? [
                    "rgba"
                ].concat(this.value.toArray()) : this.value instanceof De ? this.value.serialize() : this.value;
            }
        }
        var je = $e, Oe = class {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        };
        const qe = {
            string: ce,
            number: ue,
            boolean: he,
            object: de
        };
        class Ne {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, s;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in qe) || "object" === r) return e1.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = qe[r], n++;
                    } else i = fe;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e1.error('The length argument to "array" must be a positive integer literal', 2);
                        s = t1[2], n++;
                    }
                    r = xe(i, s);
                } else r = qe[i];
                const s = [];
                for(; n < t1.length; n++){
                    const r = e1.parse(t1[n], n, fe);
                    if (!r) return null;
                    s.push(r);
                }
                return new Ne(r, s);
            }
            evaluate(t1) {
                for(let e1 = 0; e1 < this.args.length; e1++){
                    const r = this.args[e1].evaluate(t1);
                    if (!we(this.type, Re(r))) return r;
                    if (e1 === this.args.length - 1) throw new Oe(`Expected value to be of type ${ve(this.type)}, but found ${ve(Re(r))} instead.`);
                }
                return null;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = this.type, e1 = [
                    t1.kind
                ];
                if ("array" === t1.kind) {
                    const r = t1.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e1.push(r.kind);
                        const n = t1.N;
                        ("number" == typeof n || this.args.length > 1) && e1.push(n);
                    }
                }
                return e1.concat(this.args.map((t1)=>t1.serialize()));
            }
        }
        var Ge = Ne;
        class Ze {
            constructor(t1){
                this.type = me, this.sections = t1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e1.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const s = t1[r];
                    if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;
                        let t1 = null;
                        if (s["font-scale"] && (t1 = e1.parse(s["font-scale"], 1, ue), !t1)) return null;
                        let r = null;
                        if (s["text-font"] && (r = e1.parse(s["text-font"], 1, xe(ce)), !r)) return null;
                        let a = null;
                        if (s["text-color"] && (a = e1.parse(s["text-color"], 1, pe), !a)) return null;
                        const o = n[n.length - 1];
                        o.scale = t1, o.font = r, o.textColor = a;
                    } else {
                        const s = e1.parse(t1[r], 1, fe);
                        if (!s) return null;
                        const a = s.type.kind;
                        if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: s,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Ze(n);
            }
            evaluate(t1) {
                return new De(this.sections.map((e1)=>{
                    const r = e1.content.evaluate(t1);
                    return Re(r) === ge ? new Pe("", r, null, null, null) : new Pe(Ue(r), null, e1.scale ? e1.scale.evaluate(t1) : null, e1.font ? e1.font.evaluate(t1).join(",") : null, e1.textColor ? e1.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e1 of this.sections)t1(e1.content), e1.scale && t1(e1.scale), e1.font && t1(e1.font), e1.textColor && t1(e1.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e1 of this.sections){
                    t1.push(e1.content.serialize());
                    const r = {};
                    e1.scale && (r["font-scale"] = e1.scale.serialize()), e1.font && (r["text-font"] = e1.font.serialize()), e1.textColor && (r["text-color"] = e1.textColor.serialize()), t1.push(r);
                }
                return t1;
            }
        }
        class Ke {
            constructor(t1){
                this.type = ge, this.input = t1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error("Expected two arguments.");
                const r = e1.parse(t1[1], 1, ce);
                return r ? new Ke(r) : e1.error("No image name provided.");
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1), r = Ve.fromString(e1);
                return r && t1.availableImages && (r.available = t1.availableImages.indexOf(e1) > -1), r;
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "image",
                    this.input.serialize()
                ];
            }
        }
        const Xe = {
            "to-boolean": he,
            "to-color": pe,
            "to-number": ue,
            "to-string": ce
        };
        class Je {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                const r = t1[0];
                if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e1.error("Expected one argument.");
                const n = Xe[r], i = [];
                for(let r = 1; r < t1.length; r++){
                    const n = e1.parse(t1[r], r, fe);
                    if (!n) return null;
                    i.push(n);
                }
                return new Je(n, i);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e1, r;
                    for (const n of this.args){
                        if (e1 = n.evaluate(t1), r = null, e1 instanceof Ee) return e1;
                        if ("string" == typeof e1) {
                            const r = t1.parseColor(e1);
                            if (r) return r;
                        } else if (Array.isArray(e1) && (r = e1.length < 3 || e1.length > 4 ? `Invalid rbga value ${JSON.stringify(e1)}: expected an array containing either three or four numeric values.` : Le(e1[0], e1[1], e1[2], e1[3]), !r)) return new Ee(e1[0] / 255, e1[1] / 255, e1[2] / 255, e1[3]);
                    }
                    throw new Oe(r || `Could not parse color from value '${"string" == typeof e1 ? e1 : String(JSON.stringify(e1))}'`);
                }
                if ("number" === this.type.kind) {
                    let e1 = null;
                    for (const r of this.args){
                        if (e1 = r.evaluate(t1), null === e1) return 0;
                        const n = Number(e1);
                        if (!isNaN(n)) return n;
                    }
                    throw new Oe(`Could not convert ${JSON.stringify(e1)} to number.`);
                }
                return "formatted" === this.type.kind ? De.fromString(Ue(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? Ve.fromString(Ue(this.args[0].evaluate(t1))) : Ue(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                if ("formatted" === this.type.kind) return new Ze([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new Ke(this.args[0]).serialize();
                const t1 = [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        var He = Je;
        const Ye = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        var We = class {
            constructor(){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Ye[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t1 = this.featureDistanceData.center, e1 = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e1 - t1[0]) + this.featureDistanceData.bearing[1] * (n * e1 - t1[1]);
                }
                return 0;
            }
            parseColor(t1) {
                let e1 = this._parseColorCache[t1];
                return e1 || (e1 = this._parseColorCache[t1] = Ee.parse(t1)), e1;
            }
        };
        class Qe {
            constructor(t1, e1, r, n){
                this.name = t1, this.type = e1, this._evaluate = r, this.args = n;
            }
            evaluate(t1) {
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t1)=>t1.serialize()));
            }
            static parse(t1, e1) {
                const r = t1[0], n = Qe.definitions[r];
                if (!n) return e1.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, s = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, a = s.filter(([e1])=>!Array.isArray(e1) || e1.length === t1.length - 1);
                let o = null;
                for (const [n, s] of a){
                    o = new Ir(e1.registry, e1.path, null, e1.scope);
                    const a = [];
                    let l = !1;
                    for(let e1 = 1; e1 < t1.length; e1++){
                        const r = t1[e1], i = Array.isArray(n) ? n[e1 - 1] : n.type, s = o.parse(r, 1 + a.length, i);
                        if (!s) {
                            l = !0;
                            break;
                        }
                        a.push(s);
                    }
                    if (!l) {
                        if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);
                        else {
                            for(let t1 = 0; t1 < a.length; t1++){
                                const e1 = Array.isArray(n) ? n[t1] : n.type, r = a[t1];
                                o.concat(t1 + 1).checkSubtype(e1, r.type);
                            }
                            if (0 === o.errors.length) return new Qe(r, i, s, a);
                        }
                    }
                }
                if (1 === a.length) e1.errors.push(...o.errors);
                else {
                    const r = (a.length ? a : s).map(([t1])=>{
                        var e1;
                        return e1 = t1, Array.isArray(e1) ? `(${e1.map(ve).join(", ")})` : `(${ve(e1.type)}...)`;
                    }).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e1.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(ve(i.type));
                    }
                    e1.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e1) {
                Qe.definitions = e1;
                for(const r in e1)t1[r] = Qe;
            }
        }
        var tr = Qe;
        class er {
            constructor(t1, e1, r){
                this.type = ye, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e1.error("Collator options argument must be an object.");
                const n = e1.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, he);
                if (!n) return null;
                const i = e1.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, he);
                if (!i) return null;
                let s = null;
                return r.locale && (s = e1.parse(r.locale, 1, ce), !s) ? null : new er(n, i, s);
            }
            evaluate(t1) {
                return new Ce(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return t1["case-sensitive"] = this.caseSensitive.serialize(), t1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t1.locale = this.locale.serialize()), [
                    "collator",
                    t1
                ];
            }
        }
        const rr = 8192;
        function nr(t1, e1) {
            t1[0] = Math.min(t1[0], e1[0]), t1[1] = Math.min(t1[1], e1[1]), t1[2] = Math.max(t1[2], e1[0]), t1[3] = Math.max(t1[3], e1[1]);
        }
        function ir(t1, e1) {
            return !(t1[0] <= e1[0] || t1[2] >= e1[2] || t1[1] <= e1[1] || t1[3] >= e1[3]);
        }
        function sr(t1, e1) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e1.z);
            return [
                Math.round(r * i * rr),
                Math.round(n * i * rr)
            ];
        }
        function ar(t1, e1, r) {
            const n = t1[0] - e1[0], i = t1[1] - e1[1], s = t1[0] - r[0], a = t1[1] - r[1];
            return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;
        }
        function or(t1, e1) {
            let r = !1;
            for(let a = 0, o = e1.length; a < o; a++){
                const o = e1[a];
                for(let e1 = 0, a = o.length; e1 < a - 1; e1++){
                    if (ar(t1, o[e1], o[e1 + 1])) return !1;
                    (i = o[e1])[1] > (n = t1)[1] != (s = o[e1 + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);
                }
            }
            var n, i, s;
            return r;
        }
        function lr(t1, e1) {
            for(let r = 0; r < e1.length; r++)if (or(t1, e1[r])) return !0;
            return !1;
        }
        function ur(t1, e1, r, n) {
            const i = n[0] - r[0], s = n[1] - r[1], a = (t1[0] - r[0]) * s - i * (t1[1] - r[1]), o = (e1[0] - r[0]) * s - i * (e1[1] - r[1]);
            return a > 0 && o < 0 || a < 0 && o > 0;
        }
        function cr(t1, e1, r) {
            for (const u of r)for(let r = 0; r < u.length - 1; ++r)if (0 != (o = [
                (a = u[r + 1])[0] - (s = u[r])[0],
                a[1] - s[1]
            ])[0] * (l = [
                (i = e1)[0] - (n = t1)[0],
                i[1] - n[1]
            ])[1] - o[1] * l[0] && ur(n, i, s, a) && ur(s, a, n, i)) return !0;
            var n, i, s, a, o, l;
            return !1;
        }
        function hr(t1, e1) {
            for(let r = 0; r < t1.length; ++r)if (!or(t1[r], e1)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (cr(t1[r], t1[r + 1], e1)) return !1;
            return !0;
        }
        function pr(t1, e1) {
            for(let r = 0; r < e1.length; r++)if (hr(t1, e1[r])) return !0;
            return !1;
        }
        function dr(t1, e1, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = [];
                for(let n = 0; n < t1[i].length; n++){
                    const a = sr(t1[i][n], r);
                    nr(e1, a), s.push(a);
                }
                n.push(s);
            }
            return n;
        }
        function fr(t1, e1, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = dr(t1[i], e1, r);
                n.push(s);
            }
            return n;
        }
        function yr(t1, e1, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e1 = .5 * n;
                let i = t1[0] - r[0] > e1 ? -n : r[0] - t1[0] > e1 ? n : 0;
                0 === i && (i = t1[0] - r[2] > e1 ? -n : r[2] - t1[0] > e1 ? n : 0), t1[0] += i;
            }
            nr(e1, t1);
        }
        function mr(t1, e1, r, n) {
            const i = Math.pow(2, n.z) * rr, s = [
                n.x * rr,
                n.y * rr
            ], a = [];
            if (!t1) return a;
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + s[0],
                    t1.y + s[1]
                ];
                yr(n, e1, r, i), a.push(n);
            }
            return a;
        }
        function gr(t1, e1, r, n) {
            const i = Math.pow(2, n.z) * rr, s = [
                n.x * rr,
                n.y * rr
            ], a = [];
            if (!t1) return a;
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + s[0],
                        n.y + s[1]
                    ];
                    nr(e1, r), t1.push(r);
                }
                a.push(t1);
            }
            if (e1[2] - e1[0] <= i / 2) {
                (o = e1)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
                for (const t1 of a)for (const n of t1)yr(n, e1, r, i);
            }
            var o;
            return a;
        }
        class xr {
            constructor(t1, e1){
                this.type = he, this.geojson = t1, this.geometries = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (Fe(t1[1])) {
                    const e1 = t1[1];
                    if ("FeatureCollection" === e1.type) for(let t1 = 0; t1 < e1.features.length; ++t1){
                        const r = e1.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new xr(e1, e1.features[t1].geometry);
                    }
                    else if ("Feature" === e1.type) {
                        const t1 = e1.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new xr(e1, e1.geometry);
                    } else if ("Polygon" === e1.type || "MultiPolygon" === e1.type) return new xr(e1, e1);
                }
                return e1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e1) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e1.type) {
                            const s = dr(e1.coordinates, n, i), a = mr(t1.geometry(), r, n, i);
                            if (!ir(r, n)) return !1;
                            for (const t1 of a)if (!or(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e1.type) {
                            const s = fr(e1.coordinates, n, i), a = mr(t1.geometry(), r, n, i);
                            if (!ir(r, n)) return !1;
                            for (const t1 of a)if (!lr(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e1) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e1.type) {
                            const s = dr(e1.coordinates, n, i), a = gr(t1.geometry(), r, n, i);
                            if (!ir(r, n)) return !1;
                            for (const t1 of a)if (!hr(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e1.type) {
                            const s = fr(e1.coordinates, n, i), a = gr(t1.geometry(), r, n, i);
                            if (!ir(r, n)) return !1;
                            for (const t1 of a)if (!pr(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        var vr = xr;
        function br(t1) {
            if (t1 instanceof tr) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof vr) return !1;
            let e1 = !0;
            return t1.eachChild((t1)=>{
                e1 && !br(t1) && (e1 = !1);
            }), e1;
        }
        function wr(t1) {
            if (t1 instanceof tr && "feature-state" === t1.name) return !1;
            let e1 = !0;
            return t1.eachChild((t1)=>{
                e1 && !wr(t1) && (e1 = !1);
            }), e1;
        }
        function _r(t1, e1) {
            if (t1 instanceof tr && e1.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !_r(t1, e1) && (r = !1);
            }), r;
        }
        class Ar {
            constructor(t1, e1){
                this.type = e1.type, this.name = t1, this.boundExpression = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e1.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e1.scope.has(r) ? new Ar(r, e1.scope.get(r)) : e1.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        var Sr = Ar;
        class kr {
            constructor(t1, e1 = [], r, n = new oe, i = []){
                this.registry = t1, this.path = e1, this.key = e1.map((t1)=>`[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r;
            }
            parse(t1, e1, r, n, i = {}) {
                return e1 ? this.concat(e1, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            _parse(t1, e1) {
                function r(t1, e1, r) {
                    return "assert" === r ? new Ge(e1, [
                        t1
                    ]) : "coerce" === r ? new He(e1, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = t1[0];
                    if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                    const i = this.registry[n];
                    if (i) {
                        let n = i.parse(t1, this);
                        if (!n) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, i = n.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== i.kind) {
                                if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== i.kind && "string" !== i.kind) {
                                    if (this.checkSubtype(t1, i)) return null;
                                } else n = r(n, t1, e1.typeAnnotation || "coerce");
                            } else n = r(n, t1, e1.typeAnnotation || "assert");
                        }
                        if (!(n instanceof je) && "resolvedImage" !== n.type.kind && Mr(n)) {
                            const t1 = new We;
                            try {
                                n = new je(n.type, n.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return n;
                    }
                    return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e1, r) {
                const n = "number" == typeof t1 ? this.path.concat(t1) : this.path, i = r ? this.scope.concat(r) : this.scope;
                return new kr(this.registry, n, e1 || null, i, this.errors);
            }
            error(t1, ...e1) {
                const r = `${this.key}${e1.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new se(r, t1));
            }
            checkSubtype(t1, e1) {
                const r = we(t1, e1);
                return r && this.error(r), r;
            }
        }
        var Ir = kr;
        function Mr(t1) {
            if (t1 instanceof Sr) return Mr(t1.boundExpression);
            if (t1 instanceof tr && "error" === t1.name) return !1;
            if (t1 instanceof er) return !1;
            if (t1 instanceof vr) return !1;
            const e1 = t1 instanceof He || t1 instanceof Ge;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e1 ? r && Mr(t1) : r && t1 instanceof je;
            }), !!r && br(t1) && _r(t1, [
                "zoom",
                "heatmap-density",
                "line-progress",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center"
            ]);
        }
        function Tr(t1, e1) {
            const r = t1.length - 1;
            let n, i, s = 0, a = r, o = 0;
            for(; s <= a;)if (o = Math.floor((s + a) / 2), n = t1[o], i = t1[o + 1], n <= e1) {
                if (o === r || e1 < i) return o;
                s = o + 1;
            } else {
                if (!(n > e1)) throw new Oe("Input is not a number.");
                a = o - 1;
            }
            return 0;
        }
        class zr {
            constructor(t1, e1, r){
                this.type = t1, this.input = e1, this.labels = [], this.outputs = [];
                for (const [t1, e1] of r)this.labels.push(t1), this.outputs.push(e1);
            }
            static parse(t1, e1) {
                if (t1.length - 1 < 4) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e1.error("Expected an even number of arguments.");
                const r = e1.parse(t1[1], 1, ue);
                if (!r) return null;
                const n = [];
                let i = null;
                e1.expectedType && "value" !== e1.expectedType.kind && (i = e1.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const s = 1 === r ? -1 / 0 : t1[r], a = t1[r + 1], o = r, l = r + 1;
                    if ("number" != typeof s) return e1.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= s) return e1.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e1.parse(a, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        s,
                        u
                    ]);
                }
                return new zr(i, r, n);
            }
            evaluate(t1) {
                const e1 = this.labels, r = this.outputs;
                if (1 === e1.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e1[0]) return r[0].evaluate(t1);
                const i = e1.length;
                return n >= e1[i - 1] ? r[i - 1].evaluate(t1) : r[Tr(e1, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e1 of this.outputs)t1(e1);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e1 = 0; e1 < this.labels.length; e1++)e1 > 0 && t1.push(this.labels[e1]), t1.push(this.outputs[e1].serialize());
                return t1;
            }
        }
        var Br = zr;
        function Er(t1, e1, r) {
            return t1 * (1 - r) + e1 * r;
        }
        var Cr = Object.freeze({
            __proto__: null,
            array: function(t1, e1, r) {
                return t1.map((t1, n)=>Er(t1, e1[n], r));
            },
            color: function(t1, e1, r) {
                return new Ee(Er(t1.r, e1.r, r), Er(t1.g, e1.g, r), Er(t1.b, e1.b, r), Er(t1.a, e1.a, r));
            },
            number: Er
        });
        const Pr = .95047, Dr = 1.08883, Vr = 4 / 29, Lr = 6 / 29, Fr = 3 * Lr * Lr, Rr = Lr * Lr * Lr, Ur = Math.PI / 180, $r = 180 / Math.PI;
        function jr(t1) {
            return t1 > Rr ? Math.pow(t1, 1 / 3) : t1 / Fr + Vr;
        }
        function Or(t1) {
            return t1 > Lr ? t1 * t1 * t1 : Fr * (t1 - Vr);
        }
        function qr(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function Nr(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function Gr(t1) {
            const e1 = Nr(t1.r), r = Nr(t1.g), n = Nr(t1.b), i = jr((.4124564 * e1 + .3575761 * r + .1804375 * n) / Pr), s = jr((.2126729 * e1 + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * s - 16,
                a: 500 * (i - s),
                b: 200 * (s - jr((.0193339 * e1 + .119192 * r + .9503041 * n) / Dr)),
                alpha: t1.a
            };
        }
        function Zr(t1) {
            let e1 = (t1.l + 16) / 116, r = isNaN(t1.a) ? e1 : e1 + t1.a / 500, n = isNaN(t1.b) ? e1 : e1 - t1.b / 200;
            return e1 = 1 * Or(e1), r = Pr * Or(r), n = Dr * Or(n), new Ee(qr(3.2404542 * r - 1.5371385 * e1 - .4985314 * n), qr(-0.969266 * r + 1.8760108 * e1 + .041556 * n), qr(.0556434 * r - .2040259 * e1 + 1.0572252 * n), t1.alpha);
        }
        function Kr(t1, e1, r) {
            const n = e1 - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const Xr = {
            forward: Gr,
            reverse: Zr,
            interpolate: function(t1, e1, r) {
                return {
                    l: Er(t1.l, e1.l, r),
                    a: Er(t1.a, e1.a, r),
                    b: Er(t1.b, e1.b, r),
                    alpha: Er(t1.alpha, e1.alpha, r)
                };
            }
        }, Jr = {
            forward: function(t1) {
                const { l: e1, a: r, b: n } = Gr(t1), i = Math.atan2(n, r) * $r;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e1,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e1 = t1.h * Ur, r = t1.c;
                return Zr({
                    l: t1.l,
                    a: Math.cos(e1) * r,
                    b: Math.sin(e1) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e1, r) {
                return {
                    h: Kr(t1.h, e1.h, r),
                    c: Er(t1.c, e1.c, r),
                    l: Er(t1.l, e1.l, r),
                    alpha: Er(t1.alpha, e1.alpha, r)
                };
            }
        };
        var Hr = Object.freeze({
            __proto__: null,
            hcl: Jr,
            lab: Xr
        });
        class Yr {
            constructor(t1, e1, r, n, i){
                this.type = t1, this.operator = e1, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
                for (const [t1, e1] of i)this.labels.push(t1), this.outputs.push(e1);
            }
            static interpolationFactor(t1, e1, r, n) {
                let i = 0;
                if ("exponential" === t1.name) i = Wr(e1, t1.base, r, n);
                else if ("linear" === t1.name) i = Wr(e1, 1, r, n);
                else if ("cubic-bezier" === t1.name) {
                    const s = t1.controlPoints;
                    i = new y(s[0], s[1], s[2], s[3]).solve(Wr(e1, 1, r, n));
                }
                return i;
            }
            static parse(t1, e1) {
                let [r, n, i, ...s] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e1.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e1.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e1.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 4) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e1.error("Expected an even number of arguments.");
                if (i = e1.parse(i, 2, ue), !i) return null;
                const a = [];
                let o = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? o = pe : e1.expectedType && "value" !== e1.expectedType.kind && (o = e1.expectedType);
                for(let t1 = 0; t1 < s.length; t1 += 2){
                    const r = s[t1], n = s[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e1.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (a.length && a[a.length - 1][0] >= r) return e1.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e1.parse(n, l, o);
                    if (!u) return null;
                    o = o || u.type, a.push([
                        r,
                        u
                    ]);
                }
                return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Yr(o, r, n, i, a) : e1.error(`Type ${ve(o)} is not interpolatable.`);
            }
            evaluate(t1) {
                const e1 = this.labels, r = this.outputs;
                if (1 === e1.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e1[0]) return r[0].evaluate(t1);
                const i = e1.length;
                if (n >= e1[i - 1]) return r[i - 1].evaluate(t1);
                const s = Tr(e1, n), a = Yr.interpolationFactor(this.interpolation, n, e1[s], e1[s + 1]), o = r[s].evaluate(t1), l = r[s + 1].evaluate(t1);
                return "interpolate" === this.operator ? Cr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? Jr.reverse(Jr.interpolate(Jr.forward(o), Jr.forward(l), a)) : Xr.reverse(Xr.interpolate(Xr.forward(o), Xr.forward(l), a));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e1 of this.outputs)t1(e1);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                let t1;
                t1 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier"
                ].concat(this.interpolation.controlPoints);
                const e1 = [
                    this.operator,
                    t1,
                    this.input.serialize()
                ];
                for(let t1 = 0; t1 < this.labels.length; t1++)e1.push(this.labels[t1], this.outputs[t1].serialize());
                return e1;
            }
        }
        function Wr(t1, e1, r, n) {
            const i = n - r, s = t1 - r;
            return 0 === i ? 0 : 1 === e1 ? s / i : (Math.pow(e1, s) - 1) / (Math.pow(e1, i) - 1);
        }
        var Qr = Yr;
        class tn {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expectected at least one argument.");
                let r = null;
                const n = e1.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e1.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                const s = n && i.some((t1)=>we(n, t1.type));
                return new tn(s ? fe : r, i);
            }
            evaluate(t1) {
                let e1, r = null, n = 0;
                for (const i of this.args){
                    if (n++, r = i.evaluate(t1), r && r instanceof Ve && !r.available && (e1 || (e1 = r), r = null, n === this.args.length)) return e1;
                    if (null !== r) break;
                }
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "coalesce"
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        var en = tn;
        class rn {
            constructor(t1, e1){
                this.type = e1.type, this.bindings = [].concat(t1), this.result = e1;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e1 of this.bindings)t1(e1[1]);
                t1(this.result);
            }
            static parse(t1, e1) {
                if (t1.length < 4) return e1.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e1.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e1.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const s = e1.parse(t1[n + 1], n + 1);
                    if (!s) return null;
                    r.push([
                        i,
                        s
                    ]);
                }
                const n = e1.parse(t1[t1.length - 1], t1.length - 1, e1.expectedType, r);
                return n ? new rn(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t1 = [
                    "let"
                ];
                for (const [e1, r] of this.bindings)t1.push(e1, r.serialize());
                return t1.push(this.result.serialize()), t1;
            }
        }
        var nn = rn;
        class sn {
            constructor(t1, e1, r){
                this.type = t1, this.index = e1, this.input = r;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, ue), n = e1.parse(t1[2], 2, xe(e1.expectedType || fe));
                return r && n ? new sn(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e1 = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e1 < 0) throw new Oe(`Array index out of bounds: ${e1} < 0.`);
                if (e1 >= r.length) throw new Oe(`Array index out of bounds: ${e1} > ${r.length - 1}.`);
                if (e1 !== Math.floor(e1)) throw new Oe(`Array index must be an integer, but found ${e1} instead.`);
                return r[e1];
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        var an = sn;
        class on {
            constructor(t1, e1){
                this.type = he, this.needle = t1, this.haystack = e1;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, fe), n = e1.parse(t1[2], 2, fe);
                return r && n ? _e(r.type, [
                    he,
                    ce,
                    ue,
                    le,
                    fe
                ]) ? new on(r, n) : e1.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e1 = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (null == r) return !1;
                if (!Ae(e1, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e1))} instead.`);
                if (!Ae(r, [
                    "string",
                    "array"
                ])) throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r))} instead.`);
                return r.indexOf(e1) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        var ln = on;
        class un {
            constructor(t1, e1, r){
                this.type = ue, this.needle = t1, this.haystack = e1, this.fromIndex = r;
            }
            static parse(t1, e1) {
                if (t1.length <= 2 || t1.length >= 5) return e1.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, fe), n = e1.parse(t1[2], 2, fe);
                if (!r || !n) return null;
                if (!_e(r.type, [
                    he,
                    ce,
                    ue,
                    le,
                    fe
                ])) return e1.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e1.parse(t1[3], 3, ue);
                    return i ? new un(r, n, i) : null;
                }
                return new un(r, n);
            }
            evaluate(t1) {
                const e1 = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!Ae(e1, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e1))} instead.`);
                if (!Ae(r, [
                    "string",
                    "array"
                ])) throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e1, n);
                }
                return r.indexOf(e1);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t1 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t1
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        var cn = un;
        class hn {
            constructor(t1, e1, r, n, i, s){
                this.inputType = t1, this.type = e1, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
            }
            static parse(t1, e1) {
                if (t1.length < 5) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e1.error("Expected an even number of arguments.");
                let r, n;
                e1.expectedType && "value" !== e1.expectedType.kind && (n = e1.expectedType);
                const i = {}, s = [];
                for(let a = 2; a < t1.length - 1; a += 2){
                    let o = t1[a];
                    const l = t1[a + 1];
                    Array.isArray(o) || (o = [
                        o
                    ]);
                    const u = e1.concat(a);
                    if (0 === o.length) return u.error("Expected at least one branch label.");
                    for (const t1 of o){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, Re(t1))) return null;
                        } else r = Re(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = s.length;
                    }
                    const c = e1.parse(l, a, n);
                    if (!c) return null;
                    n = n || c.type, s.push(c);
                }
                const a = e1.parse(t1[1], 1, fe);
                if (!a) return null;
                const o = e1.parse(t1[t1.length - 1], t1.length - 1, n);
                return o ? "value" !== a.type.kind && e1.concat(1).checkSubtype(r, a.type) ? null : new hn(r, n, a, i, s, o) : null;
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1);
                return (Re(e1) === this.inputType && this.outputs[this.cases[e1]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "match",
                    this.input.serialize()
                ], e1 = Object.keys(this.cases).sort(), r = [], n = {};
                for (const t1 of e1){
                    const e1 = n[this.cases[t1]];
                    void 0 === e1 ? (n[this.cases[t1]] = r.length, r.push([
                        this.cases[t1],
                        [
                            t1
                        ]
                    ])) : r[e1][1].push(t1);
                }
                const i = (t1)=>"number" === this.inputType.kind ? Number(t1) : t1;
                for (const [e1, n] of r)t1.push(1 === n.length ? i(n[0]) : n.map(i)), t1.push(this.outputs[e1].serialize());
                return t1.push(this.otherwise.serialize()), t1;
            }
        }
        var pn = hn;
        class dn {
            constructor(t1, e1, r){
                this.type = t1, this.branches = e1, this.otherwise = r;
            }
            static parse(t1, e1) {
                if (t1.length < 4) return e1.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e1.error("Expected an odd number of arguments.");
                let r;
                e1.expectedType && "value" !== e1.expectedType.kind && (r = e1.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const s = e1.parse(t1[i], i, he);
                    if (!s) return null;
                    const a = e1.parse(t1[i + 1], i + 1, r);
                    if (!a) return null;
                    n.push([
                        s,
                        a
                    ]), r = r || a.type;
                }
                const i = e1.parse(t1[t1.length - 1], t1.length - 1, r);
                return i ? new dn(r, n, i) : null;
            }
            evaluate(t1) {
                for (const [e1, r] of this.branches)if (e1.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e1, r] of this.branches)t1(e1), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e1])=>e1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "case"
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        var fn = dn;
        class yn {
            constructor(t1, e1, r, n){
                this.type = t1, this.input = e1, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e1) {
                if (t1.length <= 2 || t1.length >= 5) return e1.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, fe), n = e1.parse(t1[2], 2, ue);
                if (!r || !n) return null;
                if (!_e(r.type, [
                    xe(fe),
                    ce,
                    fe
                ])) return e1.error(`Expected first argument to be of type array or string, but found ${ve(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e1.parse(t1[3], 3, ue);
                    return i ? new yn(r.type, r, n, i) : null;
                }
                return new yn(r.type, r, n);
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!Ae(e1, [
                    "string",
                    "array"
                ])) throw new Oe(`Expected first argument to be of type array or string, but found ${ve(Re(e1))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e1.slice(r, n);
                }
                return e1.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t1 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t1
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        var mn = yn;
        function gn(t1, e1) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e1.kind || "string" === e1.kind || "number" === e1.kind || "null" === e1.kind || "value" === e1.kind : "string" === e1.kind || "number" === e1.kind || "value" === e1.kind;
        }
        function xn(t1, e1, r, n) {
            return 0 === n.compare(e1, r);
        }
        function vn(t1, e1, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e1, r){
                    this.type = he, this.lhs = t1, this.rhs = e1, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e1.type.kind;
                }
                static parse(t1, e1) {
                    if (3 !== t1.length && 4 !== t1.length) return e1.error("Expected two or three arguments.");
                    const r = t1[0];
                    let s = e1.parse(t1[1], 1, fe);
                    if (!s) return null;
                    if (!gn(r, s.type)) return e1.concat(1).error(`"${r}" comparisons are not supported for type '${ve(s.type)}'.`);
                    let a = e1.parse(t1[2], 2, fe);
                    if (!a) return null;
                    if (!gn(r, a.type)) return e1.concat(2).error(`"${r}" comparisons are not supported for type '${ve(a.type)}'.`);
                    if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e1.error(`Cannot compare types '${ve(s.type)}' and '${ve(a.type)}'.`);
                    n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new Ge(a.type, [
                        s
                    ]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new Ge(s.type, [
                        a
                    ])));
                    let o = null;
                    if (4 === t1.length) {
                        if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e1.error("Cannot use collator to compare non-string types.");
                        if (o = e1.parse(t1[3], 3, ye), !o) return null;
                    }
                    return new i(s, a, o);
                }
                evaluate(i) {
                    const s = this.lhs.evaluate(i), a = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e1 = Re(s), r = Re(a);
                        if (e1.kind !== r.kind || "string" !== e1.kind && "number" !== e1.kind) throw new Oe(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e1.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = Re(s), r = Re(a);
                        if ("string" !== t1.kind || "string" !== r.kind) return e1(i, s, a);
                    }
                    return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e1(i, s, a);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e1 = [
                        t1
                    ];
                    return this.eachChild((t1)=>{
                        e1.push(t1.serialize());
                    }), e1;
                }
            };
        }
        const bn = vn("==", function(t1, e1, r) {
            return e1 === r;
        }, xn), wn = vn("!=", function(t1, e1, r) {
            return e1 !== r;
        }, function(t1, e1, r, n) {
            return !xn(0, e1, r, n);
        }), _n = vn("<", function(t1, e1, r) {
            return e1 < r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) < 0;
        }), An = vn(">", function(t1, e1, r) {
            return e1 > r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) > 0;
        }), Sn = vn("<=", function(t1, e1, r) {
            return e1 <= r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) <= 0;
        }), kn = vn(">=", function(t1, e1, r) {
            return e1 >= r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) >= 0;
        });
        class In {
            constructor(t1, e1, r, n, i, s){
                this.type = ce, this.number = t1, this.locale = e1, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error("Expected two arguments.");
                const r = e1.parse(t1[1], 1, ue);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e1.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e1.parse(n.locale, 1, ce), !i)) return null;
                let s = null;
                if (n.currency && (s = e1.parse(n.currency, 1, ce), !s)) return null;
                let a = null;
                if (n.unit && (a = e1.parse(n.unit, 1, ce), !a)) return null;
                let o = null;
                if (n["min-fraction-digits"] && (o = e1.parse(n["min-fraction-digits"], 1, ue), !o)) return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e1.parse(n["max-fraction-digits"], 1, ue), !l) ? null : new In(r, i, s, a, o, l);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    unit: this.unit ? this.unit.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.unit && t1(this.unit), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return this.locale && (t1.locale = this.locale.serialize()), this.currency && (t1.currency = this.currency.serialize()), this.unit && (t1.unit = this.unit.serialize()), this.minFractionDigits && (t1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t1
                ];
            }
        }
        class Mn {
            constructor(t1){
                this.type = ue, this.input = t1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e1.error(`Expected argument of type string or array, but found ${ve(r.type)} instead.`) : new Mn(r) : null;
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1);
                if ("string" == typeof e1) return e1.length;
                if (Array.isArray(e1)) return e1.length;
                throw new Oe(`Expected value to be of type string or array, but found ${ve(Re(e1))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "length"
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        const Tn = {
            "==": bn,
            "!=": wn,
            ">": An,
            "<": _n,
            ">=": kn,
            "<=": Sn,
            array: Ge,
            at: an,
            boolean: Ge,
            case: fn,
            coalesce: en,
            collator: er,
            format: Ze,
            image: Ke,
            in: ln,
            "index-of": cn,
            interpolate: Qr,
            "interpolate-hcl": Qr,
            "interpolate-lab": Qr,
            length: Mn,
            let: nn,
            literal: je,
            match: pn,
            number: Ge,
            "number-format": In,
            object: Ge,
            slice: mn,
            step: Br,
            string: Ge,
            "to-boolean": He,
            "to-color": He,
            "to-number": He,
            "to-string": He,
            var: Sr,
            within: vr
        };
        function zn(t1, [e1, r, n, i]) {
            e1 = e1.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, a = Le(e1, r, n, s);
            if (a) throw new Oe(a);
            return new Ee(e1 / 255 * s, r / 255 * s, n / 255 * s, s);
        }
        function Bn(t1, e1) {
            return t1 in e1;
        }
        function En(t1, e1) {
            const r = e1[t1];
            return void 0 === r ? null : r;
        }
        function Cn(t1) {
            return {
                type: t1
            };
        }
        tr.register(Tn, {
            error: [
                {
                    kind: "error"
                },
                [
                    ce
                ],
                (t1, [e1])=>{
                    throw new Oe(e1.evaluate(t1));
                }
            ],
            typeof: [
                ce,
                [
                    fe
                ],
                (t1, [e1])=>ve(Re(e1.evaluate(t1)))
            ],
            "to-rgba": [
                xe(ue, 4),
                [
                    pe
                ],
                (t1, [e1])=>e1.evaluate(t1).toArray()
            ],
            rgb: [
                pe,
                [
                    ue,
                    ue,
                    ue
                ],
                zn
            ],
            rgba: [
                pe,
                [
                    ue,
                    ue,
                    ue,
                    ue
                ],
                zn
            ],
            has: {
                type: he,
                overloads: [
                    [
                        [
                            ce
                        ],
                        (t1, [e1])=>Bn(e1.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            ce,
                            de
                        ],
                        (t1, [e1, r])=>Bn(e1.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: fe,
                overloads: [
                    [
                        [
                            ce
                        ],
                        (t1, [e1])=>En(e1.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            ce,
                            de
                        ],
                        (t1, [e1, r])=>En(e1.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                fe,
                [
                    ce
                ],
                (t1, [e1])=>En(e1.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                de,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                ce,
                [],
                (t1)=>t1.geometryType()
            ],
            id: [
                fe,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                ue,
                [],
                (t1)=>t1.globals.zoom
            ],
            pitch: [
                ue,
                [],
                (t1)=>t1.globals.pitch || 0
            ],
            "distance-from-center": [
                ue,
                [],
                (t1)=>t1.distanceFromCenter()
            ],
            "heatmap-density": [
                ue,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                ue,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            "sky-radial-progress": [
                ue,
                [],
                (t1)=>t1.globals.skyRadialProgress || 0
            ],
            accumulated: [
                fe,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                ue,
                Cn(ue),
                (t1, e1)=>{
                    let r = 0;
                    for (const n of e1)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                ue,
                Cn(ue),
                (t1, e1)=>{
                    let r = 1;
                    for (const n of e1)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: ue,
                overloads: [
                    [
                        [
                            ue,
                            ue
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            ue
                        ],
                        (t1, [e1])=>-e1.evaluate(t1)
                    ]
                ]
            },
            "/": [
                ue,
                [
                    ue,
                    ue
                ],
                (t1, [e1, r])=>e1.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                ue,
                [
                    ue,
                    ue
                ],
                (t1, [e1, r])=>e1.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                ue,
                [],
                ()=>Math.LN2
            ],
            pi: [
                ue,
                [],
                ()=>Math.PI
            ],
            e: [
                ue,
                [],
                ()=>Math.E
            ],
            "^": [
                ue,
                [
                    ue,
                    ue
                ],
                (t1, [e1, r])=>Math.pow(e1.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.sqrt(e1.evaluate(t1))
            ],
            log10: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1)) / Math.LN10
            ],
            ln: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1))
            ],
            log2: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1)) / Math.LN2
            ],
            sin: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.sin(e1.evaluate(t1))
            ],
            cos: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.cos(e1.evaluate(t1))
            ],
            tan: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.tan(e1.evaluate(t1))
            ],
            asin: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.asin(e1.evaluate(t1))
            ],
            acos: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.acos(e1.evaluate(t1))
            ],
            atan: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.atan(e1.evaluate(t1))
            ],
            min: [
                ue,
                Cn(ue),
                (t1, e1)=>Math.min(...e1.map((e1)=>e1.evaluate(t1)))
            ],
            max: [
                ue,
                Cn(ue),
                (t1, e1)=>Math.max(...e1.map((e1)=>e1.evaluate(t1)))
            ],
            abs: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.abs(e1.evaluate(t1))
            ],
            round: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>{
                    const r = e1.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.floor(e1.evaluate(t1))
            ],
            ceil: [
                ue,
                [
                    ue
                ],
                (t1, [e1])=>Math.ceil(e1.evaluate(t1))
            ],
            "filter-==": [
                he,
                [
                    ce,
                    fe
                ],
                (t1, [e1, r])=>t1.properties()[e1.value] === r.value
            ],
            "filter-id-==": [
                he,
                [
                    fe
                ],
                (t1, [e1])=>t1.id() === e1.value
            ],
            "filter-type-==": [
                he,
                [
                    ce
                ],
                (t1, [e1])=>t1.geometryType() === e1.value
            ],
            "filter-<": [
                he,
                [
                    ce,
                    fe
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                he,
                [
                    fe
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                he,
                [
                    ce,
                    fe
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                he,
                [
                    fe
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                he,
                [
                    ce,
                    fe
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                he,
                [
                    fe
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                he,
                [
                    ce,
                    fe
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                he,
                [
                    fe
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                he,
                [
                    fe
                ],
                (t1, [e1])=>e1.value in t1.properties()
            ],
            "filter-has-id": [
                he,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                he,
                [
                    xe(ce)
                ],
                (t1, [e1])=>e1.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                he,
                [
                    xe(fe)
                ],
                (t1, [e1])=>e1.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                he,
                [
                    ce,
                    xe(fe)
                ],
                (t1, [e1, r])=>r.value.indexOf(t1.properties()[e1.value]) >= 0
            ],
            "filter-in-large": [
                he,
                [
                    ce,
                    xe(fe)
                ],
                (t1, [e1, r])=>(function(t1, e1, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e1[i] === t1) return !0;
                            e1[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e1.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: he,
                overloads: [
                    [
                        [
                            he,
                            he
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        Cn(he),
                        (t1, e1)=>{
                            for (const r of e1)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: he,
                overloads: [
                    [
                        [
                            he,
                            he
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        Cn(he),
                        (t1, e1)=>{
                            for (const r of e1)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                he,
                [
                    he
                ],
                (t1, [e1])=>!e1.evaluate(t1)
            ],
            "is-supported-script": [
                he,
                [
                    ce
                ],
                (t1, [e1])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e1.evaluate(t1));
                }
            ],
            upcase: [
                ce,
                [
                    ce
                ],
                (t1, [e1])=>e1.evaluate(t1).toUpperCase()
            ],
            downcase: [
                ce,
                [
                    ce
                ],
                (t1, [e1])=>e1.evaluate(t1).toLowerCase()
            ],
            concat: [
                ce,
                Cn(fe),
                (t1, e1)=>e1.map((e1)=>Ue(e1.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                ce,
                [
                    ye
                ],
                (t1, [e1])=>e1.evaluate(t1).resolvedLocale()
            ]
        });
        var Pn = Tn;
        function Dn(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function Vn(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function Ln(t1) {
            return "data-driven" === t1["property-type"];
        }
        function Fn(t1) {
            return !!t1.expression && t1.expression.parameters.indexOf("zoom") > -1;
        }
        function Rn(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function Un(t1) {
            return t1 instanceof Number ? "number" : t1 instanceof String ? "string" : t1 instanceof Boolean ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : typeof t1;
        }
        function $n(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function jn(t1) {
            return t1;
        }
        function On(t1, e1) {
            const r = "color" === e1.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), s = t1.type || (Rn(e1) ? "exponential" : "interval");
            if (r && ((t1 = ee({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                    t1[0],
                    Ee.parse(t1[1])
                ])), t1.default = Ee.parse(t1.default ? t1.default : e1.default)), t1.colorSpace && "rgb" !== t1.colorSpace && !Hr[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let a, o, l;
            if ("exponential" === s) a = Zn;
            else if ("interval" === s) a = Gn;
            else if ("categorical" === s) {
                a = Nn, o = Object.create(null);
                for (const e1 of t1.stops)o[e1[0]] = e1[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
                a = Kn;
            }
            if (n) {
                const r = {}, n = [];
                for(let e1 = 0; e1 < t1.stops.length; e1++){
                    const i = t1.stops[e1], s = i[0].zoom;
                    void 0 === r[s] && (r[s] = {
                        zoom: s,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(s)), r[s].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    On(r[t1], e1)
                ]);
                const s = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s,
                    interpolationFactor: Qr.interpolationFactor.bind(void 0, s),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r }, n)=>Zn({
                            stops: i,
                            base: t1.base
                        }, e1, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === s ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: Qr.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r })=>a(t1, e1, r, o, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? qn(t1.default, e1.default) : a(t1, e1, i, o, l);
                }
            };
        }
        function qn(t1, e1, r) {
            return void 0 !== t1 ? t1 : void 0 !== e1 ? e1 : void 0 !== r ? r : void 0;
        }
        function Nn(t1, e1, r, n, i) {
            return qn(typeof r === i ? n[r] : void 0, t1.default, e1.default);
        }
        function Gn(t1, e1, r) {
            if ("number" !== Un(r)) return qn(t1.default, e1.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = Tr(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function Zn(t1, e1, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if ("number" !== Un(r)) return qn(t1.default, e1.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const s = Tr(t1.stops.map((t1)=>t1[0]), r), a = function(t1, e1, r, n) {
                const i = n - r, s = t1 - r;
                return 0 === i ? 0 : 1 === e1 ? s / i : (Math.pow(e1, s) - 1) / (Math.pow(e1, i) - 1);
            }(r, n, t1.stops[s][0], t1.stops[s + 1][0]), o = t1.stops[s][1], l = t1.stops[s + 1][1];
            let u = Cr[e1.type] || jn;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e1 = Hr[t1.colorSpace];
                u = (t1, r)=>e1.reverse(e1.interpolate(e1.forward(t1), e1.forward(r), a));
            }
            return "function" == typeof o.evaluate ? {
                evaluate (...t1) {
                    const e1 = o.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e1 && void 0 !== r) return u(e1, r, a);
                }
            } : u(o, l, a);
        }
        function Kn(t1, e1, r) {
            return "color" === e1.type ? r = Ee.parse(r) : "formatted" === e1.type ? r = De.fromString(r.toString()) : "resolvedImage" === e1.type ? r = Ve.fromString(r.toString()) : Un(r) === e1.type || "enum" === e1.type && e1.values[r] || (r = void 0), qn(r, t1.default, e1.default);
        }
        class Xn {
            constructor(t1, e1){
                this.expression = t1, this._warningHistory = {}, this._evaluator = new We, this._defaultValue = e1 ? function(t1) {
                    return "color" === t1.type && ($n(t1.default) || Array.isArray(t1.default)) ? new Ee(0, 0, 0, 0) : "color" === t1.type ? Ee.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e1) : null, this._enumValues = e1 && "enum" === e1.type ? e1.values : null;
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, s, a, o) {
                return this._evaluator.globals = t1, this._evaluator.feature = e1, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e1, r, n, i, s, a, o) {
                this._evaluator.globals = t1, this._evaluator.feature = e1 || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new Oe(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    return this._warningHistory[t1.message] || (this._warningHistory[t1.message] = !0, "undefined" != typeof console && console.warn(t1.message)), this._defaultValue;
                }
            }
        }
        function Jn(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in Pn;
        }
        function Hn(t1, e1) {
            const r = new Ir(Pn, [], e1 ? function(t1) {
                const e1 = {
                    color: pe,
                    string: ce,
                    number: ue,
                    enum: ce,
                    boolean: he,
                    formatted: me,
                    resolvedImage: ge
                };
                return "array" === t1.type ? xe(e1[t1.value] || fe, t1.length) : e1[t1.type];
            }(e1) : void 0), n = r.parse(t1, void 0, void 0, void 0, e1 && "string" === e1.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return n ? Dn(new Xn(n, e1)) : Vn(r.errors);
        }
        class Yn {
            constructor(t1, e1){
                this.kind = t1, this._styleExpression = e1, this.isStateDependent = "constant" !== t1 && !wr(e1.expression);
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e1, r, n, i, s);
            }
            evaluate(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e1, r, n, i, s);
            }
        }
        class Wn {
            constructor(t1, e1, r, n){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e1, this.isStateDependent = "camera" !== t1 && !wr(e1.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e1, r, n, i, s);
            }
            evaluate(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e1, r, n, i, s);
            }
            interpolationFactor(t1, e1, r) {
                return this.interpolationType ? Qr.interpolationFactor(this.interpolationType, t1, e1, r) : 0;
            }
        }
        function Qn(t1, e1) {
            if ("error" === (t1 = Hn(t1, e1)).result) return t1;
            const r = t1.value.expression, n = br(r);
            if (!n && !Ln(e1)) return Vn([
                new se("", "data expressions not supported")
            ]);
            const i = _r(r, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!i && !Fn(e1)) return Vn([
                new se("", "zoom expressions not supported")
            ]);
            const s = ei(r);
            return s || i ? s instanceof se ? Vn([
                s
            ]) : s instanceof Qr && !Rn(e1) ? Vn([
                new se("", '"interpolate" expressions cannot be used with this property')
            ]) : Dn(s ? new Wn(n ? "camera" : "composite", t1.value, s.labels, s instanceof Qr ? s.interpolation : void 0) : new Yn(n ? "constant" : "source", t1.value)) : Vn([
                new se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
            ]);
        }
        class ti {
            constructor(t1, e1){
                this._parameters = t1, this._specification = e1, ee(this, On(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new ti(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function ei(t1) {
            let e1 = null;
            if (t1 instanceof nn) e1 = ei(t1.result);
            else if (t1 instanceof en) {
                for (const r of t1.args)if (e1 = ei(r), e1) break;
            } else (t1 instanceof Br || t1 instanceof Qr) && t1.input instanceof tr && "zoom" === t1.input.name && (e1 = t1);
            return e1 instanceof se || t1.eachChild((t1)=>{
                const r = ei(t1);
                r instanceof se ? e1 = r : !e1 && r ? e1 = new se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e1 && r && e1 !== r && (e1 = new se("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e1;
        }
        class ri {
            constructor(t1, e1, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e1 && e1.__line__ && (this.line = e1.__line__);
            }
        }
        function ni(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec || {}, i = t1.objectElementValidators || {}, s = t1.style, a = t1.styleSpec;
            let o = [];
            const l = Un(r);
            if ("object" !== l) return [
                new ri(e1, r, `object expected, ${l} found`)
            ];
            for(const t1 in r){
                const l = t1.split(".")[0];
                let u;
                i[l] ? u = i[l] : n[l] ? u = Fi : i["*"] ? u = i["*"] : n["*"] && (u = Fi), u ? o = o.concat(u({
                    key: (e1 ? `${e1}.` : e1) + t1,
                    value: r[t1],
                    valueSpec: n[l] || n["*"],
                    style: s,
                    styleSpec: a,
                    object: r,
                    objectKey: t1
                }, r)) : o.push(new ri(e1, r[t1], `unknown property "${t1}"`));
            }
            for(const t1 in n)i[t1] || n[t1].required && void 0 === n[t1].default && void 0 === r[t1] && o.push(new ri(e1, r, `missing required property "${t1}"`));
            return o;
        }
        function ii(t1) {
            const e1 = t1.value, r = t1.valueSpec, n = t1.style, i = t1.styleSpec, s = t1.key, a = t1.arrayElementValidator || Fi;
            if ("array" !== Un(e1)) return [
                new ri(s, e1, `array expected, ${Un(e1)} found`)
            ];
            if (r.length && e1.length !== r.length) return [
                new ri(s, e1, `array length ${r.length} expected, length ${e1.length} found`)
            ];
            if (r["min-length"] && e1.length < r["min-length"]) return [
                new ri(s, e1, `array length at least ${r["min-length"]} expected, length ${e1.length} found`)
            ];
            let o = {
                type: r.value,
                values: r.values,
                minimum: r.minimum,
                maximum: r.maximum,
                function: void 0
            };
            i.$version < 7 && (o.function = r.function), "object" === Un(r.value) && (o = r.value);
            let l = [];
            for(let t1 = 0; t1 < e1.length; t1++)l = l.concat(a({
                array: e1,
                arrayIndex: t1,
                value: e1[t1],
                valueSpec: o,
                style: n,
                styleSpec: i,
                key: `${s}[${t1}]`
            }));
            return l;
        }
        function si(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec;
            let i = Un(r);
            if ("number" === i && r != r && (i = "NaN"), "number" !== i) return [
                new ri(e1, r, `number expected, ${i} found`)
            ];
            if ("minimum" in n) {
                let i = n.minimum;
                if ("array" === Un(n.minimum) && (i = n.minimum[t1.arrayIndex]), r < i) return [
                    new ri(e1, r, `${r} is less than the minimum value ${i}`)
                ];
            }
            if ("maximum" in n) {
                let i = n.maximum;
                if ("array" === Un(n.maximum) && (i = n.maximum[t1.arrayIndex]), r > i) return [
                    new ri(e1, r, `${r} is greater than the maximum value ${i}`)
                ];
            }
            return [];
        }
        function ai(t1) {
            const e1 = t1.valueSpec, r = re(t1.value.type);
            let n, i, s, a = {};
            const o = "categorical" !== r && void 0 === t1.value.property, l = !o, u = "array" === Un(t1.value.stops) && "array" === Un(t1.value.stops[0]) && "object" === Un(t1.value.stops[0][0]), c = ni({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === r) return [
                            new ri(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let e1 = [];
                        const n = t1.value;
                        return e1 = e1.concat(ii({
                            key: t1.key,
                            value: n,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: h
                        })), "array" === Un(n) && 0 === n.length && e1.push(new ri(t1.key, n, "array must have at least one stop")), e1;
                    },
                    default: function(t1) {
                        return Fi({
                            key: t1.key,
                            value: t1.value,
                            valueSpec: e1,
                            style: t1.style,
                            styleSpec: t1.styleSpec
                        });
                    }
                }
            });
            return "identity" === r && o && c.push(new ri(t1.key, t1.value, 'missing required property "property"')), "identity" === r || t1.value.stops || c.push(new ri(t1.key, t1.value, 'missing required property "stops"')), "exponential" === r && t1.valueSpec.expression && !Rn(t1.valueSpec) && c.push(new ri(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (l && !Ln(t1.valueSpec) ? c.push(new ri(t1.key, t1.value, "property functions not supported")) : o && !Fn(t1.valueSpec) && c.push(new ri(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t1.value.property || c.push(new ri(t1.key, t1.value, '"property" property is required')), c;
            function h(t1) {
                let r = [];
                const n = t1.value, o = t1.key;
                if ("array" !== Un(n)) return [
                    new ri(o, n, `array expected, ${Un(n)} found`)
                ];
                if (2 !== n.length) return [
                    new ri(o, n, `array length 2 expected, length ${n.length} found`)
                ];
                if (u) {
                    if ("object" !== Un(n[0])) return [
                        new ri(o, n, `object expected, ${Un(n[0])} found`)
                    ];
                    if (void 0 === n[0].zoom) return [
                        new ri(o, n, "object stop key must have zoom")
                    ];
                    if (void 0 === n[0].value) return [
                        new ri(o, n, "object stop key must have value")
                    ];
                    const e1 = re(n[0].zoom);
                    if ("number" != typeof e1) return [
                        new ri(o, n[0].zoom, "stop zoom values must be numbers")
                    ];
                    if (s && s > e1) return [
                        new ri(o, n[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    e1 !== s && (s = e1, i = void 0, a = {}), r = r.concat(ni({
                        key: `${o}[0]`,
                        value: n[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: si,
                            value: p
                        }
                    }));
                } else r = r.concat(p({
                    key: `${o}[0]`,
                    value: n[0],
                    valueSpec: {},
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, n));
                return Jn(ne(n[1])) ? r.concat([
                    new ri(`${o}[1]`, n[1], "expressions are not allowed in function stops.")
                ]) : r.concat(Fi({
                    key: `${o}[1]`,
                    value: n[1],
                    valueSpec: e1,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function p(t1, s) {
                const o = Un(t1.value), l = re(t1.value), u = null !== t1.value ? t1.value : s;
                if (n) {
                    if (o !== n) return [
                        new ri(t1.key, u, `${o} stop domain type must match previous stop domain type ${n}`)
                    ];
                } else n = o;
                if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l) return [
                    new ri(t1.key, u, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== o && "categorical" !== r) {
                    let n = `number expected, ${o} found`;
                    return Ln(e1) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new ri(t1.key, u, n)
                    ];
                }
                return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof i && void 0 !== i && l < i ? [
                    new ri(t1.key, u, "stop domain values must appear in ascending order")
                ] : (i = l, "categorical" === r && l in a ? [
                    new ri(t1.key, u, "stop domain values must be unique")
                ] : (a[l] = !0, [])) : [
                    new ri(t1.key, u, `integer expected, found ${String(l)}`)
                ];
            }
        }
        function oi(t1) {
            const e1 = ("property" === t1.expressionContext ? Qn : Hn)(ne(t1.value), t1.valueSpec);
            if ("error" === e1.result) return e1.value.map((e1)=>new ri(`${t1.key}${e1.key}`, t1.value, e1.message));
            const r = e1.value.expression || e1.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !r.outputDefined()) return [
                new ri(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !wr(r)) return [
                new ri(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext) return li(r, t1);
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!_r(r, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new ri(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !br(r)) return [
                    new ri(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function li(t1, e1) {
            const r = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (e1.valueSpec && e1.valueSpec.expression) for (const t1 of e1.valueSpec.expression.parameters)r.delete(t1);
            if (0 === r.size) return [];
            const n = [];
            return t1 instanceof tr && r.has(t1.name) ? [
                new ri(e1.key, e1.value, `["${t1.name}"] expression is not supported in a filter for a ${e1.object.type} layer with id: ${e1.object.id}`)
            ] : (t1.eachChild((t1)=>{
                n.push(...li(t1, e1));
            }), n);
        }
        function ui(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec, i = [];
            return Array.isArray(n.values) ? -1 === n.values.indexOf(re(r)) && i.push(new ri(e1, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(re(r)) && i.push(new ri(e1, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i;
        }
        function ci(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e1 of t1.slice(1))if (!ci(e1) && "boolean" != typeof e1) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function hi(t1, e1 = "fill") {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1,
                needFeature: !1
            };
            ci(t1) || (t1 = xi(t1));
            const r = t1;
            let n = !0;
            try {
                n = function(t1) {
                    if (!fi(t1)) return t1;
                    let e1 = ne(t1);
                    return di(e1), e1 = pi(e1), e1;
                }(r);
            } catch (t1) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
            }
            const i = te[`filter_${e1}`], s = Hn(n, i);
            let a = null;
            if ("error" === s.result) throw new Error(s.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
            a = (t1, e1, r)=>s.value.evaluate(t1, e1, {}, r);
            let o = null, l = null;
            if (n !== r) {
                const t1 = Hn(r, i);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                o = (e1, r, n, i, s)=>t1.value.evaluate(e1, r, {}, n, void 0, void 0, i, s), l = !br(t1.value.expression);
            }
            return {
                filter: a,
                dynamicFilter: o || void 0,
                needGeometry: gi(n),
                needFeature: !!l
            };
        }
        function pi(t1) {
            if (!Array.isArray(t1)) return t1;
            const e1 = function(t1) {
                if (yi.has(t1[0])) {
                    for(let e1 = 1; e1 < t1.length; e1++)if (fi(t1[e1])) return !0;
                }
                return t1;
            }(t1);
            return !0 === e1 ? e1 : e1.map((t1)=>pi(t1));
        }
        function di(t1) {
            let e1 = !1;
            const r = [];
            if ("case" === t1[0]) {
                for(let n = 1; n < t1.length - 1; n += 2)e1 = e1 || fi(t1[n]), r.push(t1[n + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("match" === t1[0]) {
                e1 = e1 || fi(t1[1]);
                for(let e1 = 2; e1 < t1.length - 1; e1 += 2)r.push(t1[e1 + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("step" === t1[0]) {
                e1 = e1 || fi(t1[1]);
                for(let e1 = 1; e1 < t1.length - 1; e1 += 2)r.push(t1[e1 + 1]);
            }
            e1 && (t1.length = 0, t1.push("any", ...r));
            for(let e1 = 1; e1 < t1.length; e1++)di(t1[e1]);
        }
        function fi(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("pitch" === (e1 = t1[0]) || "distance-from-center" === e1) return !0;
            var e1;
            for(let e1 = 1; e1 < t1.length; e1++)if (fi(t1[e1])) return !0;
            return !1;
        }
        const yi = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function mi(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function gi(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0]) return !0;
            for(let e1 = 1; e1 < t1.length; e1++)if (gi(t1[e1])) return !0;
            return !1;
        }
        function xi(t1) {
            if (!t1) return !0;
            const e1 = t1[0];
            var r;
            return t1.length <= 1 ? "any" !== e1 : "==" === e1 ? vi(t1[1], t1[2], "==") : "!=" === e1 ? _i(vi(t1[1], t1[2], "==")) : "<" === e1 || ">" === e1 || "<=" === e1 || ">=" === e1 ? vi(t1[1], t1[2], e1) : "any" === e1 ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(xi))) : "all" === e1 ? [
                "all"
            ].concat(t1.slice(1).map(xi)) : "none" === e1 ? [
                "all"
            ].concat(t1.slice(1).map(xi).map(_i)) : "in" === e1 ? bi(t1[1], t1.slice(2)) : "!in" === e1 ? _i(bi(t1[1], t1.slice(2))) : "has" === e1 ? wi(t1[1]) : "!has" === e1 ? _i(wi(t1[1])) : "within" !== e1 || t1;
        }
        function vi(t1, e1, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e1
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e1
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e1
                    ];
            }
        }
        function bi(t1, e1) {
            if (0 === e1.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e1
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e1
                        ]
                    ];
                default:
                    return e1.length > 200 && !e1.some((t1)=>typeof t1 != typeof e1[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e1.sort(mi)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e1
                        ]
                    ];
            }
        }
        function wi(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function _i(t1) {
            return [
                "!",
                t1
            ];
        }
        function Ai(t1) {
            return ci(ne(t1.value)) ? oi(ee({}, t1, {
                expressionContext: "filter",
                valueSpec: t1.styleSpec[`filter_${t1.layerType || "fill"}`]
            })) : Si(t1);
        }
        function Si(t1) {
            const e1 = t1.value, r = t1.key;
            if ("array" !== Un(e1)) return [
                new ri(r, e1, `array expected, ${Un(e1)} found`)
            ];
            const n = t1.styleSpec;
            let i, s = [];
            if (e1.length < 1) return [
                new ri(r, e1, "filter array must have at least 1 element")
            ];
            switch(s = s.concat(ui({
                key: `${r}[0]`,
                value: e1[0],
                valueSpec: n.filter_operator,
                style: t1.style,
                styleSpec: t1.styleSpec
            })), re(e1[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    e1.length >= 2 && "$type" === re(e1[1]) && s.push(new ri(r, e1, `"$type" cannot be use with operator "${e1[0]}"`));
                case "==":
                case "!=":
                    3 !== e1.length && s.push(new ri(r, e1, `filter array for operator "${e1[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    e1.length >= 2 && (i = Un(e1[1]), "string" !== i && s.push(new ri(`${r}[1]`, e1[1], `string expected, ${i} found`)));
                    for(let a = 2; a < e1.length; a++)i = Un(e1[a]), "$type" === re(e1[1]) ? s = s.concat(ui({
                        key: `${r}[${a}]`,
                        value: e1[a],
                        valueSpec: n.geometry_type,
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new ri(`${r}[${a}]`, e1[a], `string, number, or boolean expected, ${i} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let n = 1; n < e1.length; n++)s = s.concat(Si({
                        key: `${r}[${n}]`,
                        value: e1[n],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    i = Un(e1[1]), 2 !== e1.length ? s.push(new ri(r, e1, `filter array for "${e1[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new ri(`${r}[1]`, e1[1], `string expected, ${i} found`));
                    break;
                case "within":
                    i = Un(e1[1]), 2 !== e1.length ? s.push(new ri(r, e1, `filter array for "${e1[0]}" operator must have 2 elements`)) : "object" !== i && s.push(new ri(`${r}[1]`, e1[1], `object expected, ${i} found`));
            }
            return s;
        }
        function ki(t1, e1) {
            const r = t1.key, n = t1.style, i = t1.styleSpec, s = t1.value, a = t1.objectKey, o = i[`${e1}_${t1.layerType}`];
            if (!o) return [];
            const l = a.match(/^(.*)-transition$/);
            if ("paint" === e1 && l && o[l[1]] && o[l[1]].transition) return Fi({
                key: r,
                value: s,
                valueSpec: i.transition,
                style: n,
                styleSpec: i
            });
            const u = t1.valueSpec || o[a];
            if (!u) return [
                new ri(r, s, `unknown property "${a}"`)
            ];
            let c;
            if ("string" === Un(s) && Ln(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) {
                const t1 = `\`{ "type": "identity", "property": ${c ? JSON.stringify(c[1]) : '"_"'} }\``;
                return [
                    new ri(r, s, `"${a}" does not support interpolation syntax\nUse an identity property function instead: ${t1}.`)
                ];
            }
            const h = [];
            return "symbol" === t1.layerType && ("text-field" === a && n && !n.glyphs && h.push(new ri(r, s, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && $n(ne(s)) && "identity" === re(s.type) && h.push(new ri(r, s, '"text-font" does not support identity functions'))), h.concat(Fi({
                key: t1.key,
                value: s,
                valueSpec: u,
                style: n,
                styleSpec: i,
                expressionContext: "property",
                propertyType: e1,
                propertyKey: a
            }));
        }
        function Ii(t1) {
            return ki(t1, "paint");
        }
        function Mi(t1) {
            return ki(t1, "layout");
        }
        function Ti(t1) {
            let e1 = [];
            const r = t1.value, n = t1.key, i = t1.style, s = t1.styleSpec;
            r.type || r.ref || e1.push(new ri(n, r, 'either "type" or "ref" is required'));
            let a = re(r.type);
            const o = re(r.ref);
            if (r.id) {
                const s = re(r.id);
                for(let a = 0; a < t1.arrayIndex; a++){
                    const t1 = i.layers[a];
                    re(t1.id) === s && e1.push(new ri(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in r) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in r && e1.push(new ri(n, r[t1], `"${t1}" is prohibited for ref layers`));
                }), i.layers.forEach((e1)=>{
                    re(e1.id) === o && (t1 = e1);
                }), t1 ? t1.ref ? e1.push(new ri(n, r.ref, "ref cannot reference another ref layer")) : a = re(t1.type) : "string" == typeof o && e1.push(new ri(n, r.ref, `ref layer "${o}" not found`));
            } else if ("background" !== a && "sky" !== a) {
                if (r.source) {
                    const t1 = i.sources && i.sources[r.source], s = t1 && re(t1.type);
                    t1 ? "vector" === s && "raster" === a ? e1.push(new ri(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === s && "raster" !== a ? e1.push(new ri(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e1.push(new ri(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] && !r.paint["line-trim-offset"] || "geojson" === s && t1.lineMetrics || e1.push(new ri(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e1.push(new ri(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e1.push(new ri(n, r.source, `source "${r.source}" not found`));
                } else e1.push(new ri(n, r, 'missing required property "source"'));
            }
            return e1 = e1.concat(ni({
                key: n,
                value: r,
                valueSpec: s.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>Fi({
                            key: `${n}.type`,
                            value: r.type,
                            valueSpec: s.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: r,
                            objectKey: "type"
                        }),
                    filter: (t1)=>Ai(ee({
                            layerType: a
                        }, t1)),
                    layout: (t1)=>ni({
                            layer: r,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>Mi(ee({
                                        layerType: a
                                    }, t1))
                            }
                        }),
                    paint: (t1)=>ni({
                            layer: r,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>Ii(ee({
                                        layerType: a
                                    }, t1))
                            }
                        })
                }
            })), e1;
        }
        function zi(t1) {
            const e1 = t1.value, r = t1.key, n = Un(e1);
            return "string" !== n ? [
                new ri(r, e1, `string expected, ${n} found`)
            ] : [];
        }
        const Bi = {
            promoteId: function({ key: t1, value: e1 }) {
                if ("string" === Un(e1)) return zi({
                    key: t1,
                    value: e1
                });
                {
                    const r = [];
                    for(const n in e1)r.push(...zi({
                        key: `${t1}.${n}`,
                        value: e1[n]
                    }));
                    return r;
                }
            }
        };
        function Ei(t1) {
            const e1 = t1.value, r = t1.key, n = t1.styleSpec, i = t1.style;
            if (!e1.type) return [
                new ri(r, e1, '"type" is required')
            ];
            const s = re(e1.type);
            let a;
            switch(s){
                case "vector":
                case "raster":
                case "raster-dem":
                    return a = ni({
                        key: r,
                        value: e1,
                        valueSpec: n[`source_${s.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: n,
                        objectElementValidators: Bi
                    }), a;
                case "geojson":
                    if (a = ni({
                        key: r,
                        value: e1,
                        valueSpec: n.source_geojson,
                        style: i,
                        styleSpec: n,
                        objectElementValidators: Bi
                    }), e1.cluster) for(const t1 in e1.clusterProperties){
                        const [n, i] = e1.clusterProperties[t1], s = "string" == typeof n ? [
                            n,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                t1
                            ]
                        ] : n;
                        a.push(...oi({
                            key: `${r}.${t1}.map`,
                            value: i,
                            expressionContext: "cluster-map"
                        })), a.push(...oi({
                            key: `${r}.${t1}.reduce`,
                            value: s,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return a;
                case "video":
                    return ni({
                        key: r,
                        value: e1,
                        valueSpec: n.source_video,
                        style: i,
                        styleSpec: n
                    });
                case "image":
                    return ni({
                        key: r,
                        value: e1,
                        valueSpec: n.source_image,
                        style: i,
                        styleSpec: n
                    });
                case "canvas":
                    return [
                        new ri(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return ui({
                        key: `${r}.type`,
                        value: e1.type,
                        valueSpec: {
                            values: Ci(n)
                        },
                        style: i,
                        styleSpec: n
                    });
            }
        }
        function Ci(t1) {
            return t1.source.reduce((e1, r)=>{
                const n = t1[r];
                return "enum" === n.type.type && (e1 = e1.concat(Object.keys(n.type.values))), e1;
            }, []);
        }
        function Pi(t1) {
            const e1 = t1.value, r = t1.styleSpec, n = r.light, i = t1.style;
            let s = [];
            const a = Un(e1);
            if (void 0 === e1) return s;
            if ("object" !== a) return s = s.concat([
                new ri("light", e1, `object expected, ${a} found`)
            ]), s;
            for(const t1 in e1){
                const a = t1.match(/^(.*)-transition$/);
                s = s.concat(a && n[a[1]] && n[a[1]].transition ? Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: r.transition,
                    style: i,
                    styleSpec: r
                }) : n[t1] ? Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n[t1],
                    style: i,
                    styleSpec: r
                }) : [
                    new ri(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            return s;
        }
        function Di(t1) {
            const e1 = t1.value, r = t1.key, n = t1.style, i = t1.styleSpec, s = i.terrain;
            let a = [];
            const o = Un(e1);
            if (void 0 === e1) return a;
            if ("object" !== o) return a = a.concat([
                new ri("terrain", e1, `object expected, ${o} found`)
            ]), a;
            for(const t1 in e1){
                const r = t1.match(/^(.*)-transition$/);
                a = a.concat(r && s[r[1]] && s[r[1]].transition ? Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: i.transition,
                    style: n,
                    styleSpec: i
                }) : s[t1] ? Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: s[t1],
                    style: n,
                    styleSpec: i
                }) : [
                    new ri(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            if (e1.source) {
                const t1 = n.sources && n.sources[e1.source], i = t1 && re(t1.type);
                t1 ? "raster-dem" !== i && a.push(new ri(r, e1.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : a.push(new ri(r, e1.source, `source "${e1.source}" not found`));
            } else a.push(new ri(r, e1, 'terrain is missing required property "source"'));
            return a;
        }
        function Vi(t1) {
            const e1 = t1.value, r = t1.style, n = t1.styleSpec, i = n.fog;
            let s = [];
            const a = Un(e1);
            if (void 0 === e1) return s;
            if ("object" !== a) return s = s.concat([
                new ri("fog", e1, `object expected, ${a} found`)
            ]), s;
            for(const t1 in e1){
                const a = t1.match(/^(.*)-transition$/);
                s = s.concat(a && i[a[1]] && i[a[1]].transition ? Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n.transition,
                    style: r,
                    styleSpec: n
                }) : i[t1] ? Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: i[t1],
                    style: r,
                    styleSpec: n
                }) : [
                    new ri(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            return s;
        }
        const Li = {
            "*": ()=>[],
            array: ii,
            boolean: function(t1) {
                const e1 = t1.value, r = t1.key, n = Un(e1);
                return "boolean" !== n ? [
                    new ri(r, e1, `boolean expected, ${n} found`)
                ] : [];
            },
            number: si,
            color: function(t1) {
                const e1 = t1.key, r = t1.value, n = Un(r);
                return "string" !== n ? [
                    new ri(e1, r, `color expected, ${n} found`)
                ] : null === Se(r) ? [
                    new ri(e1, r, `color expected, "${r}" found`)
                ] : [];
            },
            enum: ui,
            filter: Ai,
            function: ai,
            layer: Ti,
            object: ni,
            source: Ei,
            light: Pi,
            terrain: Di,
            fog: Vi,
            string: zi,
            formatted: function(t1) {
                return 0 === zi(t1).length ? [] : oi(t1);
            },
            resolvedImage: function(t1) {
                return 0 === zi(t1).length ? [] : oi(t1);
            },
            projection: function(t1) {
                const e1 = t1.value, r = t1.styleSpec, n = r.projection, i = t1.style;
                let s = [];
                const a = Un(e1);
                if ("object" === a) for(const t1 in e1)s = s.concat(Fi({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n[t1],
                    style: i,
                    styleSpec: r
                }));
                else "string" !== a && (s = s.concat([
                    new ri("projection", e1, `object or string expected, ${a} found`)
                ]));
                return s;
            }
        };
        function Fi(t1) {
            const e1 = t1.value, r = t1.valueSpec, n = t1.styleSpec;
            return r.expression && $n(re(e1)) ? ai(t1) : r.expression && Jn(ne(e1)) ? oi(t1) : r.type && Li[r.type] ? Li[r.type](t1) : ni(ee({}, t1, {
                valueSpec: r.type ? n[r.type] : r
            }));
        }
        function Ri(t1) {
            const e1 = t1.value, r = t1.key, n = zi(t1);
            return n.length || (-1 === e1.indexOf("{fontstack}") && n.push(new ri(r, e1, '"glyphs" url must include a "{fontstack}" token')), -1 === e1.indexOf("{range}") && n.push(new ri(r, e1, '"glyphs" url must include a "{range}" token'))), n;
        }
        function Ui(t1, e1 = te) {
            return Oi(Fi({
                key: "",
                value: t1,
                valueSpec: e1.$root,
                styleSpec: e1,
                style: t1,
                objectElementValidators: {
                    glyphs: Ri,
                    "*": ()=>[]
                }
            }));
        }
        const $i = (t1)=>Oi(Ii(t1)), ji = (t1)=>Oi(Mi(t1));
        function Oi(t1) {
            return t1.slice().sort((t1, e1)=>t1.line && e1.line ? t1.line - e1.line : 0);
        }
        function qi(t1, e1) {
            let r = !1;
            if (e1 && e1.length) for (const n of e1)t1.fire(new Wt(new Error(n.message))), r = !0;
            return r;
        }
        var Ni = Zi, Gi = 3;
        function Zi(t1, e1, r) {
            var n = this.cells = [];
            if (t1 instanceof ArrayBuffer) {
                this.arrayBuffer = t1;
                var i = new Int32Array(this.arrayBuffer);
                t1 = i[0], this.d = (e1 = i[1]) + 2 * (r = i[2]);
                for(var s = 0; s < this.d * this.d; s++){
                    var a = i[Gi + s], o = i[Gi + s + 1];
                    n.push(a === o ? null : i.subarray(a, o));
                }
                var l = i[Gi + n.length + 1];
                this.keys = i.subarray(i[Gi + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
            } else {
                this.d = e1 + 2 * r;
                for(var u = 0; u < this.d * this.d; u++)n.push([]);
                this.keys = [], this.bboxes = [];
            }
            this.n = e1, this.extent = t1, this.padding = r, this.scale = e1 / t1, this.uid = 0;
            var c = r / e1 * t1;
            this.min = -c, this.max = t1 + c;
        }
        Zi.prototype.insert = function(t1, e1, r, n, i) {
            this._forEachCell(e1, r, n, i, this._insertCell, this.uid++), this.keys.push(t1), this.bboxes.push(e1), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
        }, Zi.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Zi.prototype._insertCell = function(t1, e1, r, n, i, s) {
            this.cells[i].push(s);
        }, Zi.prototype.query = function(t1, e1, r, n, i) {
            var s = this.min, a = this.max;
            if (t1 <= s && e1 <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);
            var o = [];
            return this._forEachCell(t1, e1, r, n, this._queryCell, o, {}, i), o;
        }, Zi.prototype._queryCell = function(t1, e1, r, n, i, s, a, o) {
            var l = this.cells[i];
            if (null !== l) for(var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++){
                var p = l[h];
                if (void 0 === a[p]) {
                    var d = 4 * p;
                    (o ? o(c[d + 0], c[d + 1], c[d + 2], c[d + 3]) : t1 <= c[d + 2] && e1 <= c[d + 3] && r >= c[d + 0] && n >= c[d + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
                }
            }
        }, Zi.prototype._forEachCell = function(t1, e1, r, n, i, s, a, o) {
            for(var l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e1), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)for(var d = u; d <= h; d++){
                var f = this.d * d + p;
                if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(d), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(d + 1))) && i.call(this, t1, e1, r, n, f, s, a, o)) return;
            }
        }, Zi.prototype._convertFromCellCoord = function(t1) {
            return (t1 - this.padding) / this.scale;
        }, Zi.prototype._convertToCellCoord = function(t1) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
        }, Zi.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for(var t1 = this.cells, e1 = Gi + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++)r += this.cells[n].length;
            var i = new Int32Array(e1 + r + this.keys.length + this.bboxes.length);
            i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
            for(var s = e1, a = 0; a < t1.length; a++){
                var o = t1[a];
                i[Gi + a] = s, i.set(o, s), s += o.length;
            }
            return i[Gi + t1.length] = s, i.set(this.keys, s), i[Gi + t1.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;
        };
        var Ki = p(Ni);
        const Xi = {};
        function Ji(t1, e1, r = {}) {
            Object.defineProperty(t1, "_classRegistryKey", {
                value: e1,
                writeable: !1
            }), Xi[e1] = {
                klass: t1,
                omit: r.omit || []
            };
        }
        Ji(Object, "Object"), Ki.serialize = function(t1, e1) {
            const r = t1.toArrayBuffer();
            return e1 && e1.push(r), {
                buffer: r
            };
        }, Ki.deserialize = function(t1) {
            return new Ki(t1.buffer);
        }, Object.defineProperty(Ki, "name", {
            value: "Grid"
        }), Ji(Ki, "Grid"), Ji(Ee, "Color"), Ji(Error, "Error"), Ji(ut, "AJAXError"), Ji(Ve, "ResolvedImage"), Ji(ti, "StylePropertyFunction"), Ji(Xn, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), Ji(Wn, "ZoomDependentExpression"), Ji(Yn, "ZoomConstantExpression"), Ji(tr, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in Pn)Xi[Pn[t1]._classRegistryKey] || Ji(Pn[t1], `Expression${t1}`);
        function Hi(t1) {
            return t1 && "undefined" != typeof ArrayBuffer && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function Yi(t1) {
            return e1.ImageBitmap && t1 instanceof e1.ImageBitmap;
        }
        function Wi(t1, r) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp) return t1;
            if (Hi(t1) || Yi(t1)) return r && r.push(t1), t1;
            if (ArrayBuffer.isView(t1)) {
                const e1 = t1;
                return r && r.push(e1.buffer), e1;
            }
            if (t1 instanceof e1.ImageData) return r && r.push(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const e1 = [];
                for (const n of t1)e1.push(Wi(n, r));
                return e1;
            }
            if ("object" == typeof t1) {
                const e1 = t1.constructor, n = e1._classRegistryKey;
                if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);
                const i = e1.serialize ? e1.serialize(t1, r) : {};
                if (!e1.serialize) {
                    for(const e1 in t1)t1.hasOwnProperty(e1) && (Xi[n].omit.indexOf(e1) >= 0 || (i[e1] = Wi(t1[e1], r)));
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function Qi(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || Hi(t1) || Yi(t1) || ArrayBuffer.isView(t1) || t1 instanceof e1.ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(Qi);
            if ("object" == typeof t1) {
                const e1 = t1.$name || "Object", { klass: r } = Xi[e1];
                if (!r) throw new Error(`can't deserialize unregistered class ${e1}`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const e1 of Object.keys(t1))"$name" !== e1 && (n[e1] = Qi(t1[e1]));
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        const ts = {
            "Latin-1 Supplement": (t1)=>t1 >= 128 && t1 <= 255,
            Arabic: (t1)=>t1 >= 1536 && t1 <= 1791,
            "Arabic Supplement": (t1)=>t1 >= 1872 && t1 <= 1919,
            "Arabic Extended-A": (t1)=>t1 >= 2208 && t1 <= 2303,
            "Hangul Jamo": (t1)=>t1 >= 4352 && t1 <= 4607,
            "Unified Canadian Aboriginal Syllabics": (t1)=>t1 >= 5120 && t1 <= 5759,
            Khmer: (t1)=>t1 >= 6016 && t1 <= 6143,
            "Unified Canadian Aboriginal Syllabics Extended": (t1)=>t1 >= 6320 && t1 <= 6399,
            "General Punctuation": (t1)=>t1 >= 8192 && t1 <= 8303,
            "Letterlike Symbols": (t1)=>t1 >= 8448 && t1 <= 8527,
            "Number Forms": (t1)=>t1 >= 8528 && t1 <= 8591,
            "Miscellaneous Technical": (t1)=>t1 >= 8960 && t1 <= 9215,
            "Control Pictures": (t1)=>t1 >= 9216 && t1 <= 9279,
            "Optical Character Recognition": (t1)=>t1 >= 9280 && t1 <= 9311,
            "Enclosed Alphanumerics": (t1)=>t1 >= 9312 && t1 <= 9471,
            "Geometric Shapes": (t1)=>t1 >= 9632 && t1 <= 9727,
            "Miscellaneous Symbols": (t1)=>t1 >= 9728 && t1 <= 9983,
            "Miscellaneous Symbols and Arrows": (t1)=>t1 >= 11008 && t1 <= 11263,
            "CJK Radicals Supplement": (t1)=>t1 >= 11904 && t1 <= 12031,
            "Kangxi Radicals": (t1)=>t1 >= 12032 && t1 <= 12255,
            "Ideographic Description Characters": (t1)=>t1 >= 12272 && t1 <= 12287,
            "CJK Symbols and Punctuation": (t1)=>t1 >= 12288 && t1 <= 12351,
            Hiragana: (t1)=>t1 >= 12352 && t1 <= 12447,
            Katakana: (t1)=>t1 >= 12448 && t1 <= 12543,
            Bopomofo: (t1)=>t1 >= 12544 && t1 <= 12591,
            "Hangul Compatibility Jamo": (t1)=>t1 >= 12592 && t1 <= 12687,
            Kanbun: (t1)=>t1 >= 12688 && t1 <= 12703,
            "Bopomofo Extended": (t1)=>t1 >= 12704 && t1 <= 12735,
            "CJK Strokes": (t1)=>t1 >= 12736 && t1 <= 12783,
            "Katakana Phonetic Extensions": (t1)=>t1 >= 12784 && t1 <= 12799,
            "Enclosed CJK Letters and Months": (t1)=>t1 >= 12800 && t1 <= 13055,
            "CJK Compatibility": (t1)=>t1 >= 13056 && t1 <= 13311,
            "CJK Unified Ideographs Extension A": (t1)=>t1 >= 13312 && t1 <= 19903,
            "Yijing Hexagram Symbols": (t1)=>t1 >= 19904 && t1 <= 19967,
            "CJK Unified Ideographs": (t1)=>t1 >= 19968 && t1 <= 40959,
            "Yi Syllables": (t1)=>t1 >= 40960 && t1 <= 42127,
            "Yi Radicals": (t1)=>t1 >= 42128 && t1 <= 42191,
            "Hangul Jamo Extended-A": (t1)=>t1 >= 43360 && t1 <= 43391,
            "Hangul Syllables": (t1)=>t1 >= 44032 && t1 <= 55215,
            "Hangul Jamo Extended-B": (t1)=>t1 >= 55216 && t1 <= 55295,
            "Private Use Area": (t1)=>t1 >= 57344 && t1 <= 63743,
            "CJK Compatibility Ideographs": (t1)=>t1 >= 63744 && t1 <= 64255,
            "Arabic Presentation Forms-A": (t1)=>t1 >= 64336 && t1 <= 65023,
            "Vertical Forms": (t1)=>t1 >= 65040 && t1 <= 65055,
            "CJK Compatibility Forms": (t1)=>t1 >= 65072 && t1 <= 65103,
            "Small Form Variants": (t1)=>t1 >= 65104 && t1 <= 65135,
            "Arabic Presentation Forms-B": (t1)=>t1 >= 65136 && t1 <= 65279,
            "Halfwidth and Fullwidth Forms": (t1)=>t1 >= 65280 && t1 <= 65519
        };
        function es(t1) {
            for (const e1 of t1)if (is(e1.charCodeAt(0))) return !0;
            return !1;
        }
        function rs(t1) {
            for (const e1 of t1)if (!ns(e1.charCodeAt(0))) return !1;
            return !0;
        }
        function ns(t1) {
            return !(ts.Arabic(t1) || ts["Arabic Supplement"](t1) || ts["Arabic Extended-A"](t1) || ts["Arabic Presentation Forms-A"](t1) || ts["Arabic Presentation Forms-B"](t1));
        }
        function is(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(ts["Bopomofo Extended"](t1) || ts.Bopomofo(t1) || ts["CJK Compatibility Forms"](t1) && !(t1 >= 65097 && t1 <= 65103) || ts["CJK Compatibility Ideographs"](t1) || ts["CJK Compatibility"](t1) || ts["CJK Radicals Supplement"](t1) || ts["CJK Strokes"](t1) || !(!ts["CJK Symbols and Punctuation"](t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || ts["CJK Unified Ideographs Extension A"](t1) || ts["CJK Unified Ideographs"](t1) || ts["Enclosed CJK Letters and Months"](t1) || ts["Hangul Compatibility Jamo"](t1) || ts["Hangul Jamo Extended-A"](t1) || ts["Hangul Jamo Extended-B"](t1) || ts["Hangul Jamo"](t1) || ts["Hangul Syllables"](t1) || ts.Hiragana(t1) || ts["Ideographic Description Characters"](t1) || ts.Kanbun(t1) || ts["Kangxi Radicals"](t1) || ts["Katakana Phonetic Extensions"](t1) || ts.Katakana(t1) && 12540 !== t1 || !(!ts["Halfwidth and Fullwidth Forms"](t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!ts["Small Form Variants"](t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || ts["Unified Canadian Aboriginal Syllabics"](t1) || ts["Unified Canadian Aboriginal Syllabics Extended"](t1) || ts["Vertical Forms"](t1) || ts["Yijing Hexagram Symbols"](t1) || ts["Yi Syllables"](t1) || ts["Yi Radicals"](t1))));
        }
        function ss(t1) {
            return !(is(t1) || function(t1) {
                return !!(ts["Latin-1 Supplement"](t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || ts["General Punctuation"](t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || ts["Letterlike Symbols"](t1) || ts["Number Forms"](t1) || ts["Miscellaneous Technical"](t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || ts["Control Pictures"](t1) && 9251 !== t1 || ts["Optical Character Recognition"](t1) || ts["Enclosed Alphanumerics"](t1) || ts["Geometric Shapes"](t1) || ts["Miscellaneous Symbols"](t1) && !(t1 >= 9754 && t1 <= 9759) || ts["Miscellaneous Symbols and Arrows"](t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || ts["CJK Symbols and Punctuation"](t1) || ts.Katakana(t1) || ts["Private Use Area"](t1) || ts["CJK Compatibility Forms"](t1) || ts["Small Form Variants"](t1) || ts["Halfwidth and Fullwidth Forms"](t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function as(t1) {
            return t1 >= 1424 && t1 <= 2303 || ts["Arabic Presentation Forms-A"](t1) || ts["Arabic Presentation Forms-B"](t1);
        }
        function os(t1, e1) {
            return !(!e1 && as(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || ts.Khmer(t1));
        }
        function ls(t1) {
            for (const e1 of t1)if (as(e1.charCodeAt(0))) return !0;
            return !1;
        }
        const us = "deferred", cs = "loading", hs = "loaded";
        let ps = null, ds = "unavailable", fs = null;
        const ys = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (ds = "error"), ps && ps(t1);
        };
        function ms() {
            gs.fire(new Yt("pluginStateChange", {
                pluginStatus: ds,
                pluginURL: fs
            }));
        }
        const gs = new Qt, xs = function() {
            return ds;
        }, vs = function() {
            if (ds !== us || !fs) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            ds = cs, ms(), fs && pt({
                url: fs
            }, (t1)=>{
                t1 ? ys(t1) : (ds = hs, ms());
            });
        }, bs = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>ds === hs || null != bs.applyArabicShaping,
            isLoading: ()=>ds === cs,
            setState (t1) {
                ds = t1.pluginStatus, fs = t1.pluginURL;
            },
            isParsed: ()=>null != bs.applyArabicShaping && null != bs.processBidirectionalText && null != bs.processStyledBidirectionalText,
            getPluginURL: ()=>fs
        };
        class ws {
            constructor(t1, e1){
                this.zoom = t1, e1 ? (this.now = e1.now, this.fadeDuration = e1.fadeDuration, this.transition = e1.transition, this.pitch = e1.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
            }
            isSupportedScript(t1) {
                return function(t1, e1) {
                    for (const r of t1)if (!os(r.charCodeAt(0), e1)) return !1;
                    return !0;
                }(t1, bs.isLoaded());
            }
        }
        class _s {
            constructor(t1, e1){
                this.property = t1, this.value = e1, this.expression = function(t1, e1) {
                    if ($n(t1)) return new ti(t1, e1);
                    if (Jn(t1)) {
                        const r = Qn(t1, e1);
                        if ("error" === r.result) throw new Error(r.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return r.value;
                    }
                    {
                        let r = t1;
                        return "string" == typeof t1 && "color" === e1.type && (r = Ee.parse(t1)), {
                            kind: "constant",
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e1 ? t1.specification.default : e1, t1.specification);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e1, r) {
                return this.property.possiblyEvaluate(this, t1, e1, r);
            }
        }
        class As {
            constructor(t1){
                this.property = t1, this.value = new _s(t1, void 0);
            }
            transitioned(t1, e1) {
                return new ks(this.property, this.value, e1, C({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new ks(this.property, this.value, null, {}, 0);
            }
        }
        class Ss {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues);
            }
            getValue(t1) {
                return O(this._values[t1].value.value);
            }
            setValue(t1, e1) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new As(this._values[t1].property)), this._values[t1].value = new _s(this._values[t1].property, null === e1 ? void 0 : O(e1));
            }
            getTransition(t1) {
                return O(this._values[t1].transition);
            }
            setTransition(t1, e1) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new As(this._values[t1].property)), this._values[t1].transition = O(e1) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e1 of Object.keys(this._values)){
                    const r = this.getValue(e1);
                    void 0 !== r && (t1[e1] = r);
                    const n = this.getTransition(e1);
                    void 0 !== n && (t1[`${e1}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e1) {
                const r = new Is(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e1._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new Is(this._properties);
                for (const e1 of Object.keys(this._values))t1._values[e1] = this._values[e1].untransitioned();
                return t1;
            }
        }
        class ks {
            constructor(t1, e1, r, n, i){
                const s = n.delay || 0, a = n.duration || 0;
                i = i || 0, this.property = t1, this.value = e1, this.begin = i + s, this.end = this.begin + a, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e1, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e1, r), s = this.prior;
                if (s) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return s.possiblyEvaluate(t1, e1, r);
                    {
                        const a = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s.possiblyEvaluate(t1, e1, r), i, S(a));
                    }
                }
                return i;
            }
        }
        class Is {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e1, r) {
                const n = new zs(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e1, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class Ms {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues);
            }
            getValue(t1) {
                return O(this._values[t1].value);
            }
            setValue(t1, e1) {
                this._values[t1] = new _s(this._values[t1].property, null === e1 ? void 0 : O(e1));
            }
            serialize() {
                const t1 = {};
                for (const e1 of Object.keys(this._values)){
                    const r = this.getValue(e1);
                    void 0 !== r && (t1[e1] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e1, r) {
                const n = new zs(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e1, r);
                return n;
            }
        }
        class Ts {
            constructor(t1, e1, r){
                this.property = t1, this.value = e1, this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e1, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e1, r, n);
            }
        }
        class zs {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class Bs {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1) {
                return t1.expression.evaluate(e1);
            }
            interpolate(t1, e1, r) {
                const n = Cr[this.specification.type];
                return n ? n(t1, e1, r) : t1;
            }
        }
        class Es {
            constructor(t1, e1){
                this.specification = t1, this.overrides = e1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                return new Ts(this, "constant" === t1.expression.kind || "camera" === t1.expression.kind ? {
                    kind: "constant",
                    value: t1.expression.evaluate(e1, null, {}, r, n)
                } : t1.expression, e1);
            }
            interpolate(t1, e1, r) {
                if ("constant" !== t1.value.kind || "constant" !== e1.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e1.value.value) return new Ts(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = Cr[this.specification.type];
                return n ? new Ts(this, {
                    kind: "constant",
                    value: n(t1.value.value, e1.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e1, r, n, i, s) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e1, r, n, i, s);
            }
        }
        class Cs {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                return !!t1.expression.evaluate(e1, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class Ps {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                const e1 = new ws(0, {});
                for(const r in t1){
                    const n = t1[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new _s(n, void 0), s = this.defaultTransitionablePropertyValues[r] = new As(n);
                    this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e1);
                }
            }
        }
        function Ds(t1, e1) {
            return 256 * (t1 = M(Math.floor(t1), 0, 255)) + M(Math.floor(e1), 0, 255);
        }
        Ji(Es, "DataDrivenProperty"), Ji(Bs, "DataConstantProperty"), Ji(Cs, "ColorRampProperty");
        const Vs = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class Ls {
            constructor(t1, e1){
                this._structArray = t1, this._pos1 = e1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class Fs {
            constructor(){
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }
            static serialize(t1, e1) {
                return t1._trim(), e1 && (t1.isTransferred = !0, e1.push(t1.arrayBuffer)), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e1 = Object.create(this.prototype);
                return e1.arrayBuffer = t1.arrayBuffer, e1.length = t1.length, e1.capacity = t1.arrayBuffer.byteLength / e1.bytesPerElement, e1._refreshViews(), e1;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e1 = this.uint8;
                    this._refreshViews(), e1 && this.uint8.set(e1);
                }
            }
            _refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function Rs(t1, e1 = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = Vs[t1.type].BYTES_PER_ELEMENT, s = r = Us(r, Math.max(e1, i)), a = t1.components || 1;
                    return n = Math.max(n, i), r += i * a, {
                        name: t1.name,
                        type: t1.type,
                        components: a,
                        offset: s
                    };
                }),
                size: Us(r, Math.max(n, e1)),
                alignment: e1
            };
        }
        function Us(t1, e1) {
            return Math.ceil(t1 / e1) * e1;
        }
        class $s extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e1, this.int16[n + 1] = r, t1;
            }
        }
        $s.prototype.bytesPerElement = 4, Ji($s, "StructArrayLayout2i4");
        class js extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e1, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        js.prototype.bytesPerElement = 6, Ji(js, "StructArrayLayout3i6");
        class Os extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 4 * t1;
                return this.int16[s + 0] = e1, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t1;
            }
        }
        Os.prototype.bytesPerElement = 8, Ji(Os, "StructArrayLayout4i8");
        class qs extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e1, r, n, i, s, a);
            }
            emplace(t1, e1, r, n, i, s, a, o) {
                const l = 6 * t1, u = 12 * t1, c = 3 * t1;
                return this.int16[l + 0] = e1, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t1;
            }
        }
        qs.prototype.bytesPerElement = 12, Ji(qs, "StructArrayLayout2i4ub1f12");
        class Ns extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 4 * t1;
                return this.float32[s + 0] = e1, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t1;
            }
        }
        Ns.prototype.bytesPerElement = 16, Ji(Ns, "StructArrayLayout4f16");
        class Gs extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, s) {
                const a = 6 * t1, o = 3 * t1;
                return this.uint16[a + 0] = e1, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t1;
            }
        }
        Gs.prototype.bytesPerElement = 12, Ji(Gs, "StructArrayLayout4ui1f12");
        class Zs extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 4 * t1;
                return this.uint16[s + 0] = e1, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t1;
            }
        }
        Zs.prototype.bytesPerElement = 8, Ji(Zs, "StructArrayLayout4ui8");
        class Ks extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e1, r, n, i, s);
            }
            emplace(t1, e1, r, n, i, s, a) {
                const o = 6 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t1;
            }
        }
        Ks.prototype.bytesPerElement = 12, Ji(Ks, "StructArrayLayout6i12");
        class Xs extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e1, r, n, i, s, a, o, l, u, c, h);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
                const d = 12 * t1;
                return this.int16[d + 0] = e1, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.uint16[d + 4] = s, this.uint16[d + 5] = a, this.uint16[d + 6] = o, this.uint16[d + 7] = l, this.int16[d + 8] = u, this.int16[d + 9] = c, this.int16[d + 10] = h, this.int16[d + 11] = p, t1;
            }
        }
        Xs.prototype.bytesPerElement = 24, Ji(Xs, "StructArrayLayout4i4ui4i24");
        class Js extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e1, r, n, i, s);
            }
            emplace(t1, e1, r, n, i, s, a) {
                const o = 10 * t1, l = 5 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t1;
            }
        }
        Js.prototype.bytesPerElement = 20, Ji(Js, "StructArrayLayout3i3f20");
        class Hs extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.uint32[1 * t1 + 0] = e1, t1;
            }
        }
        Hs.prototype.bytesPerElement = 4, Ji(Hs, "StructArrayLayout1ul4");
        class Ys extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
                const d = this.length;
                return this.resize(d + 1), this.emplace(d, t1, e1, r, n, i, s, a, o, l, u, c, h, p);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d) {
                const f = 20 * t1, y = 10 * t1;
                return this.int16[f + 0] = e1, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.int16[f + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[f + 14] = c, this.uint32[y + 8] = h, this.uint16[f + 18] = p, this.uint16[f + 19] = d, t1;
            }
        }
        Ys.prototype.bytesPerElement = 40, Ji(Ys, "StructArrayLayout5i4f1i1ul2ui40");
        class Ws extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e1, r, n, i, s, a);
            }
            emplace(t1, e1, r, n, i, s, a, o) {
                const l = 8 * t1;
                return this.int16[l + 0] = e1, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t1;
            }
        }
        Ws.prototype.bytesPerElement = 16, Ji(Ws, "StructArrayLayout3i2i2i16");
        class Qs extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, s) {
                const a = 4 * t1, o = 8 * t1;
                return this.float32[a + 0] = e1, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t1;
            }
        }
        Qs.prototype.bytesPerElement = 16, Ji(Qs, "StructArrayLayout2f1f2i16");
        class ta extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 12 * t1, a = 3 * t1;
                return this.uint8[s + 0] = e1, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t1;
            }
        }
        ta.prototype.bytesPerElement = 12, Ji(ta, "StructArrayLayout2ub2f12");
        class ea extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e1, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        ea.prototype.bytesPerElement = 12, Ji(ea, "StructArrayLayout3f12");
        class ra extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e1, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        ra.prototype.bytesPerElement = 6, Ji(ra, "StructArrayLayout3ui6");
        class na extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b) {
                const w = this.length;
                return this.resize(w + 1), this.emplace(w, t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w) {
                const _ = 30 * t1, A = 15 * t1, S = 60 * t1;
                return this.int16[_ + 0] = e1, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = a, this.uint16[_ + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = d, this.float32[A + 10] = f, this.float32[A + 11] = y, this.uint8[S + 48] = m, this.uint8[S + 49] = g, this.uint8[S + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[S + 58] = w, t1;
            }
        }
        na.prototype.bytesPerElement = 60, Ji(na, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class ia extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z) {
                const B = this.length;
                return this.resize(B + 1), this.emplace(B, t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z, B) {
                const E = 38 * t1, C = 19 * t1;
                return this.int16[E + 0] = e1, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = d, this.uint16[E + 16] = f, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = w, this.uint16[E + 24] = _, this.uint16[E + 25] = A, this.uint16[E + 26] = S, this.uint16[E + 27] = k, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t1;
            }
        }
        ia.prototype.bytesPerElement = 76, Ji(ia, "StructArrayLayout3i2f6i15ui1ul3f76");
        class sa extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.float32[1 * t1 + 0] = e1, t1;
            }
        }
        sa.prototype.bytesPerElement = 4, Ji(sa, "StructArrayLayout1f4");
        class aa extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, s) {
                const a = 5 * t1;
                return this.float32[a + 0] = e1, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t1;
            }
        }
        aa.prototype.bytesPerElement = 20, Ji(aa, "StructArrayLayout5f20");
        class oa extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 6 * t1;
                return this.uint32[3 * t1 + 0] = e1, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t1;
            }
        }
        oa.prototype.bytesPerElement = 12, Ji(oa, "StructArrayLayout1ul3ui12");
        class la extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e1, this.uint16[n + 1] = r, t1;
            }
        }
        la.prototype.bytesPerElement = 4, Ji(la, "StructArrayLayout2ui4");
        class ua extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.uint16[1 * t1 + 0] = e1, t1;
            }
        }
        ua.prototype.bytesPerElement = 2, Ji(ua, "StructArrayLayout1ui2");
        class ca extends Fs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e1, this.float32[n + 1] = r, t1;
            }
        }
        ca.prototype.bytesPerElement = 8, Ji(ca, "StructArrayLayout2f8");
        class ha extends Ls {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        ha.prototype.size = 40;
        class pa extends Ys {
            get(t1) {
                return new ha(this, t1);
            }
        }
        Ji(pa, "CollisionBoxArray");
        class da extends Ls {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 49] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 50] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 13] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t1) {
                this._structArray.uint8[this._pos1 + 58] = t1;
            }
        }
        da.prototype.size = 60;
        class fa extends na {
            get(t1) {
                return new da(this, t1);
            }
        }
        Ji(fa, "PlacedSymbolArray");
        class ya extends Ls {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 15] = t1;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18];
            }
        }
        ya.prototype.size = 76;
        class ma extends ia {
            get(t1) {
                return new ya(this, t1);
            }
        }
        Ji(ma, "SymbolInstanceArray");
        class ga extends sa {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        Ji(ga, "GlyphOffsetArray");
        class xa extends $s {
            getx(t1) {
                return this.int16[2 * t1 + 0];
            }
            gety(t1) {
                return this.int16[2 * t1 + 1];
            }
        }
        Ji(xa, "SymbolLineVertexArray");
        class va extends Ls {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        va.prototype.size = 12;
        class ba extends oa {
            get(t1) {
                return new va(this, t1);
            }
        }
        Ji(ba, "FeatureIndexArray");
        class wa extends la {
            geta_centroid_pos0(t1) {
                return this.uint16[2 * t1 + 0];
            }
            geta_centroid_pos1(t1) {
                return this.uint16[2 * t1 + 1];
            }
        }
        Ji(wa, "FillExtrusionCentroidArray");
        const _a = Rs([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), Aa = Rs([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        var Sa = {
            exports: {}
        }, ka = {
            exports: {}
        };
        ka.exports = function(t1, e1) {
            var r, n, i, s, a, o, l, u;
            for(n = t1.length - (r = 3 & t1.length), i = e1, a = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);
            switch(l = 0, r){
                case 3:
                    l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                case 2:
                    l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                case 1:
                    i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
            }
            return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
        };
        var Ia = ka.exports, Ma = {
            exports: {}
        };
        Ma.exports = function(t1, e1) {
            for(var r, n = t1.length, i = e1 ^ n, s = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(s) | (255 & t1.charCodeAt(++s)) << 8 | (255 & t1.charCodeAt(++s)) << 16 | (255 & t1.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;
            switch(n){
                case 3:
                    i ^= (255 & t1.charCodeAt(s + 2)) << 16;
                case 2:
                    i ^= (255 & t1.charCodeAt(s + 1)) << 8;
                case 1:
                    i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
            }
            return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
        };
        var Ta = Ia, za = Ma.exports;
        Sa.exports = Ta, Sa.exports.murmur3 = Ta, Sa.exports.murmur2 = za;
        var Ba = p(Sa.exports);
        class Ea {
            constructor(){
                this.ids = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e1, r, n) {
                this.ids.push(Ca(t1)), this.positions.push(e1, r, n);
            }
            getPositions(t1) {
                const e1 = Ca(t1);
                let r = 0, n = this.ids.length - 1;
                for(; r < n;){
                    const t1 = r + n >> 1;
                    this.ids[t1] >= e1 ? n = t1 : r = t1 + 1;
                }
                const i = [];
                for(; this.ids[r] === e1;)i.push({
                    index: this.positions[3 * r],
                    start: this.positions[3 * r + 1],
                    end: this.positions[3 * r + 2]
                }), r++;
                return i;
            }
            static serialize(t1, e1) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return Pa(r, n, 0, r.length - 1), e1 && e1.push(r.buffer, n.buffer), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e1 = new Ea;
                return e1.ids = t1.ids, e1.positions = t1.positions, e1.indexed = !0, e1;
            }
        }
        function Ca(t1) {
            const e1 = +t1;
            return !isNaN(e1) && Number.MIN_SAFE_INTEGER <= e1 && e1 <= Number.MAX_SAFE_INTEGER ? e1 : Ba(String(t1));
        }
        function Pa(t1, e1, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let s = r - 1, a = n + 1;
                for(;;){
                    do s++;
                    while (t1[s] < i);
                    do a--;
                    while (t1[a] > i);
                    if (s >= a) break;
                    Da(t1, s, a), Da(e1, 3 * s, 3 * a), Da(e1, 3 * s + 1, 3 * a + 1), Da(e1, 3 * s + 2, 3 * a + 2);
                }
                a - r < n - a ? (Pa(t1, e1, r, a), r = a + 1) : (Pa(t1, e1, a + 1, n), n = a);
            }
        }
        function Da(t1, e1, r) {
            const n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        Ji(Ea, "FeaturePositionMap");
        class Va {
            constructor(t1){
                this.gl = t1.gl, this.initialized = !1;
            }
            fetchUniformLocation(t1, e1) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t1, e1), this.initialized = !0), !!this.location;
            }
        }
        class La extends Va {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class Fa extends Va {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class Ra extends Va {
            constructor(t1){
                super(t1), this.current = Ee.transparent;
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const Ua = new Float32Array(16), $a = new Float32Array(9), ja = new Float32Array(4);
        function Oa(t1) {
            return [
                Ds(255 * t1.r, 255 * t1.g),
                Ds(255 * t1.b, 255 * t1.a)
            ];
        }
        class qa {
            constructor(t1, e1, r){
                this.value = t1, this.uniformNames = e1.map((t1)=>`u_${t1}`), this.type = r;
            }
            setUniform(t1, e1, r, n, i) {
                e1.set(t1, i, n.constantOr(this.value));
            }
            getBinding(t1, e1) {
                return "color" === this.type ? new Ra(t1) : new La(t1);
            }
        }
        class Na {
            constructor(t1, e1){
                this.uniformNames = e1.map((t1)=>`u_${t1}`), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t1) {
                this.pixelRatio = t1.pixelRatio || 1, this.pattern = t1.tl.concat(t1.br);
            }
            setUniform(t1, e1, r, n, i) {
                const s = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;
                s && e1.set(t1, i, s);
            }
            getBinding(t1, e1) {
                return "u_pattern" === e1 || "u_dash" === e1 ? new Fa(t1) : new La(t1);
            }
        }
        class Ga {
            constructor(t1, e1, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e1.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e1, r, n, i, s) {
                const a = this.paintVertexArray.length, o = this.expression.evaluate(new ws(0), e1, {}, i, n, s);
                this.paintVertexArray.resize(t1), this._setPaintValue(a, t1, o);
            }
            updatePaintArray(t1, e1, r, n, i) {
                const s = this.expression.evaluate({
                    zoom: 0
                }, r, n, void 0, i);
                this._setPaintValue(t1, e1, s);
            }
            _setPaintValue(t1, e1, r) {
                if ("color" === this.type) {
                    const n = Oa(r);
                    for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, n[0], n[1]);
                } else {
                    for(let n = t1; n < e1; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Za {
            constructor(t1, e1, r, n, i, s){
                this.expression = t1, this.uniformNames = e1.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e1.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new s;
            }
            populatePaintArray(t1, e1, r, n, i, s) {
                const a = this.expression.evaluate(new ws(this.zoom), e1, {}, i, n, s), o = this.expression.evaluate(new ws(this.zoom + 1), e1, {}, i, n, s), l = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(l, t1, a, o);
            }
            updatePaintArray(t1, e1, r, n, i) {
                const s = this.expression.evaluate({
                    zoom: this.zoom
                }, r, n, void 0, i), a = this.expression.evaluate({
                    zoom: this.zoom + 1
                }, r, n, void 0, i);
                this._setPaintValue(t1, e1, s, a);
            }
            _setPaintValue(t1, e1, r, n) {
                if ("color" === this.type) {
                    const i = Oa(r), s = Oa(n);
                    for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);
                } else {
                    for(let i = t1; i < e1; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e1, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, a = M(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
                e1.set(t1, i, a);
            }
            getBinding(t1, e1) {
                return new La(t1);
            }
        }
        class Ka {
            constructor(t1, e1, r, n, i){
                this.expression = t1, this.layerId = i, this.paintVertexAttributes = ("array" === r ? Aa : _a).members;
                for(let t1 = 0; t1 < e1.length; ++t1);
                this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e1, r) {
                const n = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValues(n, t1, e1.patterns && e1.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e1, r, n, i, s) {
                this._setPaintValues(t1, e1, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t1, e1, r, n) {
                if (!n || !r) return;
                const i = n[r];
                if (!i) return;
                const { tl: s, br: a, pixelRatio: o } = i;
                for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Xa {
            constructor(t1, e1, r = ()=>!0){
                this.binders = {}, this._buffers = [];
                const n = [];
                for(const i in t1.paint._values){
                    if (!r(i)) continue;
                    const s = t1.paint.get(i);
                    if (!(s instanceof Ts && Ln(s.property.specification))) continue;
                    const a = Ya(i, t1.type), o = s.value, l = s.property.specification.type, u = !!s.property.useIntegerZoom, c = "line-dasharray" === i || i.endsWith("pattern"), h = "line-dasharray" === i && "constant" !== t1.layout.get("line-cap").value.kind;
                    if ("constant" !== o.kind || h) {
                        if ("source" === o.kind || h || c) {
                            const e1 = to(i, l, "source");
                            this.binders[i] = c ? new Ka(o, a, l, e1, t1.id) : new Ga(o, a, l, e1), n.push(`/a_${i}`);
                        } else {
                            const t1 = to(i, l, "composite");
                            this.binders[i] = new Za(o, a, l, u, e1, t1), n.push(`/z_${i}`);
                        }
                    } else this.binders[i] = c ? new Na(o.value, a) : new qa(o.value, a, l), n.push(`/u_${i}`);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e1 = this.binders[t1];
                return e1 instanceof Ga || e1 instanceof Za ? e1.maxValue : 0;
            }
            populatePaintArrays(t1, e1, r, n, i, s) {
                for(const a in this.binders){
                    const o = this.binders[a];
                    (o instanceof Ga || o instanceof Za || o instanceof Ka) && o.populatePaintArray(t1, e1, r, n, i, s);
                }
            }
            setConstantPatternPositions(t1) {
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    r instanceof Na && r.setConstantPatternPositions(t1);
                }
            }
            updatePaintArrays(t1, e1, r, n, i, s) {
                let a = !1;
                for(const o in t1){
                    const l = e1.getPositions(o);
                    for (const e1 of l){
                        const l = r.feature(e1.index);
                        for(const r in this.binders){
                            const u = this.binders[r];
                            if ((u instanceof Ga || u instanceof Za || u instanceof Ka) && !0 === u.expression.isStateDependent) {
                                const c = n.paint.get(r);
                                u.expression = c.value, u.updatePaintArray(e1.start, e1.end, l, t1[o], i, s), a = !0;
                            }
                        }
                    }
                }
                return a;
            }
            defines() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    (r instanceof qa || r instanceof Na) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getBinderAttributes() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (r instanceof Ga || r instanceof Za || r instanceof Ka) for(let e1 = 0; e1 < r.paintVertexAttributes.length; e1++)t1.push(r.paintVertexAttributes[e1].name);
                }
                return t1;
            }
            getBinderUniforms() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (r instanceof qa || r instanceof Na || r instanceof Za) for (const e1 of r.uniformNames)t1.push(e1);
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1) {
                const e1 = [];
                for(const r in this.binders){
                    const n = this.binders[r];
                    if (n instanceof qa || n instanceof Na || n instanceof Za) for (const i of n.uniformNames)e1.push({
                        name: i,
                        property: r,
                        binding: n.getBinding(t1, i)
                    });
                }
                return e1;
            }
            setUniforms(t1, e1, r, n, i) {
                for (const { name: e1, property: s, binding: a } of r)this.binders[s].setUniform(t1, a, i, n.get(s), e1);
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t1 in this.binders){
                    const e1 = this.binders[t1];
                    (e1 instanceof Ga || e1 instanceof Za || e1 instanceof Ka) && e1.paintVertexBuffer && this._buffers.push(e1.paintVertexBuffer);
                }
            }
            upload(t1) {
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    (r instanceof Ga || r instanceof Za || r instanceof Ka) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e1 = this.binders[t1];
                    (e1 instanceof Ga || e1 instanceof Za || e1 instanceof Ka) && e1.destroy();
                }
            }
        }
        class Ja {
            constructor(t1, e1, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new Xa(n, e1, r);
                this.needsUpload = !1, this._featureMap = new Ea, this._bufferOffset = 0;
            }
            populatePaintArrays(t1, e1, r, n, i, s, a) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e1, n, i, s, a);
                void 0 !== e1.id && this._featureMap.add(e1.id, r, this._bufferOffset, t1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e1, r, n, i) {
                for (const s of r)this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t1, this._featureMap, e1, s, n, i) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e1 in this.programConfigurations)this.programConfigurations[e1].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        const Ha = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "line-dasharray": [
                "dash"
            ]
        };
        function Ya(t1, e1) {
            return Ha[t1] || [
                t1.replace(`${e1}-`, "").replace(/-/g, "_")
            ];
        }
        const Wa = {
            "line-pattern": {
                source: Gs,
                composite: Gs
            },
            "fill-pattern": {
                source: Gs,
                composite: Gs
            },
            "fill-extrusion-pattern": {
                source: Gs,
                composite: Gs
            },
            "line-dasharray": {
                source: Zs,
                composite: Zs
            }
        }, Qa = {
            color: {
                source: ca,
                composite: Ns
            },
            number: {
                source: sa,
                composite: ca
            }
        };
        function to(t1, e1, r) {
            const n = Wa[t1];
            return n && n[r] || Qa[e1][r];
        }
        Ji(qa, "ConstantBinder"), Ji(Na, "PatternConstantBinder"), Ji(Ga, "SourceExpressionBinder"), Ji(Ka, "PatternCompositeBinder"), Ji(Za, "CompositeExpressionBinder"), Ji(Xa, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), Ji(Ja, "ProgramConfigurationSet");
        const eo = "-transition";
        class ro extends Qt {
            constructor(t1, e1){
                if (super(), this.id = t1.id, this.type = t1.type, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, "custom" !== t1.type && (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, "background" !== t1.type && "sky" !== t1.type && (this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter), e1.layout && (this._unevaluatedLayout = new Ms(e1.layout)), e1.paint)) {
                    this._transitionablePaint = new Ss(e1.paint);
                    for(const e1 in t1.paint)this.setPaintProperty(e1, t1.paint[e1], {
                        validate: !1
                    });
                    for(const e1 in t1.layout)this.setLayoutProperty(e1, t1.layout[e1], {
                        validate: !1
                    });
                    this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new zs(e1.paint);
                }
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e1, r = {}) {
                null != e1 && this._validate(ji, `layers.${this.id}.layout.${t1}`, t1, e1, r) || ("visibility" !== t1 ? this._unevaluatedLayout.setValue(t1, e1) : this.visibility = e1);
            }
            getPaintProperty(t1) {
                return U(t1, eo) ? this._transitionablePaint.getTransition(t1.slice(0, -11)) : this._transitionablePaint.getValue(t1);
            }
            setPaintProperty(t1, e1, r = {}) {
                if (null != e1 && this._validate($i, `layers.${this.id}.paint.${t1}`, t1, e1, r)) return !1;
                if (U(t1, eo)) return this._transitionablePaint.setTransition(t1.slice(0, -11), e1 || void 0), !1;
                {
                    const r = this._transitionablePaint._values[t1], n = r.value.isDataDriven(), i = r.value;
                    this._transitionablePaint.setValue(t1, e1), this._handleSpecialPaintPropertyUpdate(t1);
                    const s = this._transitionablePaint._values[t1].value, a = s.isDataDriven(), o = U(t1, "pattern") || "line-dasharray" === t1;
                    return a || n || o || this._handleOverridablePaintPropertyUpdate(t1, i, s);
                }
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            getProgramIds() {
                return null;
            }
            getProgramConfiguration(t1) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t1, e1, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e1) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e1)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e1);
            }
            serialize() {
                const t1 = {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return this.visibility && (t1.layout = t1.layout || {}, t1.layout.visibility = this.visibility), j(t1, (t1, e1)=>!(void 0 === t1 || "layout" === e1 && !Object.keys(t1).length || "paint" === e1 && !Object.keys(t1).length));
            }
            _validate(t1, e1, r, n, i = {}) {
                return (!i || !1 !== i.validate) && qi(this, t1.call(Ui, {
                    key: e1,
                    layerType: this.type,
                    objectKey: r,
                    value: n,
                    styleSpec: te,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    }
                }));
            }
            is3D() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            resize() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e1 = this.paint.get(t1);
                    if (e1 instanceof Ts && Ln(e1.property.specification) && ("source" === e1.value.kind || "composite" === e1.value.kind) && e1.value.isStateDependent) return !0;
                }
                return !1;
            }
            compileFilter() {
                this._filterCompiled || (this._featureFilter = hi(this.filter), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
        }
        const no = Rs([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), io = Rs([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class so {
            constructor(t1 = []){
                this.segments = t1;
            }
            prepareSegment(t1, e1, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > so.MAX_VERTEX_ARRAY_LENGTH && N(`Max vertices per segment is ${so.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > so.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e1.length,
                    primitiveOffset: r.length,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e1 in t1.vaos)t1.vaos[e1].destroy();
            }
            static simpleSegment(t1, e1, r, n) {
                return new so([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e1,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        so.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ji(so, "SegmentVector");
        var ao = 8192;
        class oo {
            constructor(t1, e1){
                t1 && (e1 ? this.setSouthWest(t1).setNorthEast(e1) : 4 === t1.length ? this.setSouthWest([
                    t1[0],
                    t1[1]
                ]).setNorthEast([
                    t1[2],
                    t1[3]
                ]) : this.setSouthWest(t1[0]).setNorthEast(t1[1]));
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof Ol ? new Ol(t1.lng, t1.lat) : Ol.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof Ol ? new Ol(t1.lng, t1.lat) : Ol.convert(t1), this;
            }
            extend(t1) {
                const e1 = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof Ol) n = t1, i = t1;
                else {
                    if (!(t1 instanceof oo)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(oo.convert(t1)) : this.extend(Ol.convert(t1)) : "object" == typeof t1 && null !== t1 && t1.hasOwnProperty("lat") && (t1.hasOwnProperty("lon") || t1.hasOwnProperty("lng")) ? this.extend(Ol.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e1 || r ? (e1.lng = Math.min(n.lng, e1.lng), e1.lat = Math.min(n.lat, e1.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ol(n.lng, n.lat), this._ne = new Ol(i.lng, i.lat)), this;
            }
            getCenter() {
                return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new Ol(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new Ol(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e1, lat: r } = Ol.convert(t1);
                let n = this._sw.lng <= e1 && e1 <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e1 && e1 >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                return !t1 || t1 instanceof oo ? t1 : new oo(t1);
            }
        }
        var lo = 1e-6, uo = "undefined" != typeof Float32Array ? Float32Array : Array;
        function co() {
            var t1 = new uo(9);
            return uo != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
        }
        function ho(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = r[0], d = r[1], f = r[2], y = r[3], m = r[4], g = r[5], x = r[6], v = r[7], b = r[8];
            return t1[0] = p * n + d * a + f * u, t1[1] = p * i + d * o + f * c, t1[2] = p * s + d * l + f * h, t1[3] = y * n + m * a + g * u, t1[4] = y * i + m * o + g * c, t1[5] = y * s + m * l + g * h, t1[6] = x * n + v * a + b * u, t1[7] = x * i + v * o + b * c, t1[8] = x * s + v * l + b * h, t1;
        }
        function po(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function fo(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = e1[4], o = e1[5], l = e1[6], u = e1[7], c = e1[8], h = e1[9], p = e1[10], d = e1[11], f = e1[12], y = e1[13], m = e1[14], g = e1[15], x = r * o - n * a, v = r * l - i * a, b = r * u - s * a, w = n * l - i * o, _ = n * u - s * o, A = i * u - s * l, S = c * y - h * f, k = c * m - p * f, I = c * g - d * f, M = h * m - p * y, T = h * g - d * y, z = p * g - d * m, B = x * z - v * T + b * M + w * I - _ * k + A * S;
            return B ? (t1[0] = (o * z - l * T + u * M) * (B = 1 / B), t1[1] = (i * T - n * z - s * M) * B, t1[2] = (y * A - m * _ + g * w) * B, t1[3] = (p * _ - h * A - d * w) * B, t1[4] = (l * I - a * z - u * k) * B, t1[5] = (r * z - i * I + s * k) * B, t1[6] = (m * b - f * A - g * v) * B, t1[7] = (c * A - p * b + d * v) * B, t1[8] = (a * T - o * I + u * S) * B, t1[9] = (n * I - r * T - s * S) * B, t1[10] = (f * _ - y * b + g * x) * B, t1[11] = (h * b - c * _ - d * x) * B, t1[12] = (o * k - a * M - l * S) * B, t1[13] = (r * M - n * k + i * S) * B, t1[14] = (y * v - f * w - m * x) * B, t1[15] = (c * w - h * v + p * x) * B, t1) : null;
        }
        function yo(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = e1[9], d = e1[10], f = e1[11], y = e1[12], m = e1[13], g = e1[14], x = e1[15], v = r[0], b = r[1], w = r[2], _ = r[3];
            return t1[0] = v * n + b * o + w * h + _ * y, t1[1] = v * i + b * l + w * p + _ * m, t1[2] = v * s + b * u + w * d + _ * g, t1[3] = v * a + b * c + w * f + _ * x, t1[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t1[5] = v * i + b * l + w * p + _ * m, t1[6] = v * s + b * u + w * d + _ * g, t1[7] = v * a + b * c + w * f + _ * x, t1[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t1[9] = v * i + b * l + w * p + _ * m, t1[10] = v * s + b * u + w * d + _ * g, t1[11] = v * a + b * c + w * f + _ * x, t1[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t1[13] = v * i + b * l + w * p + _ * m, t1[14] = v * s + b * u + w * d + _ * g, t1[15] = v * a + b * c + w * f + _ * x, t1;
        }
        function mo(t1, e1, r) {
            var n, i, s, a, o, l, u, c, h, p, d, f, y = r[0], m = r[1], g = r[2];
            return e1 === t1 ? (t1[12] = e1[0] * y + e1[4] * m + e1[8] * g + e1[12], t1[13] = e1[1] * y + e1[5] * m + e1[9] * g + e1[13], t1[14] = e1[2] * y + e1[6] * m + e1[10] * g + e1[14], t1[15] = e1[3] * y + e1[7] * m + e1[11] * g + e1[15]) : (i = e1[1], s = e1[2], a = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = e1[9], d = e1[10], f = e1[11], t1[0] = n = e1[0], t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = o, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = d, t1[11] = f, t1[12] = n * y + o * m + h * g + e1[12], t1[13] = i * y + l * m + p * g + e1[13], t1[14] = s * y + u * m + d * g + e1[14], t1[15] = a * y + c * m + f * g + e1[15]), t1;
        }
        function go(t1, e1, r) {
            var n = r[0], i = r[1], s = r[2];
            return t1[0] = e1[0] * n, t1[1] = e1[1] * n, t1[2] = e1[2] * n, t1[3] = e1[3] * n, t1[4] = e1[4] * i, t1[5] = e1[5] * i, t1[6] = e1[6] * i, t1[7] = e1[7] * i, t1[8] = e1[8] * s, t1[9] = e1[9] * s, t1[10] = e1[10] * s, t1[11] = e1[11] * s, t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15], t1;
        }
        function xo(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e1[4], a = e1[5], o = e1[6], l = e1[7], u = e1[8], c = e1[9], h = e1[10], p = e1[11];
            return e1 !== t1 && (t1[0] = e1[0], t1[1] = e1[1], t1[2] = e1[2], t1[3] = e1[3], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[4] = s * i + u * n, t1[5] = a * i + c * n, t1[6] = o * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - s * n, t1[9] = c * i - a * n, t1[10] = h * i - o * n, t1[11] = p * i - l * n, t1;
        }
        function vo(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e1[0], a = e1[1], o = e1[2], l = e1[3], u = e1[8], c = e1[9], h = e1[10], p = e1[11];
            return e1 !== t1 && (t1[4] = e1[4], t1[5] = e1[5], t1[6] = e1[6], t1[7] = e1[7], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[0] = s * i - u * n, t1[1] = a * i - c * n, t1[2] = o * i - h * n, t1[3] = l * i - p * n, t1[8] = s * n + u * i, t1[9] = a * n + c * i, t1[10] = o * n + h * i, t1[11] = l * n + p * i, t1;
        }
        function bo(t1, e1) {
            return t1[0] = e1[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e1[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e1[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function wo(t1, e1, r) {
            var n, i, s, a = r[0], o = r[1], l = r[2], u = Math.hypot(a, o, l);
            return u < lo ? null : (a *= u = 1 / u, o *= u, l *= u, n = Math.sin(e1), i = Math.cos(e1), t1[0] = a * a * (s = 1 - i) + i, t1[1] = o * a * s + l * n, t1[2] = l * a * s - o * n, t1[3] = 0, t1[4] = a * o * s - l * n, t1[5] = o * o * s + i, t1[6] = l * o * s + a * n, t1[7] = 0, t1[8] = a * l * s + o * n, t1[9] = o * l * s - a * n, t1[10] = l * l * s + i, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1);
        }
        Math.hypot || (Math.hypot = function() {
            for(var t1 = 0, e1 = arguments.length; e1--;)t1 += arguments[e1] * arguments[e1];
            return Math.sqrt(t1);
        });
        var _o = yo;
        function Ao() {
            var t1 = new uo(3);
            return uo != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
        }
        function So(t1) {
            var e1 = new uo(3);
            return e1[0] = t1[0], e1[1] = t1[1], e1[2] = t1[2], e1;
        }
        function ko(t1) {
            return Math.hypot(t1[0], t1[1], t1[2]);
        }
        function Io(t1, e1, r) {
            var n = new uo(3);
            return n[0] = t1, n[1] = e1, n[2] = r, n;
        }
        function Mo(t1, e1, r) {
            return t1[0] = e1[0] + r[0], t1[1] = e1[1] + r[1], t1[2] = e1[2] + r[2], t1;
        }
        function To(t1, e1, r) {
            return t1[0] = e1[0] - r[0], t1[1] = e1[1] - r[1], t1[2] = e1[2] - r[2], t1;
        }
        function zo(t1, e1, r) {
            return t1[0] = e1[0] * r[0], t1[1] = e1[1] * r[1], t1[2] = e1[2] * r[2], t1;
        }
        function Bo(t1, e1, r) {
            return t1[0] = Math.min(e1[0], r[0]), t1[1] = Math.min(e1[1], r[1]), t1[2] = Math.min(e1[2], r[2]), t1;
        }
        function Eo(t1, e1, r) {
            return t1[0] = Math.max(e1[0], r[0]), t1[1] = Math.max(e1[1], r[1]), t1[2] = Math.max(e1[2], r[2]), t1;
        }
        function Co(t1, e1, r) {
            return t1[0] = e1[0] * r, t1[1] = e1[1] * r, t1[2] = e1[2] * r, t1;
        }
        function Po(t1, e1, r, n) {
            return t1[0] = e1[0] + r[0] * n, t1[1] = e1[1] + r[1] * n, t1[2] = e1[2] + r[2] * n, t1;
        }
        function Do(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = r * r + n * n + i * i;
            return s > 0 && (s = 1 / Math.sqrt(s)), t1[0] = e1[0] * s, t1[1] = e1[1] * s, t1[2] = e1[2] * s, t1;
        }
        function Vo(t1, e1) {
            return t1[0] * e1[0] + t1[1] * e1[1] + t1[2] * e1[2];
        }
        function Lo(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = r[0], o = r[1], l = r[2];
            return t1[0] = i * l - s * o, t1[1] = s * a - n * l, t1[2] = n * o - i * a, t1;
        }
        function Fo(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = r[3] * n + r[7] * i + r[11] * s + r[15];
            return t1[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t1[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t1[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t1;
        }
        function Ro(t1, e1, r) {
            var n = r[0], i = r[1], s = r[2], a = e1[0], o = e1[1], l = e1[2], u = i * l - s * o, c = s * a - n * l, h = n * o - i * a, p = i * h - s * c, d = s * u - n * h, f = n * c - i * u, y = 2 * r[3];
            return c *= y, h *= y, d *= 2, f *= 2, t1[0] = a + (u *= y) + (p *= 2), t1[1] = o + c + d, t1[2] = l + h + f, t1;
        }
        var Uo, $o = To, jo = zo, Oo = ko;
        function qo(t1, e1, r) {
            return t1[0] = e1[0] * r, t1[1] = e1[1] * r, t1[2] = e1[2] * r, t1[3] = e1[3] * r, t1;
        }
        function No(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = r * r + n * n + i * i + s * s;
            return a > 0 && (a = 1 / Math.sqrt(a)), t1[0] = r * a, t1[1] = n * a, t1[2] = i * a, t1[3] = s * a, t1;
        }
        function Go(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3];
            return t1[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t1[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t1[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t1[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t1;
        }
        function Zo() {
            var t1 = new uo(4);
            return uo != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
        }
        function Ko(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
        }
        function Xo(t1, e1, r) {
            r *= .5;
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + a * o, t1[1] = i * l + s * o, t1[2] = s * l - i * o, t1[3] = a * l - n * o, t1;
        }
        function Jo(t1, e1, r) {
            r *= .5;
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l - s * o, t1[1] = i * l + a * o, t1[2] = s * l + n * o, t1[3] = a * l - i * o, t1;
        }
        Ao(), Uo = new uo(4), uo != Float32Array && (Uo[0] = 0, Uo[1] = 0, Uo[2] = 0, Uo[3] = 0);
        var Ho = No;
        Ao(), Io(1, 0, 0), Io(0, 1, 0), Zo(), Zo(), co();
        const Yo = Rs([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: Wo } = Yo, Qo = Rs([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var tl = Rs([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        class el {
            constructor(t1, e1){
                this.pos = t1, this.dir = e1;
            }
            intersectsPlane(t1, e1, r) {
                const n = Vo(e1, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e1[0] + (t1[1] - this.pos[1]) * e1[1] + (t1[2] - this.pos[2]) * e1[2]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
            }
            closestPointOnSphere(t1, e1, r) {
                if (function(t1, e1) {
                    var r = t1[0], n = t1[1], i = t1[2], s = e1[0], a = e1[1], o = e1[2];
                    return Math.abs(r - s) <= lo * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= lo * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= lo * Math.max(1, Math.abs(i), Math.abs(o));
                }(this.pos, t1) || 0 === e1) return r[0] = r[1] = r[2] = 0, !1;
                const [n, i, s] = this.dir, a = this.pos[0] - t1[0], o = this.pos[1] - t1[1], l = this.pos[2] - t1[2], u = n * n + i * i + s * s, c = 2 * (a * n + o * i + l * s), h = c * c - 4 * u * (a * a + o * o + l * l - e1 * e1);
                if (h < 0) {
                    const t1 = Math.max(-c / 2, 0), u = a + n * t1, h = o + i * t1, p = l + s * t1, d = Math.hypot(u, h, p);
                    return r[0] = u * e1 / d, r[1] = h * e1 / d, r[2] = p * e1 / d, !1;
                }
                {
                    const t1 = (-c - Math.sqrt(h)) / (2 * u);
                    if (t1 < 0) {
                        const t1 = Math.hypot(a, o, l);
                        return r[0] = a * e1 / t1, r[1] = o * e1 / t1, r[2] = l * e1 / t1, !1;
                    }
                    return r[0] = a + n * t1, r[1] = o + i * t1, r[2] = l + s * t1, !0;
                }
            }
        }
        class rl {
            constructor(t1, e1, r, n, i){
                this.TL = t1, this.TR = e1, this.BR = r, this.BL = n, this.horizon = i;
            }
            static fromInvProjectionMatrix(t1, e1, r) {
                const n = [
                    -1,
                    1,
                    1
                ], i = [
                    1,
                    1,
                    1
                ], s = [
                    1,
                    -1,
                    1
                ], a = [
                    -1,
                    -1,
                    1
                ], o = Fo(n, n, t1), l = Fo(i, i, t1), u = Fo(s, s, t1), c = Fo(a, a, t1);
                return new rl(o, l, u, c, e1 / r);
            }
        }
        class nl {
            constructor(t1, e1){
                this.points = t1, this.planes = e1;
            }
            static fromInvProjectionMatrix(t1, e1, r, n) {
                const i = Math.pow(2, r), s = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((r)=>{
                    const s = Go([], r, t1), a = 1 / s[3] / e1 * i;
                    return function(t1, e1, r) {
                        return t1[0] = e1[0] * r[0], t1[1] = e1[1] * r[1], t1[2] = e1[2] * r[2], t1[3] = e1[3] * r[3], t1;
                    }(s, s, [
                        a,
                        a,
                        n ? 1 / s[3] : a,
                        a
                    ]);
                }), a = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((t1)=>{
                    const e1 = Do([], Lo([], $o([], s[t1[0]], s[t1[1]]), $o([], s[t1[2]], s[t1[1]]))), r = -Vo(e1, s[t1[1]]);
                    return e1.concat(r);
                });
                return new nl(s, a);
            }
        }
        class il {
            static fromPoints(t1) {
                const e1 = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], r = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const n of t1)Bo(e1, e1, n), Eo(r, r, n);
                return new il(e1, r);
            }
            static applyTransform(t1, e1) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)Fo(r[t1], r[t1], e1);
                return il.fromPoints(r);
            }
            constructor(t1, e1){
                this.min = t1, this.max = e1, this.center = Co([], Mo([], this.min, this.max), .5);
            }
            quadrant(t1) {
                const e1 = [
                    t1 % 2 == 0,
                    t1 < 2
                ], r = So(this.min), n = So(this.max);
                for(let t1 = 0; t1 < e1.length; t1++)r[t1] = e1[t1] ? this.min[t1] : this.center[t1], n[t1] = e1[t1] ? this.center[t1] : this.max[t1];
                return n[2] = this.max[2], new il(r, n);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            distanceZ(t1) {
                return Math.max(Math.min(this.max[2], t1[2]), this.min[2]) - t1[2];
            }
            getCorners() {
                const t1 = this.min, e1 = this.max;
                return [
                    [
                        t1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e1[0],
                        e1[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        e1[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        t1[1],
                        e1[2]
                    ],
                    [
                        e1[0],
                        t1[1],
                        e1[2]
                    ],
                    [
                        e1[0],
                        e1[1],
                        e1[2]
                    ],
                    [
                        t1[0],
                        e1[1],
                        e1[2]
                    ]
                ];
            }
            intersects(t1) {
                const e1 = this.getCorners();
                let r = !0;
                for(let n = 0; n < t1.planes.length; n++){
                    const i = t1.planes[n];
                    let s = 0;
                    for(let t1 = 0; t1 < e1.length; t1++)s += Vo(i, e1[t1]) + i[3] >= 0;
                    if (0 === s) return 0;
                    s !== e1.length && (r = !1);
                }
                if (r) return 2;
                for(let e1 = 0; e1 < 3; e1++){
                    let r = Number.MAX_VALUE, n = -Number.MAX_VALUE;
                    for(let i = 0; i < t1.points.length; i++){
                        const s = t1.points[i][e1] - this.min[e1];
                        r = Math.min(r, s), n = Math.max(n, s);
                    }
                    if (n < 0 || r > this.max[e1] - this.min[e1]) return 0;
                }
                return 1;
            }
        }
        const sl = 5, al = 6, ol = ao / Math.PI / 2, ll = 16383, ul = 64, cl = [
            ul,
            32,
            16
        ], hl = -ol, pl = ol, dl = [
            new il([
                hl,
                hl,
                hl
            ], [
                pl,
                pl,
                pl
            ]),
            new il([
                hl,
                hl,
                hl
            ], [
                0,
                0,
                pl
            ]),
            new il([
                0,
                hl,
                hl
            ], [
                pl,
                0,
                pl
            ]),
            new il([
                hl,
                0,
                hl
            ], [
                0,
                pl,
                pl
            ]),
            new il([
                0,
                0,
                hl
            ], [
                pl,
                pl,
                pl
            ])
        ];
        function fl(t1) {
            return t1 * ol / Ul;
        }
        function yl(t1, e1, r, n = !0) {
            const i = Co([], t1._camera.position, t1.worldSize), s = [
                e1,
                r,
                1,
                1
            ];
            Go(s, s, t1.pixelMatrixInverse), qo(s, s, 1 / s[3]);
            const a = Do([], $o([], s, i)), o = t1.globeMatrix, l = [
                o[12],
                o[13],
                o[14]
            ], u = $o([], l, i), c = ko(u), h = Do([], u), p = t1.worldSize / (2 * Math.PI), d = Vo(h, a), f = Math.asin(p / c);
            if (f < Math.acos(d)) {
                if (!n) return null;
                const t1 = [], e1 = [];
                Co(t1, a, c / d), Do(e1, $o(e1, t1, u)), Do(a, Mo(a, u, Co(a, e1, Math.tan(f) * c)));
            }
            const y = [];
            new el(i, a).closestPointOnSphere(l, p, y);
            const m = Do([], W(o, 0)), g = Do([], W(o, 1)), x = Do([], W(o, 2)), v = Vo(m, y), b = Vo(g, y), w = Vo(x, y), A = _(Math.asin(-b / p));
            let S = _(Math.atan2(v, w));
            S = t1.center.lng + function(t1, e1) {
                const r = (e1 - t1 + 180) % 360 - 180;
                return r < -180 ? r + 360 : r;
            }(t1.center.lng, S);
            const k = Nl(S), I = M(Gl(A), 0, 1);
            return new Wl(k, I);
        }
        class ml {
            constructor(t1, e1, r){
                this.a = $o([], t1, r), this.b = $o([], e1, r), this.center = r;
                const n = Do([], this.a), i = Do([], this.b);
                this.angle = Math.acos(Vo(n, i));
            }
        }
        function gl(t1, e1) {
            if (0 === t1.angle) return null;
            let r;
            return r = 0 === t1.a[e1] ? 1 / t1.angle * .5 * Math.PI : 1 / t1.angle * Math.atan(t1.b[e1] / t1.a[e1] / Math.sin(t1.angle) - 1 / Math.tan(t1.angle)), r < 0 || r > 1 ? null : function(t1, e1, r, n) {
                const i = Math.sin(r);
                return t1 * (Math.sin((1 - n) * r) / i) + e1 * (Math.sin(n * r) / i);
            }(t1.a[e1], t1.b[e1], t1.angle, M(r, 0, 1)) + t1.center[e1];
        }
        function xl(t1) {
            if (t1.z <= 1) return dl[t1.z + 2 * t1.y + t1.x];
            const e1 = Sl(Al(t1));
            return il.fromPoints(e1);
        }
        function vl(t1, e1, r) {
            return Co(t1, t1, 1 - r), Po(t1, t1, e1, r);
        }
        function bl(t1, e1) {
            const r = Pl(e1.zoom);
            if (0 === r) return xl(t1);
            const n = Al(t1), i = Sl(n), s = Nl(n.getWest()) * e1.worldSize, a = Nl(n.getEast()) * e1.worldSize, o = Gl(n.getNorth()) * e1.worldSize, l = Gl(n.getSouth()) * e1.worldSize, u = [
                s,
                o,
                0
            ], c = [
                a,
                o,
                0
            ], h = [
                s,
                l,
                0
            ], p = [
                a,
                l,
                0
            ], d = fo([], e1.globeMatrix);
            return Fo(u, u, d), Fo(c, c, d), Fo(h, h, d), Fo(p, p, d), i[0] = vl(i[0], h, r), i[1] = vl(i[1], p, r), i[2] = vl(i[2], c, r), i[3] = vl(i[3], u, r), il.fromPoints(i);
        }
        function wl(t1, e1, r) {
            for (const n of t1)Fo(n, n, e1), Co(n, n, r);
        }
        function _l(t1, e1, r) {
            const n = e1 / t1.worldSize, i = t1.globeMatrix;
            if (r.z <= 1) {
                const t1 = xl(r).getCorners();
                return wl(t1, i, n), il.fromPoints(t1);
            }
            const s = Al(r), a = Sl(s);
            wl(a, i, n);
            const o = Number.MAX_VALUE, l = [
                -o,
                -o,
                -o
            ], u = [
                o,
                o,
                o
            ];
            if (s.contains(t1.center)) {
                for (const t1 of a)Bo(u, u, t1), Eo(l, l, t1);
                l[2] = 0;
                const e1 = t1.point, r = [
                    e1.x * n,
                    e1.y * n,
                    0
                ];
                return Bo(u, u, r), Eo(l, l, r), new il(u, l);
            }
            const c = [
                i[12] * n,
                i[13] * n,
                i[14] * n
            ], h = s.getCenter(), p = M(t1.center.lat, -Hl, Hl), d = M(h.lat, -Hl, Hl), f = Nl(t1.center.lng), y = Gl(p);
            let m = f - Nl(h.lng);
            const g = y - Gl(d);
            m > .5 ? m -= 1 : m < -0.5 && (m += 1);
            let x = 0;
            Math.abs(m) > Math.abs(g) ? x = m >= 0 ? 1 : 3 : (x = g >= 0 ? 0 : 2, Po(c, c, [
                i[4] * n,
                i[5] * n,
                i[6] * n
            ], -Math.sin(w(g >= 0 ? s.getSouth() : s.getNorth())) * ol));
            const v = a[x], b = a[(x + 1) % 4], _ = new ml(v, b, c), A = [
                gl(_, 0) || v[0],
                gl(_, 1) || v[1],
                gl(_, 2) || v[2]
            ], S = Pl(t1.zoom);
            if (S > 0) {
                const n = function({ x: t1, y: e1, z: r }, n, i, s, a) {
                    const o = 1 / (1 << r);
                    let l = t1 * o, u = l + o, c = e1 * o, h = c + o, p = 0;
                    const d = (l + u) / 2 - s;
                    return d > .5 ? p = -1 : d < -0.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [
                        [
                            l,
                            h,
                            0
                        ],
                        [
                            u,
                            h,
                            0
                        ],
                        [
                            u,
                            c,
                            0
                        ],
                        [
                            l,
                            c,
                            0
                        ]
                    ];
                }(r, e1, t1._pixelsPerMercatorPixel, f, y);
                for(let t1 = 0; t1 < a.length; t1++)vl(a[t1], n[t1], S);
                const i = Mo([], n[x], n[(x + 1) % 4]);
                Co(i, i, .5), vl(A, i, S);
            }
            for (const t1 of a)Bo(u, u, t1), Eo(l, l, t1);
            return u[2] = Math.min(v[2], b[2]), Bo(u, u, A), Eo(l, l, A), new il(u, l);
        }
        function Al({ x: t1, y: e1, z: r }) {
            const n = 1 / (1 << r), i = new Ol(Kl(t1 * n), Xl((e1 + 1) * n)), s = new Ol(Kl((t1 + 1) * n), Xl(e1 * n));
            return new oo(i, s);
        }
        function Sl(t1) {
            const e1 = w(t1.getNorth()), r = w(t1.getSouth()), n = Math.cos(e1), i = Math.cos(r), s = Math.sin(e1), a = Math.sin(r), o = t1.getWest(), l = t1.getEast();
            return [
                kl(i, a, o),
                kl(i, a, l),
                kl(n, s, l),
                kl(n, s, o)
            ];
        }
        function kl(t1, e1, r, n = ol) {
            return r = w(r), [
                t1 * Math.sin(r) * n,
                -e1 * n,
                t1 * Math.cos(r) * n
            ];
        }
        function Il(t1, e1, r) {
            return kl(Math.cos(w(t1)), Math.sin(w(t1)), e1, r);
        }
        function Ml(t1, e1, r, n) {
            const i = 1 << r.z, s = (t1 / ao + r.x) / i;
            return Il(Xl((e1 / ao + r.y) / i), Kl(s), n);
        }
        function Tl({ min: t1, max: e1 }) {
            return ll / Math.max(e1[0] - t1[0], e1[1] - t1[1], e1[2] - t1[2]);
        }
        const zl = new Float64Array(16);
        function Bl(t1) {
            const e1 = Tl(t1), r = bo(zl, [
                e1,
                e1,
                e1
            ]);
            var n, i;
            return mo(r, r, ((n = [])[0] = -(i = t1.min)[0], n[1] = -i[1], n[2] = -i[2], n));
        }
        function El(t1) {
            const e1 = (n = t1.min, (r = zl)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);
            var r, n;
            const i = 1 / Tl(t1);
            return go(e1, e1, [
                i,
                i,
                i
            ]);
        }
        function Cl(t1, e1, r, n, i) {
            const s = function(t1) {
                const e1 = ao / (2 * Math.PI);
                return t1 / (2 * Math.PI) / e1;
            }(r), a = [
                t1,
                e1,
                -r / (2 * Math.PI)
            ], o = po(new Float64Array(16));
            return mo(o, o, a), go(o, o, [
                s,
                s,
                s
            ]), xo(o, o, w(-i)), vo(o, o, w(-n)), o;
        }
        function Pl(t1) {
            return T(sl, al, t1);
        }
        function Dl(t1, e1) {
            const r = Il(e1.lat, e1.lng), n = function(t1) {
                const e1 = Il(t1._center.lat, t1._center.lng);
                let r = Lo([], Io(0, 1, 0), e1);
                const n = wo([], -t1.angle, e1);
                r = Fo(r, r, n), wo(n, -t1._pitch, r);
                const i = Do([], e1);
                return Co(i, i, fl(t1.cameraToCenterDistance / t1.pixelsPerMeter)), Fo(i, i, n), Mo([], e1, i);
            }(t1);
            var i, s, a, o, l, u, c, h, p, d;
            return a = (i = To([], n, r))[0], o = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], d = (p = Math.sqrt(a * a + o * o + l * l) * Math.sqrt(u * u + c * c + h * h)) && Vo(i, s) / p, Math.acos(Math.min(Math.max(d, -1), 1));
        }
        function Vl(t1, e1) {
            return Dl(t1, e1) > Math.PI / 2 * 1.01;
        }
        const Ll = w(85), Fl = Math.cos(Ll), Rl = Math.sin(Ll), Ul = 6371008.8, $l = 2 * Math.PI * Ul;
        class jl {
            constructor(t1, e1){
                if (isNaN(t1) || isNaN(e1)) throw new Error(`Invalid LngLat object: (${t1}, ${e1})`);
                if (this.lng = +t1, this.lat = +e1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new jl(z(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e1 = Math.PI / 180, r = this.lat * e1, n = t1.lat * e1, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e1);
                return Ul * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e1 = 360 * t1 / 40075017, r = e1 / Math.cos(Math.PI / 180 * this.lat);
                return new oo(new jl(this.lng - r, this.lat - e1), new jl(this.lng + r, this.lat + e1));
            }
            toEcef(t1) {
                const e1 = fl(t1);
                return Il(this.lat, this.lng, ol + e1);
            }
            static convert(t1) {
                if (t1 instanceof jl) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new jl(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new jl(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        var Ol = jl;
        function ql(t1) {
            return $l * Math.cos(t1 * Math.PI / 180);
        }
        function Nl(t1) {
            return (180 + t1) / 360;
        }
        function Gl(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function Zl(t1, e1) {
            return t1 / ql(e1);
        }
        function Kl(t1) {
            return 360 * t1 - 180;
        }
        function Xl(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function Jl(t1, e1) {
            return t1 * ql(Xl(e1));
        }
        const Hl = 85.051129;
        function Yl(t1) {
            return 1 / Math.cos(t1 * Math.PI / 180);
        }
        class Wl {
            constructor(t1, e1, r = 0){
                this.x = +t1, this.y = +e1, this.z = +r;
            }
            static fromLngLat(t1, e1 = 0) {
                const r = Ol.convert(t1);
                return new Wl(Nl(r.lng), Gl(r.lat), Zl(e1, r.lat));
            }
            toLngLat() {
                return new Ol(Kl(this.x), Xl(this.y));
            }
            toAltitude() {
                return Jl(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / $l * Yl(Xl(this.y));
            }
        }
        function Ql(t1, e1, r, n, i, s, a, o, l) {
            const u = (e1 + n) / 2, c = (r + i) / 2, h = new x(u, c);
            o(h), function(t1, e1, r, n, i, s) {
                const a = r - i, o = n - s;
                return Math.abs((n - e1) * a - (r - t1) * o) / Math.hypot(a, o);
            }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (Ql(t1, e1, r, u, c, s, h, o, l), Ql(t1, u, c, n, i, h, a, o, l)) : t1.push(a);
        }
        function tu(t1, e1, r) {
            let n = t1[0], i = n.x, s = n.y;
            e1(n);
            const a = [
                n
            ];
            for(let o = 1; o < t1.length; o++){
                const l = t1[o], { x: u, y: c } = l;
                e1(l), Ql(a, i, s, u, c, n, l, e1, r), i = u, s = c, n = l;
            }
            return a;
        }
        function eu(t1, e1, r, n) {
            if (n(e1, r)) {
                const i = e1.add(r)._mult(.5);
                eu(t1, e1, i, n), eu(t1, i, r, n);
            } else t1.push(r);
        }
        function ru(t1, e1) {
            let r = t1[0];
            const n = [
                r
            ];
            for(let i = 1; i < t1.length; i++){
                const s = t1[i];
                eu(n, r, s, e1), r = s;
            }
            return n;
        }
        const nu = Math.pow(2, 14) - 1, iu = -nu - 1;
        function su(t1, e1) {
            const r = Math.round(t1.x * e1), n = Math.round(t1.y * e1);
            return t1.x = M(r, iu, nu), t1.y = M(n, iu, nu), (r < t1.x || r > t1.x + 1 || n < t1.y || n > t1.y + 1) && N("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t1;
        }
        function au(t1, e1, r) {
            const n = t1.loadGeometry(), i = t1.extent, s = ao / i;
            if (e1 && r && r.projection.isReprojectedInTileSpace) {
                const s = 1 << e1.z, { scale: a, x: o, y: l, projection: u } = r, c = (t1)=>{
                    const r = Kl((e1.x + t1.x / i) / s), n = Xl((e1.y + t1.y / i) / s), c = u.project(r, n);
                    t1.x = (c.x * a - o) * i, t1.y = (c.y * a - l) * i;
                };
                for(let e1 = 0; e1 < n.length; e1++)if (1 !== t1.type) n[e1] = tu(n[e1], c, 1);
                else {
                    const t1 = [];
                    for (const r of n[e1])r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t1.push(r));
                    n[e1] = t1;
                }
            }
            for (const t1 of n)for (const e1 of t1)su(e1, s);
            return n;
        }
        function ou(t1, e1) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e1 ? au(t1) : []
            };
        }
        function lu(t1, e1, r, n, i) {
            t1.emplaceBack(2 * e1 + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        function uu(t1, e1, r) {
            const n = 16384;
            t1.emplaceBack(e1.x, e1.y, e1.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class cu {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.projection = t1.projection, this.layoutVertexArray = new $s, this.indexArray = new ra, this.segments = new so, this.programConfigurations = new Ja(t1.layers, t1.zoom), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r, n) {
                const i = this.layers[0], s = [];
                let a = null;
                "circle" === i.type && (a = i.layout.get("circle-sort-key"));
                for (const { feature: e1, id: i, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = ou(e1, t1);
                    if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u, r)) continue;
                    const c = a ? a.evaluate(u, {}, r) : void 0, h = {
                        id: i,
                        properties: e1.properties,
                        type: e1.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : au(e1, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    s.push(h);
                }
                a && s.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                let o = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new Ks, o = n.projection);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n, l = t1[s].feature;
                    this.addFeature(n, i, s, e1.availableImages, r, o), e1.featureIndex.insert(l, i, s, a, this.index);
                }
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, no.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, io.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t1, e1, r, n, i, s) {
                for (const r of e1)for (const e1 of r){
                    const r = e1.x, n = e1.y;
                    if (r < 0 || r >= ao || n < 0 || n >= ao) continue;
                    if (s) {
                        const t1 = s.projectTilePoint(r, n, i), e1 = s.upVector(i, r, n), a = this.globeExtVertexArray;
                        uu(a, t1, e1), uu(a, t1, e1), uu(a, t1, e1), uu(a, t1, e1);
                    }
                    const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), o = a.vertexLength;
                    lu(this.layoutVertexArray, r, n, -1, -1), lu(this.layoutVertexArray, r, n, 1, -1), lu(this.layoutVertexArray, r, n, 1, 1), lu(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n, i);
            }
        }
        function hu(t1, e1) {
            for(let r = 0; r < t1.length; r++)if (bu(e1, t1[r])) return !0;
            for(let r = 0; r < e1.length; r++)if (bu(t1, e1[r])) return !0;
            return !!yu(t1, e1);
        }
        function pu(t1, e1, r) {
            return !!bu(t1, e1) || !!gu(e1, t1, r);
        }
        function du(t1, e1) {
            if (1 === t1.length) return vu(e1, t1[0]);
            for(let r = 0; r < e1.length; r++){
                const n = e1[r];
                for(let e1 = 0; e1 < n.length; e1++)if (bu(t1, n[e1])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (vu(e1, t1[r])) return !0;
            for(let r = 0; r < e1.length; r++)if (yu(t1, e1[r])) return !0;
            return !1;
        }
        function fu(t1, e1, r) {
            if (t1.length > 1) {
                if (yu(t1, e1)) return !0;
                for(let n = 0; n < e1.length; n++)if (gu(e1[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (gu(t1[n], e1, r)) return !0;
            return !1;
        }
        function yu(t1, e1) {
            if (0 === t1.length || 0 === e1.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e1.length - 1; t1++)if (mu(n, i, e1[t1], e1[t1 + 1])) return !0;
            }
            return !1;
        }
        function mu(t1, e1, r, n) {
            return G(t1, r, n) !== G(e1, r, n) && G(t1, e1, r) !== G(t1, e1, n);
        }
        function gu(t1, e1, r) {
            const n = r * r;
            if (1 === e1.length) return t1.distSqr(e1[0]) < n;
            for(let r = 1; r < e1.length; r++)if (xu(t1, e1[r - 1], e1[r]) < n) return !0;
            return !1;
        }
        function xu(t1, e1, r) {
            const n = e1.distSqr(r);
            if (0 === n) return t1.distSqr(e1);
            const i = ((t1.x - e1.x) * (r.x - e1.x) + (t1.y - e1.y) * (r.y - e1.y)) / n;
            return t1.distSqr(i < 0 ? e1 : i > 1 ? r : r.sub(e1)._mult(i)._add(e1));
        }
        function vu(t1, e1) {
            let r, n, i, s = !1;
            for(let a = 0; a < t1.length; a++){
                r = t1[a];
                for(let t1 = 0, a = r.length - 1; t1 < r.length; a = t1++)n = r[t1], i = r[a], n.y > e1.y != i.y > e1.y && e1.x < (i.x - n.x) * (e1.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }
            return s;
        }
        function bu(t1, e1) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const s = t1[n], a = t1[i];
                s.y > e1.y != a.y > e1.y && e1.x < (a.x - s.x) * (e1.y - s.y) / (a.y - s.y) + s.x && (r = !r);
            }
            return r;
        }
        function wu(t1, e1, r, n, i) {
            for (const s of t1)if (e1 <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;
            const s = [
                new x(e1, r),
                new x(e1, i),
                new x(n, i),
                new x(n, r)
            ];
            if (t1.length > 2) {
                for (const e1 of s)if (bu(t1, e1)) return !0;
            }
            for(let e1 = 0; e1 < t1.length - 1; e1++)if (_u(t1[e1], t1[e1 + 1], s)) return !0;
            return !1;
        }
        function _u(t1, e1, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e1.x < n.x || t1.x > i.x && e1.x > i.x || t1.y < n.y && e1.y < n.y || t1.y > i.y && e1.y > i.y) return !1;
            const s = G(t1, e1, r[0]);
            return s !== G(t1, e1, r[1]) || s !== G(t1, e1, r[2]) || s !== G(t1, e1, r[3]);
        }
        function Au(t1, e1, r) {
            const n = e1.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e1.id).getMaxValue(t1);
        }
        function Su(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function ku(t1, e1, r, n, i) {
            if (!e1[0] && !e1[1]) return t1;
            const s = x.convert(e1)._mult(i);
            "viewport" === r && s._rotate(-n);
            const a = [];
            for(let e1 = 0; e1 < t1.length; e1++)a.push(t1[e1].sub(s));
            return a;
        }
        function Iu(t1, e1, r, n) {
            const i = x.convert(t1)._mult(n);
            return "viewport" === e1 && i._rotate(-r), i;
        }
        Ji(cu, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        const Mu = new Ps({
            "circle-sort-key": new Es(te.layout_circle["circle-sort-key"])
        });
        var Tu = {
            paint: new Ps({
                "circle-radius": new Es(te.paint_circle["circle-radius"]),
                "circle-color": new Es(te.paint_circle["circle-color"]),
                "circle-blur": new Es(te.paint_circle["circle-blur"]),
                "circle-opacity": new Es(te.paint_circle["circle-opacity"]),
                "circle-translate": new Bs(te.paint_circle["circle-translate"]),
                "circle-translate-anchor": new Bs(te.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new Bs(te.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new Bs(te.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new Es(te.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new Es(te.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new Es(te.paint_circle["circle-stroke-opacity"])
            }),
            layout: Mu
        };
        function zu(t1, e1, r, n, i, s, a, o, l) {
            if (s && t1.queryGeometry.isAboveHorizon) return !1;
            s && (l *= t1.pixelToTileUnitsFactor);
            const u = t1.tileID.canonical, c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
            for (const h of e1)for (const e1 of h){
                const h = e1.add(o), p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0, d = r.projection.projectTilePoint(h.x, h.y, u);
                if (p > 0) {
                    const t1 = r.projection.upVector(u, h.x, h.y);
                    d.x += t1[0] * c * p, d.y += t1[1] * c * p, d.z += t1[2] * c * p;
                }
                const f = s ? h : Bu(d.x, d.y, d.z, n), y = s ? t1.tilespaceRays.map((t1)=>Pu(t1, p)) : t1.queryGeometry.screenGeometry, m = Go([], [
                    d.x,
                    d.y,
                    d.z,
                    1
                ], n);
                if (!a && s ? l *= m[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / m[3]), s) {
                    const t1 = Xl((e1.y / ao + u.y) / (1 << u.z));
                    l /= r.projection.pixelsPerMeter(t1, 1) / Zl(1, t1);
                }
                if (pu(y, f, l)) return !0;
            }
            return !1;
        }
        function Bu(t1, e1, r, n) {
            const i = Go([], [
                t1,
                e1,
                r,
                1
            ], n);
            return new x(i[0] / i[3], i[1] / i[3]);
        }
        const Eu = Io(0, 0, 0), Cu = Io(0, 0, 1);
        function Pu(t1, e1) {
            const r = Ao();
            return Eu[2] = e1, t1.intersectsPlane(Eu, Cu, r), new x(r[0], r[1]);
        }
        class Du extends cu {
        }
        function Vu(t1, { width: e1, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e1 * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e1 * r * n);
            return t1.width = e1, t1.height = r, t1.data = i, t1;
        }
        function Lu(t1, e1, r) {
            const { width: n, height: i } = e1;
            n === t1.width && i === t1.height || (Fu(t1, e1, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, n),
                height: Math.min(t1.height, i)
            }, r), t1.width = n, t1.height = i, t1.data = e1.data);
        }
        function Fu(t1, e1, r, n, i, s) {
            if (0 === i.width || 0 === i.height) return e1;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e1.width || i.height > e1.height || n.x > e1.width - i.width || n.y > e1.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const a = t1.data, o = e1.data;
            for(let l = 0; l < i.height; l++){
                const u = ((r.y + l) * t1.width + r.x) * s, c = ((n.y + l) * e1.width + n.x) * s;
                for(let t1 = 0; t1 < i.width * s; t1++)o[c + t1] = a[u + t1];
            }
            return e1;
        }
        Ji(Du, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class Ru {
            constructor(t1, e1){
                Vu(this, t1, 1, e1);
            }
            resize(t1) {
                Lu(this, new Ru(t1), 1);
            }
            clone() {
                return new Ru({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e1, r, n, i) {
                Fu(t1, e1, r, n, i, 1);
            }
        }
        class Uu {
            constructor(t1, e1){
                Vu(this, t1, 4, e1);
            }
            resize(t1) {
                Lu(this, new Uu(t1), 4);
            }
            replace(t1, e1) {
                e1 ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new Uu({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e1, r, n, i) {
                Fu(t1, e1, r, n, i, 4);
            }
        }
        Ji(Ru, "AlphaImage"), Ji(Uu, "RGBAImage");
        var $u = {
            paint: new Ps({
                "heatmap-radius": new Es(te.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new Es(te.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new Bs(te.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new Cs(te.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new Bs(te.paint_heatmap["heatmap-opacity"])
            })
        };
        function ju(t1) {
            const e1 = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new Uu({
                width: r,
                height: n
            }), s = (r, n, s)=>{
                e1[t1.evaluationKey] = s;
                const a = t1.expression.evaluate(e1);
                i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);
            };
            if (t1.clips) for(let e1 = 0, i = 0; e1 < n; ++e1, i += 4 * r)for(let n = 0, a = 0; n < r; n++, a += 4){
                const o = n / (r - 1), { start: l, end: u } = t1.clips[e1];
                s(i, a, l * (1 - o) + u * o);
            }
            else for(let t1 = 0, e1 = 0; t1 < r; t1++, e1 += 4)s(0, e1, t1 / (r - 1));
            return i;
        }
        var Ou = {
            paint: new Ps({
                "hillshade-illumination-direction": new Bs(te.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new Bs(te.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new Bs(te.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new Bs(te.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new Bs(te.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new Bs(te.paint_hillshade["hillshade-accent-color"])
            })
        };
        const qu = Rs([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: Nu } = qu;
        var Gu = {
            exports: {}
        };
        function Zu(t1, e1, r) {
            r = r || 2;
            var n, i, s, a, o, l, u, c = e1 && e1.length, h = c ? e1[0] * r : t1.length, p = Ku(t1, 0, h, r, !0), d = [];
            if (!p || p.next === p.prev) return d;
            if (c && (p = function(t1, e1, r, n) {
                var i, s, a, o = [];
                for(i = 0, s = e1.length; i < s; i++)(a = Ku(t1, e1[i] * n, i < s - 1 ? e1[i + 1] * n : t1.length, n, !1)) === a.next && (a.steiner = !0), o.push(ic(a));
                for(o.sort(tc), i = 0; i < o.length; i++)r = ec(o[i], r);
                return r;
            }(t1, e1, p, r)), t1.length > 80 * r) {
                n = s = t1[0], i = a = t1[1];
                for(var f = r; f < h; f += r)(o = t1[f]) < n && (n = o), (l = t1[f + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);
                u = 0 !== (u = Math.max(s - n, a - i)) ? 32767 / u : 0;
            }
            return Ju(p, d, r, n, i, u, 0), d;
        }
        function Ku(t1, e1, r, n, i) {
            var s, a;
            if (i === gc(t1, e1, r, n) > 0) for(s = e1; s < r; s += n)a = fc(s, t1[s], t1[s + 1], a);
            else for(s = r - n; s >= e1; s -= n)a = fc(s, t1[s], t1[s + 1], a);
            return a && lc(a, a.next) && (yc(a), a = a.next), a;
        }
        function Xu(t1, e1) {
            if (!t1) return t1;
            e1 || (e1 = t1);
            var r, n = t1;
            do if (r = !1, n.steiner || !lc(n, n.next) && 0 !== oc(n.prev, n, n.next)) n = n.next;
            else {
                if (yc(n), (n = e1 = n.prev) === n.next) break;
                r = !0;
            }
            while (r || n !== e1);
            return e1;
        }
        function Ju(t1, e1, r, n, i, s, a) {
            if (t1) {
                !a && s && function(t1, e1, r, n) {
                    var i = t1;
                    do 0 === i.z && (i.z = nc(i.x, i.y, e1, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                    while (i !== t1);
                    i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                        var e1, r, n, i, s, a, o, l, u = 1;
                        do {
                            for(r = t1, t1 = null, s = null, a = 0; r;){
                                for(a++, n = r, o = 0, e1 = 0; e1 < u && (o++, n = n.nextZ); e1++);
                                for(l = u; o > 0 || l > 0 && n;)0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t1 = i, i.prevZ = s, s = i;
                                r = n;
                            }
                            s.nextZ = null, u *= 2;
                        }while (a > 1);
                    }(i);
                }(t1, n, i, s);
                for(var o, l, u = t1; t1.prev !== t1.next;)if (o = t1.prev, l = t1.next, s ? Yu(t1, n, i, s) : Hu(t1)) e1.push(o.i / r | 0), e1.push(t1.i / r | 0), e1.push(l.i / r | 0), yc(t1), t1 = l.next, u = l.next;
                else if ((t1 = l) === u) {
                    a ? 1 === a ? Ju(t1 = Wu(Xu(t1), e1, r), e1, r, n, i, s, 2) : 2 === a && Qu(t1, e1, r, n, i, s) : Ju(Xu(t1), e1, r, n, i, s, 1);
                    break;
                }
            }
        }
        function Hu(t1) {
            var e1 = t1.prev, r = t1, n = t1.next;
            if (oc(e1, r, n) >= 0) return !1;
            for(var i = e1.x, s = r.x, a = n.x, o = e1.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, d = o > l ? o > u ? o : u : l > u ? l : u, f = n.next; f !== e1;){
                if (f.x >= c && f.x <= p && f.y >= h && f.y <= d && sc(i, o, s, l, a, u, f.x, f.y) && oc(f.prev, f, f.next) >= 0) return !1;
                f = f.next;
            }
            return !0;
        }
        function Yu(t1, e1, r, n) {
            var i = t1.prev, s = t1, a = t1.next;
            if (oc(i, s, a) >= 0) return !1;
            for(var o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, d = o < l ? o < u ? o : u : l < u ? l : u, f = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = nc(d, f, e1, r, n), x = nc(y, m, e1, r, n), v = t1.prevZ, b = t1.nextZ; v && v.z >= g && b && b.z <= x;){
                if (v.x >= d && v.x <= y && v.y >= f && v.y <= m && v !== i && v !== a && sc(o, c, l, h, u, p, v.x, v.y) && oc(v.prev, v, v.next) >= 0) return !1;
                if (v = v.prevZ, b.x >= d && b.x <= y && b.y >= f && b.y <= m && b !== i && b !== a && sc(o, c, l, h, u, p, b.x, b.y) && oc(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            for(; v && v.z >= g;){
                if (v.x >= d && v.x <= y && v.y >= f && v.y <= m && v !== i && v !== a && sc(o, c, l, h, u, p, v.x, v.y) && oc(v.prev, v, v.next) >= 0) return !1;
                v = v.prevZ;
            }
            for(; b && b.z <= x;){
                if (b.x >= d && b.x <= y && b.y >= f && b.y <= m && b !== i && b !== a && sc(o, c, l, h, u, p, b.x, b.y) && oc(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            return !0;
        }
        function Wu(t1, e1, r) {
            var n = t1;
            do {
                var i = n.prev, s = n.next.next;
                !lc(i, s) && uc(i, n, n.next, s) && pc(i, s) && pc(s, i) && (e1.push(i.i / r | 0), e1.push(n.i / r | 0), e1.push(s.i / r | 0), yc(n), yc(n.next), n = t1 = s), n = n.next;
            }while (n !== t1);
            return Xu(n);
        }
        function Qu(t1, e1, r, n, i, s) {
            var a = t1;
            do {
                for(var o = a.next.next; o !== a.prev;){
                    if (a.i !== o.i && ac(a, o)) {
                        var l = dc(a, o);
                        return a = Xu(a, a.next), l = Xu(l, l.next), Ju(a, e1, r, n, i, s, 0), void Ju(l, e1, r, n, i, s, 0);
                    }
                    o = o.next;
                }
                a = a.next;
            }while (a !== t1);
        }
        function tc(t1, e1) {
            return t1.x - e1.x;
        }
        function ec(t1, e1) {
            var r = function(t1, e1) {
                var r, n = e1, i = t1.x, s = t1.y, a = -1 / 0;
                do {
                    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                        var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (o <= i && o > a && (a = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;
                    }
                    n = n.next;
                }while (n !== e1);
                if (!r) return null;
                var l, u = r, c = r.x, h = r.y, p = 1 / 0;
                n = r;
                do i >= n.x && n.x >= c && i !== n.x && sc(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), pc(n, t1) && (l < p || l === p && (n.x > r.x || n.x === r.x && rc(r, n))) && (r = n, p = l)), n = n.next;
                while (n !== u);
                return r;
            }(t1, e1);
            if (!r) return e1;
            var n = dc(r, t1);
            return Xu(n, n.next), Xu(r, r.next);
        }
        function rc(t1, e1) {
            return oc(t1.prev, t1, e1.prev) < 0 && oc(e1.next, t1, t1.next) < 0;
        }
        function nc(t1, e1, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e1 = 1431655765 & ((e1 = 858993459 & ((e1 = 252645135 & ((e1 = 16711935 & ((e1 = (e1 - n) * i | 0) | e1 << 8)) | e1 << 4)) | e1 << 2)) | e1 << 1)) << 1;
        }
        function ic(t1) {
            var e1 = t1, r = t1;
            do (e1.x < r.x || e1.x === r.x && e1.y < r.y) && (r = e1), e1 = e1.next;
            while (e1 !== t1);
            return r;
        }
        function sc(t1, e1, r, n, i, s, a, o) {
            return (i - a) * (e1 - o) >= (t1 - a) * (s - o) && (t1 - a) * (n - o) >= (r - a) * (e1 - o) && (r - a) * (s - o) >= (i - a) * (n - o);
        }
        function ac(t1, e1) {
            return t1.next.i !== e1.i && t1.prev.i !== e1.i && !function(t1, e1) {
                var r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e1.i && r.next.i !== e1.i && uc(r, r.next, t1, e1)) return !0;
                    r = r.next;
                }while (r !== t1);
                return !1;
            }(t1, e1) && (pc(t1, e1) && pc(e1, t1) && function(t1, e1) {
                var r = t1, n = !1, i = (t1.x + e1.x) / 2, s = (t1.y + e1.y) / 2;
                do r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                while (r !== t1);
                return n;
            }(t1, e1) && (oc(t1.prev, t1, e1.prev) || oc(t1, e1.prev, e1)) || lc(t1, e1) && oc(t1.prev, t1, t1.next) > 0 && oc(e1.prev, e1, e1.next) > 0);
        }
        function oc(t1, e1, r) {
            return (e1.y - t1.y) * (r.x - e1.x) - (e1.x - t1.x) * (r.y - e1.y);
        }
        function lc(t1, e1) {
            return t1.x === e1.x && t1.y === e1.y;
        }
        function uc(t1, e1, r, n) {
            var i = hc(oc(t1, e1, r)), s = hc(oc(t1, e1, n)), a = hc(oc(r, n, t1)), o = hc(oc(r, n, e1));
            return i !== s && a !== o || !(0 !== i || !cc(t1, r, e1)) || !(0 !== s || !cc(t1, n, e1)) || !(0 !== a || !cc(r, t1, n)) || !(0 !== o || !cc(r, e1, n));
        }
        function cc(t1, e1, r) {
            return e1.x <= Math.max(t1.x, r.x) && e1.x >= Math.min(t1.x, r.x) && e1.y <= Math.max(t1.y, r.y) && e1.y >= Math.min(t1.y, r.y);
        }
        function hc(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function pc(t1, e1) {
            return oc(t1.prev, t1, t1.next) < 0 ? oc(t1, e1, t1.next) >= 0 && oc(t1, t1.prev, e1) >= 0 : oc(t1, e1, t1.prev) < 0 || oc(t1, t1.next, e1) < 0;
        }
        function dc(t1, e1) {
            var r = new mc(t1.i, t1.x, t1.y), n = new mc(e1.i, e1.x, e1.y), i = t1.next, s = e1.prev;
            return t1.next = e1, e1.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
        }
        function fc(t1, e1, r, n) {
            var i = new mc(t1, e1, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function yc(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function mc(t1, e1, r) {
            this.i = t1, this.x = e1, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function gc(t1, e1, r, n) {
            for(var i = 0, s = e1, a = r - n; s < r; s += n)i += (t1[a] - t1[s]) * (t1[s + 1] + t1[a + 1]), a = s;
            return i;
        }
        Gu.exports = Zu, Gu.exports.default = Zu, Zu.deviation = function(t1, e1, r, n) {
            var i = e1 && e1.length, s = Math.abs(gc(t1, 0, i ? e1[0] * r : t1.length, r));
            if (i) for(var a = 0, o = e1.length; a < o; a++)s -= Math.abs(gc(t1, e1[a] * r, a < o - 1 ? e1[a + 1] * r : t1.length, r));
            var l = 0;
            for(a = 0; a < n.length; a += 3){
                var u = n[a] * r, c = n[a + 1] * r, h = n[a + 2] * r;
                l += Math.abs((t1[u] - t1[h]) * (t1[c + 1] - t1[u + 1]) - (t1[u] - t1[c]) * (t1[h + 1] - t1[u + 1]));
            }
            return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);
        }, Zu.flatten = function(t1) {
            for(var e1 = t1[0][0].length, r = {
                vertices: [],
                holes: [],
                dimensions: e1
            }, n = 0, i = 0; i < t1.length; i++){
                for(var s = 0; s < t1[i].length; s++)for(var a = 0; a < e1; a++)r.vertices.push(t1[i][s][a]);
                i > 0 && r.holes.push(n += t1[i - 1].length);
            }
            return r;
        };
        var xc = p(Gu.exports);
        function vc(t1, e1, r, n, i) {
            bc(t1, e1, r || 0, n || t1.length - 1, i || _c);
        }
        function bc(t1, e1, r, n, i) {
            for(; n > r;){
                if (n - r > 600) {
                    var s = n - r + 1, a = e1 - r + 1, o = Math.log(s), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
                    bc(t1, e1, Math.max(r, Math.floor(e1 - a * l / s + u)), Math.min(n, Math.floor(e1 + (s - a) * l / s + u)), i);
                }
                var c = t1[e1], h = r, p = n;
                for(wc(t1, r, e1), i(t1[n], c) > 0 && wc(t1, r, n); h < p;){
                    for(wc(t1, h, p), h++, p--; i(t1[h], c) < 0;)h++;
                    for(; i(t1[p], c) > 0;)p--;
                }
                0 === i(t1[r], c) ? wc(t1, r, p) : wc(t1, ++p, n), p <= e1 && (r = p + 1), e1 <= p && (n = p - 1);
            }
        }
        function wc(t1, e1, r) {
            var n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        function _c(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function Ac(t1, e1) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, s;
            for(let e1 = 0; e1 < r; e1++){
                const r = Z(t1[e1]);
                0 !== r && (t1[e1].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                    t1[e1]
                ]) : i.push(t1[e1]));
            }
            if (i && n.push(i), e1 > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e1 || (vc(n[t1], e1, 1, n[t1].length - 1, Sc), n[t1] = n[t1].slice(0, e1));
            return n;
        }
        function Sc(t1, e1) {
            return e1.area - t1.area;
        }
        function kc(t1, e1, r) {
            const n = r.patternDependencies;
            let i = !1;
            for (const r of e1){
                const e1 = r.paint.get(`${t1}-pattern`);
                e1.isConstant() || (i = !0);
                const s = e1.constantOr(null);
                s && (i = !0, n[s] = !0);
            }
            return i;
        }
        function Ic(t1, e1, r, n, i) {
            const s = i.patternDependencies;
            for (const a of e1){
                const e1 = a.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e1.kind) {
                    let t1 = e1.evaluate({
                        zoom: n
                    }, r, {}, i.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1, s[t1] = !0, r.patterns[a.id] = t1;
                }
            }
            return r;
        }
        class Mc {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new $s, this.indexArray = new ra, this.indexArray2 = new la, this.programConfigurations = new Ja(t1.layers, t1.zoom), this.segments = new so, this.segments2 = new so, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection;
            }
            populate(t1, e1, r, n) {
                this.hasPattern = kc("fill", this.layers, e1);
                const i = this.layers[0].layout.get("fill-sort-key"), s = [];
                for (const { feature: a, id: o, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = ou(a, t1);
                    if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r, e1.availableImages) : void 0, p = {
                        id: o,
                        properties: a.properties,
                        type: a.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : au(a, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    s.push(p);
                }
                i && s.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    if (this.hasPattern) {
                        const t1 = Ic("fill", this.layers, n, this.zoom, e1);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, {}, e1.availableImages);
                    e1.featureIndex.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            addFeatures(t1, e1, r, n, i) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e1, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Nu), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t1, e1, r, n, i, s = []) {
                for (const t1 of Ac(e1, 500)){
                    let e1 = 0;
                    for (const r of t1)e1 += r.length;
                    const r = this.segments.prepareSegment(e1, this.layoutVertexArray, this.indexArray), n = r.vertexLength, i = [], s = [];
                    for (const e1 of t1){
                        if (0 === e1.length) continue;
                        e1 !== t1[0] && s.push(i.length / 2);
                        const r = this.segments2.prepareSegment(e1.length, this.layoutVertexArray, this.indexArray2), n = r.vertexLength;
                        this.layoutVertexArray.emplaceBack(e1[0].x, e1[0].y), this.indexArray2.emplaceBack(n + e1.length - 1, n), i.push(e1[0].x), i.push(e1[0].y);
                        for(let t1 = 1; t1 < e1.length; t1++)this.layoutVertexArray.emplaceBack(e1[t1].x, e1[t1].y), this.indexArray2.emplaceBack(n + t1 - 1, n + t1), i.push(e1[t1].x), i.push(e1[t1].y);
                        r.vertexLength += e1.length, r.primitiveLength += e1.length;
                    }
                    const a = xc(i, s);
                    for(let t1 = 0; t1 < a.length; t1 += 3)this.indexArray.emplaceBack(n + a[t1], n + a[t1 + 1], n + a[t1 + 2]);
                    r.vertexLength += e1, r.primitiveLength += a.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n);
            }
        }
        Ji(Mc, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const Tc = new Ps({
            "fill-sort-key": new Es(te.layout_fill["fill-sort-key"])
        });
        var zc = {
            paint: new Ps({
                "fill-antialias": new Bs(te.paint_fill["fill-antialias"]),
                "fill-opacity": new Es(te.paint_fill["fill-opacity"]),
                "fill-color": new Es(te.paint_fill["fill-color"]),
                "fill-outline-color": new Es(te.paint_fill["fill-outline-color"]),
                "fill-translate": new Bs(te.paint_fill["fill-translate"]),
                "fill-translate-anchor": new Bs(te.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new Es(te.paint_fill["fill-pattern"])
            }),
            layout: Tc
        };
        const Bc = Rs([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), Ec = Rs([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), Cc = Rs([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: Pc } = Bc;
        var Dc = {}, Vc = m, Lc = Fc;
        function Fc(t1, e1, r, n, i) {
            this.properties = {}, this.extent = r, this.type = 0, this._pbf = t1, this._geometry = -1, this._keys = n, this._values = i, t1.readFields(Rc, this, e1);
        }
        function Rc(t1, e1, r) {
            1 == t1 ? e1.id = r.readVarint() : 2 == t1 ? function(t1, e1) {
                for(var r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = e1._keys[t1.readVarint()], i = e1._values[t1.readVarint()];
                    e1.properties[n] = i;
                }
            }(r, e1) : 3 == t1 ? e1.type = r.readVarint() : 4 == t1 && (e1._geometry = r.pos);
        }
        function Uc(t1) {
            for(var e1, r, n = 0, i = 0, s = t1.length, a = s - 1; i < s; a = i++)n += ((r = t1[a]).x - (e1 = t1[i]).x) * (e1.y + r.y);
            return n;
        }
        Fc.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ], Fc.prototype.loadGeometry = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e1, r = t1.readVarint() + t1.pos, n = 1, i = 0, s = 0, a = 0, o = []; t1.pos < r;){
                if (i <= 0) {
                    var l = t1.readVarint();
                    n = 7 & l, i = l >> 3;
                }
                if (i--, 1 === n || 2 === n) s += t1.readSVarint(), a += t1.readSVarint(), 1 === n && (e1 && o.push(e1), e1 = []), e1.push(new Vc(s, a));
                else {
                    if (7 !== n) throw new Error("unknown command " + n);
                    e1 && e1.push(e1[0].clone());
                }
            }
            return e1 && o.push(e1), o;
        }, Fc.prototype.bbox = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e1 = t1.readVarint() + t1.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t1.pos < e1;){
                if (n <= 0) {
                    var c = t1.readVarint();
                    r = 7 & c, n = c >> 3;
                }
                if (n--, 1 === r || 2 === r) (i += t1.readSVarint()) < a && (a = i), i > o && (o = i), (s += t1.readSVarint()) < l && (l = s), s > u && (u = s);
                else if (7 !== r) throw new Error("unknown command " + r);
            }
            return [
                a,
                l,
                o,
                u
            ];
        }, Fc.prototype.toGeoJSON = function(t1, e1, r) {
            var n, i, s = this.extent * Math.pow(2, r), a = this.extent * t1, o = this.extent * e1, l = this.loadGeometry(), u = Fc.types[this.type];
            function c(t1) {
                for(var e1 = 0; e1 < t1.length; e1++){
                    var r = t1[e1];
                    t1[e1] = [
                        360 * (r.x + a) / s - 180,
                        360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90
                    ];
                }
            }
            switch(this.type){
                case 1:
                    var h = [];
                    for(n = 0; n < l.length; n++)h[n] = l[n][0];
                    c(l = h);
                    break;
                case 2:
                    for(n = 0; n < l.length; n++)c(l[n]);
                    break;
                case 3:
                    for(l = function(t1) {
                        var e1 = t1.length;
                        if (e1 <= 1) return [
                            t1
                        ];
                        for(var r, n, i = [], s = 0; s < e1; s++){
                            var a = Uc(t1[s]);
                            0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [
                                t1[s]
                            ]) : r.push(t1[s]));
                        }
                        return r && i.push(r), i;
                    }(l), n = 0; n < l.length; n++)for(i = 0; i < l[n].length; i++)c(l[n][i]);
            }
            1 === l.length ? l = l[0] : u = "Multi" + u;
            var p = {
                type: "Feature",
                geometry: {
                    type: u,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id" in this && (p.id = this.id), p;
        };
        var $c = Lc, jc = Oc;
        function Oc(t1, e1) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(qc, this, e1), this.length = this._features.length;
        }
        function qc(t1, e1, r) {
            15 === t1 ? e1.version = r.readVarint() : 1 === t1 ? e1.name = r.readString() : 5 === t1 ? e1.extent = r.readVarint() : 2 === t1 ? e1._features.push(r.pos) : 3 === t1 ? e1._keys.push(r.readString()) : 4 === t1 && e1._values.push(function(t1) {
                for(var e1 = null, r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = t1.readVarint() >> 3;
                    e1 = 1 === n ? t1.readString() : 2 === n ? t1.readFloat() : 3 === n ? t1.readDouble() : 4 === n ? t1.readVarint64() : 5 === n ? t1.readVarint() : 6 === n ? t1.readSVarint() : 7 === n ? t1.readBoolean() : null;
                }
                return e1;
            }(r));
        }
        Oc.prototype.feature = function(t1) {
            if (t1 < 0 || t1 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t1];
            var e1 = this._pbf.readVarint() + this._pbf.pos;
            return new $c(this._pbf, e1, this.extent, this._keys, this._values);
        };
        var Nc = jc;
        function Gc(t1, e1, r) {
            if (3 === t1) {
                var n = new Nc(r, r.readVarint() + r.pos);
                n.length && (e1[n.name] = n);
            }
        }
        var Zc = Dc.VectorTile = function(t1, e1) {
            this.layers = t1.readFields(Gc, {}, e1);
        }, Kc = Dc.VectorTileFeature = Lc;
        function Xc(t1, e1, r, n) {
            const i = [], s = 0 === n ? (t1, e1, r, n, i, s)=>{
                t1.push(new x(s, r + (s - e1) / (n - e1) * (i - r)));
            } : (t1, e1, r, n, i, s)=>{
                t1.push(new x(e1 + (s - r) / (i - r) * (n - e1), s));
            };
            for (const a of t1){
                const t1 = [];
                for (const i of a){
                    if (i.length <= 2) continue;
                    const a = [];
                    for(let t1 = 0; t1 < i.length - 1; t1++){
                        const o = i[t1].x, l = i[t1].y, u = i[t1 + 1].x, c = i[t1 + 1].y, h = 0 === n ? o : l, p = 0 === n ? u : c;
                        h < e1 ? p > e1 && s(a, o, l, u, c, e1) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t1]), p < e1 && h >= e1 && s(a, o, l, u, c, e1), p > r && h <= r && s(a, o, l, u, c, r);
                    }
                    let o = i[i.length - 1];
                    const l = 0 === n ? o.x : o.y;
                    l >= e1 && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t1.push(a));
                }
                t1.length && i.push(t1);
            }
            return i;
        }
        Dc.VectorTileLayer = jc;
        const Jc = Kc.types, Hc = Math.pow(2, 13);
        function Yc(t1, e1, r, n, i, s, a, o) {
            t1.emplaceBack((e1 << 1) + a, (r << 1) + s, (Math.floor(n * Hc) << 1) + i, Math.round(o));
        }
        function Wc(t1, e1, r) {
            const n = 16384;
            t1.emplaceBack(e1.x, e1.y, e1.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class Qc {
            constructor(){
                this.acc = new x(0, 0), this.polyCount = [];
            }
            startRing(t1) {
                this.currentPolyCount = {
                    edges: 0,
                    top: 0
                }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new x(t1.x, t1.y), this.max = new x(t1.x, t1.y));
            }
            append(t1, e1) {
                this.currentPolyCount.edges++, this.acc._add(t1);
                const r = this.min, n = this.max;
                t1.x < r.x ? r.x = t1.x : t1.x > n.x && (n.x = t1.x), t1.y < r.y ? r.y = t1.y : t1.y > n.y && (n.y = t1.y), ((0 === t1.x || t1.x === ao) && t1.x === e1.x) != ((0 === t1.y || t1.y === ao) && t1.y === e1.y) && this.processBorderOverlap(t1, e1), e1.x < 0 != t1.x < 0 && this.addBorderIntersection(0, Er(e1.y, t1.y, (0 - e1.x) / (t1.x - e1.x))), e1.x > ao != t1.x > ao && this.addBorderIntersection(1, Er(e1.y, t1.y, (ao - e1.x) / (t1.x - e1.x))), e1.y < 0 != t1.y < 0 && this.addBorderIntersection(2, Er(e1.x, t1.x, (0 - e1.y) / (t1.y - e1.y))), e1.y > ao != t1.y > ao && this.addBorderIntersection(3, Er(e1.x, t1.x, (ao - e1.y) / (t1.y - e1.y)));
            }
            addBorderIntersection(t1, e1) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r = this.borders[t1];
                e1 < r[0] && (r[0] = e1), e1 > r[1] && (r[1] = e1);
            }
            processBorderOverlap(t1, e1) {
                if (t1.x === e1.x) {
                    if (t1.y === e1.y) return;
                    const r = 0 === t1.x ? 0 : 1;
                    this.addBorderIntersection(r, e1.y), this.addBorderIntersection(r, t1.y);
                } else {
                    const r = 0 === t1.y ? 2 : 3;
                    this.addBorderIntersection(r, e1.x), this.addBorderIntersection(r, t1.x);
                }
            }
            centroid() {
                const t1 = this.polyCount.reduce((t1, e1)=>t1 + e1.edges, 0);
                return 0 !== t1 ? this.acc.div(t1)._round() : new x(0, 0);
            }
            span() {
                return new x(this.max.x - this.min.x, this.max.y - this.min.y);
            }
            intersectsCount() {
                return this.borders.reduce((t1, e1)=>t1 + +(e1[0] !== Number.MAX_VALUE), 0);
            }
        }
        class th {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t1.projection, this.layoutVertexArray = new Os, this.centroidVertexArray = new wa, this.indexArray = new ra, this.programConfigurations = new Ja(t1.layers, t1.zoom), this.segments = new so, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.enableTerrain = t1.enableTerrain;
            }
            populate(t1, e1, r, n) {
                this.features = [], this.hasPattern = kc("fill-extrusion", this.layers, e1), this.featuresOnBorder = [], this.borders = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.tileToMeter = function(t1) {
                    const e1 = Math.exp(Math.PI * (1 - t1.y / (1 << t1.z) * 2));
                    return 80150034 * e1 / (e1 * e1 + 1) / ao / (1 << t1.z);
                }(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                for (const { feature: i, id: s, index: a, sourceLayerIndex: o } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = ou(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), l, r)) continue;
                    const u = {
                        id: s,
                        sourceLayerIndex: o,
                        index: a,
                        geometry: t1 ? l.geometry : au(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }, c = this.layoutVertexArray.length;
                    this.hasPattern ? this.features.push(Ic("fill-extrusion", this.layers, u, this.zoom, e1)) : this.addFeature(u, u.geometry, a, r, {}, e1.availableImages, n), e1.featureIndex.insert(i, u.geometry, a, o, this.index, c);
                }
                this.sortBorders();
            }
            addFeatures(t1, e1, r, n, i) {
                for (const t1 of this.features){
                    const { geometry: s } = t1;
                    this.addFeature(t1, s, t1.index, e1, r, n, i);
                }
                this.sortBorders();
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Pc), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t1.createVertexBuffer(this.layoutVertexExtArray, Cc.members, !0))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            uploadCentroid(t1) {
                0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, Ec.members, !0), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e1, r, n, i, s, a) {
                const o = [
                    new x(0, 0),
                    new x(ao, ao)
                ], l = a.projection, u = "globe" === l.name, c = this.enableTerrain && !u ? new Qc : null, h = "Polygon" === Jc[t1.type];
                u && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ks);
                const p = Ac(e1, 500);
                for(let t1 = p.length - 1; t1 >= 0; t1--){
                    const e1 = p[t1];
                    (0 === e1.length || (d = e1[0]).every((t1)=>t1.x <= 0) || d.every((t1)=>t1.x >= ao) || d.every((t1)=>t1.y <= 0) || d.every((t1)=>t1.y >= ao)) && p.splice(t1, 1);
                }
                var d;
                let f;
                if (u) f = lh(p, o, n);
                else {
                    f = [];
                    for (const t1 of p)f.push({
                        polygon: t1,
                        bounds: o
                    });
                }
                const y = h ? this.edgeRadius : 0;
                for (const { polygon: t1, bounds: e1 } of f){
                    let r = 0, i = 0;
                    for (const e1 of t1)h && !e1[0].equals(e1[e1.length - 1]) && e1.push(e1[0]), i += h ? e1.length - 1 : e1.length;
                    const s = this.segments.prepareSegment((h ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);
                    if (h) {
                        const e1 = [], i = [];
                        r = s.vertexLength;
                        for (const r of t1){
                            let a, o;
                            r.length && r !== t1[0] && i.push(e1.length / 2), a = r[1].sub(r[0])._perp()._unit();
                            for(let t1 = 1; t1 < r.length; t1++){
                                const i = r[t1], c = r[t1 === r.length - 1 ? 1 : t1 + 1];
                                let { x: h, y: p } = i;
                                if (y) {
                                    o = c.sub(i)._perp()._unit();
                                    const t1 = a.add(o)._unit(), e1 = y * Math.min(4, 1 / (a.x * t1.x + a.y * t1.y));
                                    h += e1 * t1.x, p += e1 * t1.y, a = o;
                                }
                                Yc(this.layoutVertexArray, h, p, 0, 0, 1, 1, 0), s.vertexLength++, e1.push(i.x, i.y), u && Wc(this.layoutVertexExtArray, l.projectTilePoint(h, p, n), l.upVector(n, h, p));
                            }
                        }
                        const a = xc(e1, i);
                        for(let t1 = 0; t1 < a.length; t1 += 3)this.indexArray.emplaceBack(r + a[t1], r + a[t1 + 2], r + a[t1 + 1]), s.primitiveLength++;
                    }
                    for (const i of t1){
                        c && i.length && c.startRing(i[0]);
                        let t1, a, o, p = i.length > 4 && sh(i[i.length - 2], i[0], i[1]), d = y ? rh(i[i.length - 2], i[0], i[1], y) : 0;
                        a = i[1].sub(i[0])._perp()._unit();
                        let f = !0;
                        for(let m = 1, g = 0; m < i.length; m++){
                            let x = i[m - 1], v = i[m];
                            const b = i[m === i.length - 1 ? 1 : m + 1];
                            if (c && h && c.currentPolyCount.top++, ih(v, x, e1)) {
                                y && (a = b.sub(v)._perp()._unit(), f = !f);
                                continue;
                            }
                            c && c.append(v, x);
                            const w = v.sub(x)._perp(), _ = w.x / (Math.abs(w.x) + Math.abs(w.y)), A = w.y > 0 ? 1 : 0, S = x.dist(v);
                            if (g + S > 32768 && (g = 0), y) {
                                o = b.sub(v)._perp()._unit();
                                let t1 = nh(x, v, b, eh(a, o), y);
                                isNaN(t1) && (t1 = 0);
                                const e1 = v.sub(x)._unit();
                                x = x.add(e1.mult(d))._round(), v = v.add(e1.mult(-t1))._round(), d = t1, a = o;
                            }
                            const k = s.vertexLength, I = i.length > 4 && sh(x, v, b);
                            let M = ah(g, p, f);
                            if (Yc(this.layoutVertexArray, x.x, x.y, _, A, 0, 0, M), Yc(this.layoutVertexArray, x.x, x.y, _, A, 0, 1, M), g += S, M = ah(g, I, !f), p = I, Yc(this.layoutVertexArray, v.x, v.y, _, A, 0, 0, M), Yc(this.layoutVertexArray, v.x, v.y, _, A, 0, 1, M), s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, y) {
                                const n = r + (1 === m ? i.length - 2 : m - 2), a = 1 === m ? r : n + 1;
                                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, a, k + 3), s.primitiveLength += 2, void 0 === t1 && (t1 = k), !ih(b, i[m], e1)) {
                                    const e1 = m === i.length - 1 ? t1 : s.vertexLength;
                                    this.indexArray.emplaceBack(k + 2, k + 3, e1), this.indexArray.emplaceBack(k + 3, e1 + 1, e1), this.indexArray.emplaceBack(k + 3, a, e1 + 1), s.primitiveLength += 3;
                                }
                                f = !f;
                            }
                            if (u) {
                                const t1 = this.layoutVertexExtArray, e1 = l.projectTilePoint(x.x, x.y, n), r = l.projectTilePoint(v.x, v.y, n), i = l.upVector(n, x.x, x.y), s = l.upVector(n, v.x, v.y);
                                Wc(t1, e1, i), Wc(t1, e1, i), Wc(t1, r, s), Wc(t1, r, s);
                            }
                        }
                        h && (r += i.length - 1);
                    }
                }
                if (c && c.polyCount.length > 0) {
                    if (c.borders) {
                        c.vertexArrayOffset = this.centroidVertexArray.length;
                        const t1 = c.borders, e1 = this.featuresOnBorder.push(c) - 1;
                        for(let r = 0; r < 4; r++)t1[r][0] !== Number.MAX_VALUE && this.borders[r].push(e1);
                    }
                    this.encodeCentroid(c.borders ? void 0 : c.centroid(), c);
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n);
            }
            sortBorders() {
                for(let t1 = 0; t1 < 4; t1++)this.borders[t1].sort((e1, r)=>this.featuresOnBorder[e1].borders[t1][0] - this.featuresOnBorder[r].borders[t1][0]);
            }
            encodeCentroid(t1, e1, r = !0) {
                let n, i;
                if (t1) {
                    if (0 !== t1.y) {
                        const r = e1.span()._mult(this.tileToMeter);
                        n = (Math.max(t1.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t1.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));
                    } else n = Math.ceil(7 * (t1.x + 450)), i = 0;
                } else n = 0, i = +r;
                let s = r ? this.centroidVertexArray.length : e1.vertexArrayOffset;
                for (const t1 of e1.polyCount){
                    r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t1.edges + t1.top);
                    for(let e1 = 0; e1 < t1.top; e1++)this.centroidVertexArray.emplace(s++, n, i);
                    for(let e1 = 0; e1 < 2 * t1.edges; e1++)this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);
                }
            }
        }
        function eh(t1, e1) {
            const r = t1.add(e1)._unit();
            return t1.x * r.x + t1.y * r.y;
        }
        function rh(t1, e1, r, n) {
            const i = e1.sub(t1)._perp()._unit(), s = r.sub(e1)._perp()._unit();
            return nh(t1, e1, r, eh(i, s), n);
        }
        function nh(t1, e1, r, n, i) {
            const s = Math.sqrt(1 - n * n);
            return Math.min(t1.dist(e1) / 3, e1.dist(r) / 3, i * s / n);
        }
        function ih(t1, e1, r) {
            return t1.x < r[0].x && e1.x < r[0].x || t1.x > r[1].x && e1.x > r[1].x || t1.y < r[0].y && e1.y < r[0].y || t1.y > r[1].y && e1.y > r[1].y;
        }
        function sh(t1, e1, r) {
            if (t1.x < 0 || t1.x >= ao || e1.x < 0 || e1.x >= ao || r.x < 0 || r.x >= ao) return !1;
            const n = r.sub(e1), i = n.perp(), s = t1.sub(e1);
            return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -0.866 && i.x * s.x + i.y * s.y < 0;
        }
        function ah(t1, e1, r) {
            const n = e1 ? 2 | t1 : -3 & t1;
            return r ? 1 | n : -2 & n;
        }
        function oh() {
            const t1 = Math.PI / 32, e1 = Math.tan(t1), r = Ul;
            return r * Math.sqrt(1 + 2 * e1 * e1) - r;
        }
        function lh(t1, e1, r) {
            const n = 1 << r.z, i = Kl(r.x / n), s = Kl((r.x + 1) / n), a = Xl(r.y / n), o = Xl((r.y + 1) / n);
            return function(t1, e1, r, n, i = 0, s) {
                const a = [];
                if (!t1.length || !r || !n) return a;
                const o = (t1, e1)=>{
                    for (const r of t1)a.push({
                        polygon: r,
                        bounds: e1
                    });
                }, l = Math.ceil(Math.log2(r)), u = Math.ceil(Math.log2(n)), c = l - u, h = [];
                for(let t1 = 0; t1 < Math.abs(c); t1++)h.push(c > 0 ? 0 : 1);
                for(let t1 = 0; t1 < Math.min(l, u); t1++)h.push(0), h.push(1);
                let p = t1;
                if (p = Xc(p, e1[0].y - i, e1[1].y + i, 1), p = Xc(p, e1[0].x - i, e1[1].x + i, 0), !p.length) return a;
                const d = [];
                for(h.length ? d.push({
                    polygons: p,
                    bounds: e1,
                    depth: 0
                }) : o(p, e1); d.length;){
                    const t1 = d.pop(), e1 = t1.depth, r = h[e1], n = t1.bounds[0], a = t1.bounds[1], l = 0 === r ? n.x : n.y, u = 0 === r ? a.x : a.y, c = s ? s(r, l, u) : .5 * (l + u), p = Xc(t1.polygons, l - i, c + i, r), f = Xc(t1.polygons, c - i, u + i, r);
                    if (p.length) {
                        const t1 = [
                            n,
                            new x(0 === r ? c : a.x, 1 === r ? c : a.y)
                        ];
                        h.length > e1 + 1 ? d.push({
                            polygons: p,
                            bounds: t1,
                            depth: e1 + 1
                        }) : o(p, t1);
                    }
                    if (f.length) {
                        const t1 = [
                            new x(0 === r ? c : n.x, 1 === r ? c : n.y),
                            a
                        ];
                        h.length > e1 + 1 ? d.push({
                            polygons: f,
                            bounds: t1,
                            depth: e1 + 1
                        }) : o(f, t1);
                    }
                }
                return a;
            }(t1, e1, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t1, e1, i)=>{
                if (0 === t1) return .5 * (e1 + i);
                {
                    const t1 = Xl((r.y + e1 / ao) / n);
                    return (Gl(.5 * (Xl((r.y + i / ao) / n) + t1)) * n - r.y) * ao;
                }
            });
        }
        Ji(th, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), Ji(Qc, "PartMetadata");
        const uh = new Ps({
            "fill-extrusion-edge-radius": new Bs(te["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
        });
        var ch = {
            paint: new Ps({
                "fill-extrusion-opacity": new Bs(te["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new Es(te["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new Es(te["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new Es(te["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new Es(te["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new Bs(te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                "fill-extrusion-ambient-occlusion-intensity": new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                "fill-extrusion-ambient-occlusion-radius": new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                "fill-extrusion-rounded-roof": new Bs(te["paint_fill-extrusion"]["fill-extrusion-rounded-roof"])
            }),
            layout: uh
        };
        function hh(t1, e1, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
            return [
                t1 * n - 2 * Math.PI * 6378137 / 2,
                e1 * n - 2 * Math.PI * 6378137 / 2
            ];
        }
        class ph {
            constructor(t1, e1, r){
                this.z = t1, this.x = e1, this.y = r, this.key = yh(0, t1, t1, e1, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            url(t1, e1) {
                const r = function(t1, e1, r) {
                    var n = hh(256 * t1, 256 * (e1 = Math.pow(2, r) - e1 - 1), r), i = hh(256 * (t1 + 1), 256 * (e1 + 1), r);
                    return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
                }(this.x, this.y, this.z), n = function(t1, e1, r) {
                    let n, i = "";
                    for(let s = t1; s > 0; s--)n = 1 << s - 1, i += (e1 & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class dh {
            constructor(t1, e1){
                this.wrap = t1, this.canonical = e1, this.key = yh(t1, e1.z, e1.z, e1.x, e1.y);
            }
        }
        class fh {
            constructor(t1, e1, r, n, i){
                this.overscaledZ = t1, this.wrap = e1, this.canonical = new ph(r, +n, +i), this.key = 0 === e1 && t1 === r ? this.canonical.key : yh(e1, t1, r, n, i);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                const e1 = this.canonical.z - t1;
                return t1 > this.canonical.z ? new fh(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fh(t1, this.wrap, t1, this.canonical.x >> e1, this.canonical.y >> e1);
            }
            calculateScaledKey(t1, e1 = !0) {
                if (this.overscaledZ === t1 && e1) return this.key;
                if (t1 > this.canonical.z) return yh(this.wrap * +e1, t1, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r = this.canonical.z - t1;
                    return yh(this.wrap * +e1, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
                }
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e1 = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.x === this.canonical.x >> e1 && t1.canonical.y === this.canonical.y >> e1;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new fh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e1 = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new fh(e1, this.wrap, e1, r, n),
                    new fh(e1, this.wrap, e1, r + 1, n),
                    new fh(e1, this.wrap, e1, r, n + 1),
                    new fh(e1, this.wrap, e1, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new fh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new fh(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new dh(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function yh(t1, e1, r, n, i) {
            const s = 1 << Math.min(r, 22);
            let a = s * (i % s) + n % s;
            return t1 && r < 22 && (a += s * s * ((t1 < 0 ? -2 * t1 - 1 : 2 * t1) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e1 - r);
        }
        Ji(ph, "CanonicalTileID"), Ji(fh, "OverscaledTileID", {
            omit: [
                "projMatrix"
            ]
        });
        class mh extends x {
            constructor(t1, e1, r){
                super(t1, e1), this.z = r;
            }
        }
        function gh(t1, e1) {
            return t1.x * e1.x + t1.y * e1.y;
        }
        function xh(t1, e1) {
            if (1 === t1.length) {
                let r = 0;
                const n = e1[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e1[r++], !i) return 1 / 0;
                for(; r < e1.length; r++){
                    const s = e1[r], a = t1[0], o = i.sub(n), l = s.sub(n), u = a.sub(n), c = gh(o, o), h = gh(o, l), p = gh(l, l), d = gh(u, o), f = gh(u, l), y = c * p - h * h, m = (p * d - h * f) / y, g = (c * f - h * d) / y, x = n.z * (1 - m - g) + i.z * m + s.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e1)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        function vh(t1, e1, r, n, i, s, a, o) {
            const l = a * i.getElevationAt(t1, e1, !0, !0), u = 0 !== s[0], c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function(t1, e1, r) {
                const n = Math.floor(e1[0] / 8), i = Math.floor(e1[1] / 8), s = 10 * (e1[0] - 8 * n), a = 10 * (e1[1] - 8 * i), o = t1.getElevationAt(n, i, !0, !0), l = t1.getMeterToDEM(r), u = Math.floor(.5 * (s * l - 1)), c = Math.floor(.5 * (a * l - 1)), h = t1.tileCoordToPixel(n, i), p = 2 * u + 1, d = 2 * c + 1, f = function(t1, e1, r, n, i) {
                    return [
                        t1.getElevationAtPixel(e1, r, !0),
                        t1.getElevationAtPixel(e1 + i, r, !0),
                        t1.getElevationAtPixel(e1, r + i, !0),
                        t1.getElevationAtPixel(e1 + n, r + i, !0)
                    ];
                }(t1, h.x - u, h.y - c, p, d), y = Math.abs(f[0] - f[1]), m = Math.abs(f[2] - f[3]), g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]), x = Math.min(.25, .5 * l * (y + m) / p), v = Math.min(.25, .5 * l * g / d);
                return o + Math.max(x * s, v * a);
            }(i, s, o) : l;
            return {
                base: l + (0 === r) ? -1 : r,
                top: u ? Math.max(c + n, l + r + 2) : l + n
            };
        }
        const bh = Rs([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), { members: wh } = bh, _h = Rs([
            {
                name: "a_packed",
                components: 4,
                type: "Float32"
            }
        ]), { members: Ah } = _h, Sh = Kc.types, kh = Math.cos(Math.PI / 180 * 37.5);
        class Ih {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.projection = t1.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new qs, this.layoutVertexArray2 = new Ns, this.indexArray = new ra, this.programConfigurations = new Ja(t1.layers, t1.zoom), this.segments = new so, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r, n) {
                this.hasPattern = kc("line", this.layers, e1);
                const i = this.layers[0].layout.get("line-sort-key"), s = [];
                for (const { feature: e1, id: a, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = ou(e1, t1);
                    if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u, r)) continue;
                    const c = i ? i.evaluate(u, {}, r) : void 0, h = {
                        id: a,
                        properties: e1.properties,
                        type: e1.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : au(e1, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    s.push(h);
                }
                i && s.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                const { lineAtlas: a, featureIndex: o } = e1, l = this.addConstantDashes(a);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: u } = n;
                    if (l && this.addFeatureDashes(n, a), this.hasPattern) {
                        const t1 = Ic("line", this.layers, n, this.zoom, e1);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, a.positions, e1.availableImages);
                    o.insert(t1[s].feature, i, s, u, this.index);
                }
            }
            addConstantDashes(t1) {
                let e1 = !1;
                for (const r of this.layers){
                    const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind) e1 = !0;
                    else {
                        const e1 = i.value, r = n.value;
                        if (!r) continue;
                        t1.addDash(r, e1);
                    }
                }
                return e1;
            }
            addFeatureDashes(t1, e1) {
                const r = this.zoom;
                for (const n of this.layers){
                    const i = n.paint.get("line-dasharray").value, s = n.layout.get("line-cap").value;
                    if ("constant" === i.kind && "constant" === s.kind) continue;
                    let a, o;
                    if ("constant" === i.kind) {
                        if (a = i.value, !a) continue;
                    } else a = i.evaluate({
                        zoom: r
                    }, t1);
                    o = "constant" === s.kind ? s.value : s.evaluate({
                        zoom: r
                    }, t1), e1.addDash(a, o), t1.patterns[n.id] = e1.getKey(a, o);
                }
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            addFeatures(t1, e1, r, n, i) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e1, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, Ah)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, wh), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1) {
                if (t1.properties && t1.properties.hasOwnProperty("mapbox_clip_start") && t1.properties.hasOwnProperty("mapbox_clip_end")) return {
                    start: +t1.properties.mapbox_clip_start,
                    end: +t1.properties.mapbox_clip_end
                };
            }
            addFeature(t1, e1, r, n, i, s) {
                const a = this.layers[0].layout, o = a.get("line-join").evaluate(t1, {}), l = a.get("line-cap").evaluate(t1, {}), u = a.get("line-miter-limit"), c = a.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1);
                for (const r of e1)this.addLine(r, t1, o, l, u, c);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n);
            }
            addLine(t1, e1, r, n, i, s) {
                if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for(let e1 = 0; e1 < t1.length - 1; e1++)this.totalDistance += t1[e1].dist(t1[e1 + 1]);
                    this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const a = "Polygon" === Sh[e1.type];
                let o = t1.length;
                for(; o >= 2 && t1[o - 1].equals(t1[o - 2]);)o--;
                let l = 0;
                for(; l < o - 1 && t1[l].equals(t1[l + 1]);)l++;
                if (o < (a ? 3 : 2)) return;
                "bevel" === r && (i = 1.05);
                const u = this.overscaling <= 16 ? 15 * ao / (512 * this.overscaling) : 0, c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);
                let h, p, d, f, y;
                this.e1 = this.e2 = -1, a && (h = t1[o - 2], y = t1[l].sub(h)._unit()._perp());
                for(let e1 = l; e1 < o; e1++){
                    if (d = e1 === o - 1 ? a ? t1[l + 1] : void 0 : t1[e1 + 1], d && t1[e1].equals(d)) continue;
                    y && (f = y), h && (p = h), h = t1[e1], y = d ? d.sub(h)._unit()._perp() : f, f = f || y;
                    let m = f.add(y);
                    0 === m.x && 0 === m.y || m._unit();
                    const g = f.x * y.x + f.y * y.y, x = m.x * y.x + m.y * y.y, v = 0 !== x ? 1 / x : 1 / 0, b = 2 * Math.sqrt(2 - 2 * x), w = x < kh && p && d, _ = f.x * y.y - f.y * y.x > 0;
                    if (w && e1 > l) {
                        const t1 = h.dist(p);
                        if (t1 > 2 * u) {
                            const e1 = h.sub(h.sub(p)._mult(u / t1)._round());
                            this.updateDistance(p, e1), this.addCurrentVertex(e1, f, 0, 0, c), p = e1;
                        }
                    }
                    const A = p && d;
                    let S = A ? r : a ? "butt" : n;
                    if (A && "round" === S && (v < s ? S = "miter" : v <= 2 && (S = "fakeround")), "miter" === S && v > i && (S = "bevel"), "bevel" === S && (v > 2 && (S = "flipbevel"), v < i && (S = "miter")), p && this.updateDistance(p, h), "miter" === S) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);
                    else if ("flipbevel" === S) {
                        if (v > 100) m = y.mult(-1);
                        else {
                            const t1 = v * f.add(y).mag() / f.sub(y).mag();
                            m._perp()._mult(t1 * (_ ? -1 : 1));
                        }
                        this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);
                    } else if ("bevel" === S || "fakeround" === S) {
                        const t1 = -Math.sqrt(v * v - 1), e1 = _ ? t1 : 0, r = _ ? 0 : t1;
                        if (p && this.addCurrentVertex(h, f, e1, r, c), "fakeround" === S) {
                            const t1 = Math.round(180 * b / Math.PI / 20);
                            for(let e1 = 1; e1 < t1; e1++){
                                let r = e1 / t1;
                                if (.5 !== r) {
                                    const t1 = r - .5;
                                    r += r * t1 * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t1 * t1 + (.848013 + g * (.215638 * g - 1.06021)));
                                }
                                const n = y.sub(f)._mult(r)._add(f)._unit()._mult(_ ? -1 : 1);
                                this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);
                            }
                        }
                        d && this.addCurrentVertex(h, y, -e1, -r, c);
                    } else if ("butt" === S) this.addCurrentVertex(h, m, 0, 0, c);
                    else if ("square" === S) {
                        const t1 = p ? 1 : -1;
                        p || this.addCurrentVertex(h, m, t1, t1, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t1, t1, c);
                    } else "round" === S && (p && (this.addCurrentVertex(h, f, 0, 0, c), this.addCurrentVertex(h, f, 1, 1, c, !0)), d && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));
                    if (w && e1 < o - 1) {
                        const t1 = h.dist(d);
                        if (t1 > 2 * u) {
                            const e1 = h.add(d.sub(h)._mult(u / t1)._round());
                            this.updateDistance(h, e1), this.addCurrentVertex(e1, y, 0, 0, c), h = e1;
                        }
                    }
                }
            }
            addCurrentVertex(t1, e1, r, n, i, s = !1) {
                const a = e1.y * n - e1.x, o = -e1.y - e1.x * n;
                this.addHalfVertex(t1, e1.x + e1.y * r, e1.y - e1.x * r, s, !1, r, i), this.addHalfVertex(t1, a, o, s, !0, -n, i);
            }
            addHalfVertex({ x: t1, y: e1 }, r, n, i, s, a, o) {
                this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e1 << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const l = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;
            }
            updateScaledDistance() {
                if (this.lineClips) {
                    const t1 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                    this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t1 * this.lineClips.start + this.distance;
                } else this.lineSoFar = this.distance;
            }
            updateDistance(t1, e1) {
                this.distance += t1.dist(e1), this.updateScaledDistance();
            }
        }
        Ji(Ih, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const Mh = new Ps({
            "line-cap": new Es(te.layout_line["line-cap"]),
            "line-join": new Es(te.layout_line["line-join"]),
            "line-miter-limit": new Bs(te.layout_line["line-miter-limit"]),
            "line-round-limit": new Bs(te.layout_line["line-round-limit"]),
            "line-sort-key": new Es(te.layout_line["line-sort-key"])
        });
        var Th = {
            paint: new Ps({
                "line-opacity": new Es(te.paint_line["line-opacity"]),
                "line-color": new Es(te.paint_line["line-color"]),
                "line-translate": new Bs(te.paint_line["line-translate"]),
                "line-translate-anchor": new Bs(te.paint_line["line-translate-anchor"]),
                "line-width": new Es(te.paint_line["line-width"]),
                "line-gap-width": new Es(te.paint_line["line-gap-width"]),
                "line-offset": new Es(te.paint_line["line-offset"]),
                "line-blur": new Es(te.paint_line["line-blur"]),
                "line-dasharray": new Es(te.paint_line["line-dasharray"]),
                "line-pattern": new Es(te.paint_line["line-pattern"]),
                "line-gradient": new Cs(te.paint_line["line-gradient"]),
                "line-trim-offset": new Bs(te.paint_line["line-trim-offset"])
            }),
            layout: Mh
        };
        const zh = new class extends Es {
            possiblyEvaluate(t1, e1) {
                return e1 = new ws(Math.floor(e1.zoom), {
                    now: e1.now,
                    fadeDuration: e1.fadeDuration,
                    transition: e1.transition
                }), super.possiblyEvaluate(t1, e1);
            }
            evaluate(t1, e1, r, n) {
                return e1 = C({}, e1, {
                    zoom: Math.floor(e1.zoom)
                }), super.evaluate(t1, e1, r, n);
            }
        }(Th.paint.properties["line-width"].specification);
        function Bh(t1, e1) {
            return e1 > 0 ? e1 + 2 * t1 : t1;
        }
        zh.useIntegerZoom = !0;
        const Eh = Rs([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), Ch = Rs([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), Ph = Rs([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        Rs([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const Dh = Rs([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }
        ]), Vh = Rs([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            }
        ]);
        Rs([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const Lh = Rs([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), Fh = Rs([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        Rs([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), Rs([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), Rs([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            }
        ]), Rs([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), Rs([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        var Rh = 24;
        const Uh = 128;
        function $h(t1, e1) {
            const { expression: r } = e1;
            if ("constant" === r.kind) return {
                kind: "constant",
                layoutSize: r.evaluate(new ws(t1 + 1))
            };
            if ("source" === r.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e1, interpolationType: n } = r;
                let i = 0;
                for(; i < e1.length && e1[i] <= t1;)i++;
                i = Math.max(0, i - 1);
                let s = i;
                for(; s < e1.length && e1[s] < t1 + 1;)s++;
                s = Math.min(e1.length - 1, s);
                const a = e1[i], o = e1[s];
                return "composite" === r.kind ? {
                    kind: "composite",
                    minZoom: a,
                    maxZoom: o,
                    interpolationType: n
                } : {
                    kind: "camera",
                    minZoom: a,
                    maxZoom: o,
                    minSize: r.evaluate(new ws(a)),
                    maxSize: r.evaluate(new ws(o)),
                    interpolationType: n
                };
            }
        }
        function jh(t1, { uSize: e1, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t1.kind ? n / Uh : "composite" === t1.kind ? Er(n / Uh, i / Uh, r) : e1;
        }
        function Oh(t1, e1) {
            let r = 0, n = 0;
            if ("constant" === t1.kind) n = t1.layoutSize;
            else if ("source" !== t1.kind) {
                const { interpolationType: i, minZoom: s, maxZoom: a } = t1, o = i ? M(Qr.interpolationFactor(i, e1, s, a), 0, 1) : 0;
                "camera" === t1.kind ? n = Er(t1.minSize, t1.maxSize, o) : r = o;
            }
            return {
                uSizeT: r,
                uSize: n
            };
        }
        var qh = Object.freeze({
            __proto__: null,
            SIZE_PACK_FACTOR: Uh,
            evaluateSizeForFeature: jh,
            evaluateSizeForZoom: Oh,
            getSizeData: $h
        });
        function Nh(t1, e1, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e1, r) {
                    const n = e1.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), bs.applyArabicShaping && (t1 = bs.applyArabicShaping(t1)), t1;
                }(t1.text, e1, r);
            }), t1;
        }
        const Gh = {
            "!": "\uFE15",
            "#": "\uFF03",
            $: "\uFF04",
            "%": "\uFF05",
            "&": "\uFF06",
            "(": "\uFE35",
            ")": "\uFE36",
            "*": "\uFF0A",
            "+": "\uFF0B",
            ",": "\uFE10",
            "-": "\uFE32",
            ".": "\u30FB",
            "/": "\uFF0F",
            ":": "\uFE13",
            ";": "\uFE14",
            "<": "\uFE3F",
            "=": "\uFF1D",
            ">": "\uFE40",
            "?": "\uFE16",
            "@": "\uFF20",
            "[": "\uFE47",
            "\\": "\uFF3C",
            "]": "\uFE48",
            "^": "\uFF3E",
            _: "\uFE33",
            "`": "\uFF40",
            "{": "\uFE37",
            "|": "\u2015",
            "}": "\uFE38",
            "~": "\uFF5E",
            "\xa2": "\uFFE0",
            "\xa3": "\uFFE1",
            "\xa5": "\uFFE5",
            "\xa6": "\uFFE4",
            "\xac": "\uFFE2",
            "\xaf": "\uFFE3",
            "\u2013": "\uFE32",
            "\u2014": "\uFE31",
            "\u2018": "\uFE43",
            "\u2019": "\uFE44",
            "\u201C": "\uFE41",
            "\u201D": "\uFE42",
            "\u2026": "\uFE19",
            "\u2027": "\u30FB",
            "\u20A9": "\uFFE6",
            "\u3001": "\uFE11",
            "\u3002": "\uFE12",
            "\u3008": "\uFE3F",
            "\u3009": "\uFE40",
            "\u300A": "\uFE3D",
            "\u300B": "\uFE3E",
            "\u300C": "\uFE41",
            "\u300D": "\uFE42",
            "\u300E": "\uFE43",
            "\u300F": "\uFE44",
            "\u3010": "\uFE3B",
            "\u3011": "\uFE3C",
            "\u3014": "\uFE39",
            "\u3015": "\uFE3A",
            "\u3016": "\uFE17",
            "\u3017": "\uFE18",
            "\uFF01": "\uFE15",
            "\uFF08": "\uFE35",
            "\uFF09": "\uFE36",
            "\uFF0C": "\uFE10",
            "\uFF0D": "\uFE32",
            "\uFF0E": "\u30FB",
            "\uFF1A": "\uFE13",
            "\uFF1B": "\uFE14",
            "\uFF1C": "\uFE3F",
            "\uFF1E": "\uFE40",
            "\uFF1F": "\uFE16",
            "\uFF3B": "\uFE47",
            "\uFF3D": "\uFE48",
            "\uFF3F": "\uFE33",
            "\uFF5B": "\uFE37",
            "\uFF5C": "\u2015",
            "\uFF5D": "\uFE38",
            "\uFF5F": "\uFE35",
            "\uFF60": "\uFE36",
            "\uFF61": "\uFE12",
            "\uFF62": "\uFE41",
            "\uFF63": "\uFE42",
            "\u2190": "\u2191",
            "\u2192": "\u2193"
        };
        function Zh(t1) {
            return "\uFE36" === t1 || "\uFE48" === t1 || "\uFE38" === t1 || "\uFE44" === t1 || "\uFE42" === t1 || "\uFE3E" === t1 || "\uFE3C" === t1 || "\uFE3A" === t1 || "\uFE18" === t1 || "\uFE40" === t1 || "\uFE10" === t1 || "\uFE13" === t1 || "\uFE14" === t1 || "\uFF40" === t1 || "\uFFE3" === t1 || "\uFE11" === t1 || "\uFE12" === t1;
        }
        function Kh(t1) {
            return "\uFE35" === t1 || "\uFE47" === t1 || "\uFE37" === t1 || "\uFE43" === t1 || "\uFE41" === t1 || "\uFE3D" === t1 || "\uFE3B" === t1 || "\uFE39" === t1 || "\uFE17" === t1 || "\uFE3F" === t1;
        }
        var Xh = Yh, Jh = function(t1, e1, r, n, i) {
            var s, a, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, d = t1[e1 + h];
            for(h += p, s = d & (1 << -c) - 1, d >>= -c, c += o; c > 0; s = 256 * s + t1[e1 + h], h += p, c -= 8);
            for(a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t1[e1 + h], h += p, c -= 8);
            if (0 === s) s = 1 - u;
            else {
                if (s === l) return a ? NaN : 1 / 0 * (d ? -1 : 1);
                a += Math.pow(2, n), s -= u;
            }
            return (d ? -1 : 1) * a * Math.pow(2, s - n);
        }, Hh = function(t1, e1, r, n, i, s) {
            var a, o, l, u = 8 * s - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : s - 1, f = n ? 1 : -1, y = e1 < 0 || 0 === e1 && 1 / e1 < 0 ? 1 : 0;
            for(e1 = Math.abs(e1), isNaN(e1) || e1 === 1 / 0 ? (o = isNaN(e1) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e1) / Math.LN2), e1 * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e1 += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e1 * l - 1) * Math.pow(2, i), a += h) : (o = e1 * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t1[r + d] = 255 & o, d += f, o /= 256, i -= 8);
            for(a = a << i | o, u += i; u > 0; t1[r + d] = 255 & a, d += f, a /= 256, u -= 8);
            t1[r + d - f] |= 128 * y;
        };
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ function Yh(t1) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Yh.Varint = 0, Yh.Fixed64 = 1, Yh.Bytes = 2, Yh.Fixed32 = 5;
        var Wh = 4294967296, Qh = 1 / Wh, tp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function ep(t1) {
            return t1.type === Yh.Bytes ? t1.readVarint() + t1.pos : t1.pos + 1;
        }
        function rp(t1, e1, r) {
            return r ? 4294967296 * e1 + (t1 >>> 0) : 4294967296 * (e1 >>> 0) + (t1 >>> 0);
        }
        function np(t1, e1, r) {
            var n = e1 <= 16383 ? 1 : e1 <= 2097151 ? 2 : e1 <= 268435455 ? 3 : Math.floor(Math.log(e1) / (7 * Math.LN2));
            r.realloc(n);
            for(var i = r.pos - 1; i >= t1; i--)r.buf[i + n] = r.buf[i];
        }
        function ip(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeVarint(t1[r]);
        }
        function sp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSVarint(t1[r]);
        }
        function ap(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFloat(t1[r]);
        }
        function op(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeDouble(t1[r]);
        }
        function lp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeBoolean(t1[r]);
        }
        function up(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFixed32(t1[r]);
        }
        function cp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSFixed32(t1[r]);
        }
        function hp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFixed64(t1[r]);
        }
        function pp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSFixed64(t1[r]);
        }
        function dp(t1, e1) {
            return (t1[e1] | t1[e1 + 1] << 8 | t1[e1 + 2] << 16) + 16777216 * t1[e1 + 3];
        }
        function fp(t1, e1, r) {
            t1[r] = e1, t1[r + 1] = e1 >>> 8, t1[r + 2] = e1 >>> 16, t1[r + 3] = e1 >>> 24;
        }
        function yp(t1, e1) {
            return (t1[e1] | t1[e1 + 1] << 8 | t1[e1 + 2] << 16) + (t1[e1 + 3] << 24);
        }
        Yh.prototype = {
            destroy: function() {
                this.buf = null;
            },
            readFields: function(t1, e1, r) {
                for(r = r || this.length; this.pos < r;){
                    var n = this.readVarint(), i = n >> 3, s = this.pos;
                    this.type = 7 & n, t1(i, e1, this), this.pos === s && this.skip(n);
                }
                return e1;
            },
            readMessage: function(t1, e1) {
                return this.readFields(t1, e1, this.readVarint() + this.pos);
            },
            readFixed32: function() {
                var t1 = dp(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readSFixed32: function() {
                var t1 = yp(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readFixed64: function() {
                var t1 = dp(this.buf, this.pos) + dp(this.buf, this.pos + 4) * Wh;
                return this.pos += 8, t1;
            },
            readSFixed64: function() {
                var t1 = dp(this.buf, this.pos) + yp(this.buf, this.pos + 4) * Wh;
                return this.pos += 8, t1;
            },
            readFloat: function() {
                var t1 = Jh(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4, t1;
            },
            readDouble: function() {
                var t1 = Jh(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8, t1;
            },
            readVarint: function(t1) {
                var e1, r, n = this.buf;
                return e1 = 127 & (r = n[this.pos++]), r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e1 : function(t1, e1, r) {
                    var n, i, s = r.buf;
                    if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return rp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return rp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return rp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return rp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return rp(t1, n, e1);
                    if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return rp(t1, n, e1);
                    throw new Error("Expected varint not more than 10 bytes");
                }(e1 |= (15 & (r = n[this.pos])) << 28, t1, this))));
            },
            readVarint64: function() {
                return this.readVarint(!0);
            },
            readSVarint: function() {
                var t1 = this.readVarint();
                return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
            },
            readBoolean: function() {
                return Boolean(this.readVarint());
            },
            readString: function() {
                var t1 = this.readVarint() + this.pos, e1 = this.pos;
                return this.pos = t1, t1 - e1 >= 12 && tp ? function(t1, e1, r) {
                    return tp.decode(t1.subarray(e1, r));
                }(this.buf, e1, t1) : function(t1, e1, r) {
                    for(var n = "", i = e1; i < r;){
                        var s, a, o, l = t1[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                        if (i + c > r) break;
                        1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t1[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t1[i + 2], 128 == (192 & (s = t1[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t1[i + 2], o = t1[i + 3], 128 == (192 & (s = t1[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
                    }
                    return n;
                }(this.buf, e1, t1);
            },
            readBytes: function() {
                var t1 = this.readVarint() + this.pos, e1 = this.buf.subarray(this.pos, t1);
                return this.pos = t1, e1;
            },
            readPackedVarint: function(t1, e1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readVarint(e1));
                var r = ep(this);
                for(t1 = t1 || []; this.pos < r;)t1.push(this.readVarint(e1));
                return t1;
            },
            readPackedSVarint: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readSVarint());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSVarint());
                return t1;
            },
            readPackedBoolean: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readBoolean());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readBoolean());
                return t1;
            },
            readPackedFloat: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readFloat());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFloat());
                return t1;
            },
            readPackedDouble: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readDouble());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readDouble());
                return t1;
            },
            readPackedFixed32: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readFixed32());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFixed32());
                return t1;
            },
            readPackedSFixed32: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readSFixed32());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSFixed32());
                return t1;
            },
            readPackedFixed64: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readFixed64());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFixed64());
                return t1;
            },
            readPackedSFixed64: function(t1) {
                if (this.type !== Yh.Bytes) return t1.push(this.readSFixed64());
                var e1 = ep(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSFixed64());
                return t1;
            },
            skip: function(t1) {
                var e1 = 7 & t1;
                if (e1 === Yh.Varint) for(; this.buf[this.pos++] > 127;);
                else if (e1 === Yh.Bytes) this.pos = this.readVarint() + this.pos;
                else if (e1 === Yh.Fixed32) this.pos += 4;
                else {
                    if (e1 !== Yh.Fixed64) throw new Error("Unimplemented type: " + e1);
                    this.pos += 8;
                }
            },
            writeTag: function(t1, e1) {
                this.writeVarint(t1 << 3 | e1);
            },
            realloc: function(t1) {
                for(var e1 = this.length || 16; e1 < this.pos + t1;)e1 *= 2;
                if (e1 !== this.length) {
                    var r = new Uint8Array(e1);
                    r.set(this.buf), this.buf = r, this.length = e1;
                }
            },
            finish: function() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            },
            writeFixed32: function(t1) {
                this.realloc(4), fp(this.buf, t1, this.pos), this.pos += 4;
            },
            writeSFixed32: function(t1) {
                this.realloc(4), fp(this.buf, t1, this.pos), this.pos += 4;
            },
            writeFixed64: function(t1) {
                this.realloc(8), fp(this.buf, -1 & t1, this.pos), fp(this.buf, Math.floor(t1 * Qh), this.pos + 4), this.pos += 8;
            },
            writeSFixed64: function(t1) {
                this.realloc(8), fp(this.buf, -1 & t1, this.pos), fp(this.buf, Math.floor(t1 * Qh), this.pos + 4), this.pos += 8;
            },
            writeVarint: function(t1) {
                (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e1) {
                    var r, n;
                    if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (n = ~(-t1 / 4294967296), 4294967295 ^ (r = ~(-t1 % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -18446744073709552000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e1.realloc(10), function(t1, e1, r) {
                        r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                    }(r, 0, e1), function(t1, e1) {
                        var r = (7 & t1) << 4;
                        e1.buf[e1.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1)))));
                    }(n, e1);
                }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
            },
            writeSVarint: function(t1) {
                this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
            },
            writeBoolean: function(t1) {
                this.writeVarint(Boolean(t1));
            },
            writeString: function(t1) {
                t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                var e1 = this.pos;
                this.pos = function(t1, e1, r) {
                    for(var n, i, s = 0; s < e1.length; s++){
                        if ((n = e1.charCodeAt(s)) > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e1.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                continue;
                            }
                            if (n < 56320) {
                                t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                continue;
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                        n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                    }
                    return r;
                }(this.buf, t1, this.pos);
                var r = this.pos - e1;
                r >= 128 && np(e1, r, this), this.pos = e1 - 1, this.writeVarint(r), this.pos += r;
            },
            writeFloat: function(t1) {
                this.realloc(4), Hh(this.buf, t1, this.pos, !0, 23, 4), this.pos += 4;
            },
            writeDouble: function(t1) {
                this.realloc(8), Hh(this.buf, t1, this.pos, !0, 52, 8), this.pos += 8;
            },
            writeBytes: function(t1) {
                var e1 = t1.length;
                this.writeVarint(e1), this.realloc(e1);
                for(var r = 0; r < e1; r++)this.buf[this.pos++] = t1[r];
            },
            writeRawMessage: function(t1, e1) {
                this.pos++;
                var r = this.pos;
                t1(e1, this);
                var n = this.pos - r;
                n >= 128 && np(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            },
            writeMessage: function(t1, e1, r) {
                this.writeTag(t1, Yh.Bytes), this.writeRawMessage(e1, r);
            },
            writePackedVarint: function(t1, e1) {
                e1.length && this.writeMessage(t1, ip, e1);
            },
            writePackedSVarint: function(t1, e1) {
                e1.length && this.writeMessage(t1, sp, e1);
            },
            writePackedBoolean: function(t1, e1) {
                e1.length && this.writeMessage(t1, lp, e1);
            },
            writePackedFloat: function(t1, e1) {
                e1.length && this.writeMessage(t1, ap, e1);
            },
            writePackedDouble: function(t1, e1) {
                e1.length && this.writeMessage(t1, op, e1);
            },
            writePackedFixed32: function(t1, e1) {
                e1.length && this.writeMessage(t1, up, e1);
            },
            writePackedSFixed32: function(t1, e1) {
                e1.length && this.writeMessage(t1, cp, e1);
            },
            writePackedFixed64: function(t1, e1) {
                e1.length && this.writeMessage(t1, hp, e1);
            },
            writePackedSFixed64: function(t1, e1) {
                e1.length && this.writeMessage(t1, pp, e1);
            },
            writeBytesField: function(t1, e1) {
                this.writeTag(t1, Yh.Bytes), this.writeBytes(e1);
            },
            writeFixed32Field: function(t1, e1) {
                this.writeTag(t1, Yh.Fixed32), this.writeFixed32(e1);
            },
            writeSFixed32Field: function(t1, e1) {
                this.writeTag(t1, Yh.Fixed32), this.writeSFixed32(e1);
            },
            writeFixed64Field: function(t1, e1) {
                this.writeTag(t1, Yh.Fixed64), this.writeFixed64(e1);
            },
            writeSFixed64Field: function(t1, e1) {
                this.writeTag(t1, Yh.Fixed64), this.writeSFixed64(e1);
            },
            writeVarintField: function(t1, e1) {
                this.writeTag(t1, Yh.Varint), this.writeVarint(e1);
            },
            writeSVarintField: function(t1, e1) {
                this.writeTag(t1, Yh.Varint), this.writeSVarint(e1);
            },
            writeStringField: function(t1, e1) {
                this.writeTag(t1, Yh.Bytes), this.writeString(e1);
            },
            writeFloatField: function(t1, e1) {
                this.writeTag(t1, Yh.Fixed32), this.writeFloat(e1);
            },
            writeDoubleField: function(t1, e1) {
                this.writeTag(t1, Yh.Fixed64), this.writeDouble(e1);
            },
            writeBooleanField: function(t1, e1) {
                this.writeVarintField(t1, Boolean(e1));
            }
        };
        var mp = p(Xh);
        const gp = 3;
        function xp(t1, e1, r) {
            e1.glyphs = [], 1 === t1 && r.readMessage(vp, e1);
        }
        function vp(t1, e1, r) {
            if (3 === t1) {
                const { id: t1, bitmap: n, width: i, height: s, left: a, top: o, advance: l } = r.readMessage(bp, {});
                e1.glyphs.push({
                    id: t1,
                    bitmap: new Ru({
                        width: i + 2 * gp,
                        height: s + 2 * gp
                    }, n),
                    metrics: {
                        width: i,
                        height: s,
                        left: a,
                        top: o,
                        advance: l
                    }
                });
            } else 4 === t1 ? e1.ascender = r.readSVarint() : 5 === t1 && (e1.descender = r.readSVarint());
        }
        function bp(t1, e1, r) {
            1 === t1 ? e1.id = r.readVarint() : 2 === t1 ? e1.bitmap = r.readBytes() : 3 === t1 ? e1.width = r.readVarint() : 4 === t1 ? e1.height = r.readVarint() : 5 === t1 ? e1.left = r.readSVarint() : 6 === t1 ? e1.top = r.readSVarint() : 7 === t1 && (e1.advance = r.readVarint());
        }
        const wp = gp;
        function _p(t1) {
            let e1 = 0, r = 0;
            for (const n of t1)e1 += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e1)=>e1.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e1 / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, s = 0;
            for (const e1 of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e1.w > r.w || e1.h > r.h)) {
                    if (e1.x = r.x, e1.y = r.y, s = Math.max(s, e1.y + e1.h), i = Math.max(i, e1.x + e1.w), e1.w === r.w && e1.h === r.h) {
                        const e1 = n.pop();
                        t1 < n.length && (n[t1] = e1);
                    } else e1.h === r.h ? (r.x += e1.w, r.w -= e1.w) : e1.w === r.w ? (r.y += e1.h, r.h -= e1.h) : (n.push({
                        x: r.x + e1.w,
                        y: r.y,
                        w: r.w - e1.w,
                        h: e1.h
                    }), r.y += e1.h, r.h -= e1.h);
                    break;
                }
            }
            return {
                w: i,
                h: s,
                fill: e1 / (i * s) || 0
            };
        }
        const Ap = 1;
        class Sp {
            constructor(t1, { pixelRatio: e1, version: r, stretchX: n, stretchY: i, content: s }){
                this.paddedRect = t1, this.pixelRatio = e1, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;
            }
            get tl() {
                return [
                    this.paddedRect.x + Ap,
                    this.paddedRect.y + Ap
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - Ap,
                    this.paddedRect.y + this.paddedRect.h - Ap
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2 * Ap) / this.pixelRatio,
                    (this.paddedRect.h - 2 * Ap) / this.pixelRatio
                ];
            }
        }
        class kp {
            constructor(t1, e1){
                const r = {}, n = {};
                this.haveRenderCallbacks = [];
                const i = [];
                this.addImages(t1, r, i), this.addImages(e1, n, i);
                const { w: s, h: a } = _p(i), o = new Uu({
                    width: s || 1,
                    height: a || 1
                });
                for(const e1 in t1){
                    const n = t1[e1], i = r[e1].paddedRect;
                    Uu.copy(n.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: i.x + Ap,
                        y: i.y + Ap
                    }, n.data);
                }
                for(const t1 in e1){
                    const r = e1[t1], i = n[t1].paddedRect, s = i.x + Ap, a = i.y + Ap, l = r.data.width, u = r.data.height;
                    Uu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s,
                        y: a
                    }, r.data), Uu.copy(r.data, o, {
                        x: 0,
                        y: u - 1
                    }, {
                        x: s,
                        y: a - 1
                    }, {
                        width: l,
                        height: 1
                    }), Uu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s,
                        y: a + u
                    }, {
                        width: l,
                        height: 1
                    }), Uu.copy(r.data, o, {
                        x: l - 1,
                        y: 0
                    }, {
                        x: s - 1,
                        y: a
                    }, {
                        width: 1,
                        height: u
                    }), Uu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s + l,
                        y: a
                    }, {
                        width: 1,
                        height: u
                    });
                }
                this.image = o, this.iconPositions = r, this.patternPositions = n;
            }
            addImages(t1, e1, r) {
                for(const n in t1){
                    const i = t1[n], s = {
                        x: 0,
                        y: 0,
                        w: i.data.width + 2 * Ap,
                        h: i.data.height + 2 * Ap
                    };
                    r.push(s), e1[n] = new Sp(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
                }
            }
            patchUpdatedImages(t1, e1) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e1)=>t1.hasImage(e1)), t1.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for(const r in t1.updatedImages)this.patchUpdatedImage(this.iconPositions[r], t1.getImage(r), e1), this.patchUpdatedImage(this.patternPositions[r], t1.getImage(r), e1);
            }
            patchUpdatedImage(t1, e1, r) {
                if (!t1 || !e1) return;
                if (t1.version === e1.version) return;
                t1.version = e1.version;
                const [n, i] = t1.tl;
                r.update(e1.data, void 0, {
                    x: n,
                    y: i
                });
            }
        }
        Ji(Sp, "ImagePosition"), Ji(kp, "ImageAtlas");
        const Ip = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        }, Mp = -17;
        class Tp {
            constructor(){
                this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t1, e1) {
                const r = new Tp;
                return r.scale = t1 || 1, r.fontStack = e1, r;
            }
            static forImage(t1) {
                const e1 = new Tp;
                return e1.imageName = t1, e1;
            }
        }
        class zp {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e1) {
                const r = new zp;
                for(let n = 0; n < t1.sections.length; n++){
                    const i = t1.sections[n];
                    i.image ? r.addImageSection(i) : r.addTextSection(i, e1);
                }
                return r;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCharCode(t1) {
                return this.text.charCodeAt(t1);
            }
            verticalizePunctuation(t1) {
                this.text = function(t1, e1) {
                    let r = "";
                    for(let n = 0; n < t1.length; n++){
                        const i = t1.charCodeAt(n + 1) || null, s = t1.charCodeAt(n - 1) || null;
                        r += !e1 && (i && ss(i) && !Gh[t1[n + 1]] || s && ss(s) && !Gh[t1[n - 1]]) || !Gh[t1[n]] ? t1[n] : Gh[t1[n]];
                    }
                    return r;
                }(this.text, t1);
            }
            trim() {
                let t1 = 0;
                for(let e1 = 0; e1 < this.text.length && Ep[this.text.charCodeAt(e1)]; e1++)t1++;
                let e1 = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && Ep[this.text.charCodeAt(r)]; r--)e1--;
                this.text = this.text.substring(t1, e1), this.sectionIndex = this.sectionIndex.slice(t1, e1);
            }
            substring(t1, e1) {
                const r = new zp;
                return r.text = this.text.substring(t1, e1), r.sectionIndex = this.sectionIndex.slice(t1, e1), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e1)=>Math.max(t1, this.sections[e1].scale), 0);
            }
            addTextSection(t1, e1) {
                this.text += t1.text, this.sections.push(Tp.forText(t1.scale, t1.fontStack || e1));
                const r = this.sections.length - 1;
                for(let e1 = 0; e1 < t1.text.length; ++e1)this.sectionIndex.push(r);
            }
            addImageSection(t1) {
                const e1 = t1.image ? t1.image.name : "";
                if (0 === e1.length) return void N("Can't add FormattedSection with an empty image.");
                const r = this.getNextImageSectionCharCode();
                r ? (this.text += String.fromCharCode(r), this.sections.push(Tp.forImage(e1)), this.sectionIndex.push(this.sections.length - 1)) : N("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function Bp(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f) {
            const y = zp.fromFeature(t1, i);
            h === Ip.vertical && y.verticalizePunctuation(p);
            let m = [];
            const g = function(t1, e1, r, n, i, s) {
                if (!t1) return [];
                const a = [], o = function(t1, e1, r, n, i, s) {
                    let a = 0;
                    for(let r = 0; r < t1.length(); r++){
                        const o = t1.getSection(r);
                        a += Pp(t1.getCharCode(r), o, n, i, e1, s);
                    }
                    return a / Math.max(1, Math.ceil(a / r));
                }(t1, e1, r, n, i, s), l = t1.text.indexOf("\u200B") >= 0;
                let u = 0;
                for(let r = 0; r < t1.length(); r++){
                    const h = t1.getSection(r), p = t1.getCharCode(r);
                    if (Ep[p] || (u += Pp(p, h, n, i, e1, s)), r < t1.length() - 1) {
                        const e1 = !((c = p) < 11904 || !(ts["Bopomofo Extended"](c) || ts.Bopomofo(c) || ts["CJK Compatibility Forms"](c) || ts["CJK Compatibility Ideographs"](c) || ts["CJK Compatibility"](c) || ts["CJK Radicals Supplement"](c) || ts["CJK Strokes"](c) || ts["CJK Symbols and Punctuation"](c) || ts["CJK Unified Ideographs Extension A"](c) || ts["CJK Unified Ideographs"](c) || ts["Enclosed CJK Letters and Months"](c) || ts["Halfwidth and Fullwidth Forms"](c) || ts.Hiragana(c) || ts["Ideographic Description Characters"](c) || ts["Kangxi Radicals"](c) || ts["Katakana Phonetic Extensions"](c) || ts.Katakana(c) || ts["Vertical Forms"](c) || ts["Yi Radicals"](c) || ts["Yi Syllables"](c)));
                        (Cp[p] || e1 || h.imageName) && a.push(Lp(r + 1, u, o, a, Vp(p, t1.getCharCode(r + 1), e1 && l), !1));
                    }
                }
                var c;
                return Fp(Lp(t1.length(), u, o, a, 0, !0));
            }(y, u, s, e1, n, d), { processBidirectionalText: x, processStyledBidirectionalText: v } = bs;
            if (x && 1 === y.sections.length) {
                const t1 = x(y.toString(), g);
                for (const e1 of t1){
                    const t1 = new zp;
                    t1.text = e1, t1.sections = y.sections;
                    for(let r = 0; r < e1.length; r++)t1.sectionIndex.push(0);
                    m.push(t1);
                }
            } else if (v) {
                const t1 = v(y.text, y.sectionIndex, g);
                for (const e1 of t1){
                    const t1 = new zp;
                    t1.text = e1[0], t1.sectionIndex = e1[1], t1.sections = y.sections, m.push(t1);
                }
            } else m = function(t1, e1) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e1)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(y, g);
            const b = [], w = {
                positionedLines: b,
                text: y.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return function(t1, e1, r, n, i, s, a, o, l, u, c, h) {
                let p = 0, d = 0, f = 0;
                const y = "right" === o ? 1 : "left" === o ? 0 : .5;
                let m = !1;
                for (const t1 of i){
                    const r = t1.getSections();
                    for (const t1 of r){
                        if (t1.imageName) continue;
                        const r = e1[t1.fontStack];
                        if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;
                    }
                    if (!m) break;
                }
                let g = 0;
                for (const a of i){
                    a.trim();
                    const i = a.getMaxScale(), o = (i - 1) * Rh, v = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t1.positionedLines[g] = v;
                    const b = v.positionedGlyphs;
                    let w = 0;
                    if (!a.length()) {
                        d += s, ++g;
                        continue;
                    }
                    let _ = 0, A = 0;
                    for(let s = 0; s < a.length(); s++){
                        const o = a.getSection(s), f = a.getSectionIndex(s), y = a.getCharCode(s);
                        let g = o.scale, v = null, S = null, k = null, I = Rh, M = 0;
                        const T = !(l === Ip.horizontal || !c && !is(y) || c && (Ep[y] || (x = y, ts.Arabic(x) || ts["Arabic Supplement"](x) || ts["Arabic Extended-A"](x) || ts["Arabic Presentation Forms-A"](x) || ts["Arabic Presentation Forms-B"](x))));
                        if (o.imageName) {
                            const e1 = n[o.imageName];
                            if (!e1) continue;
                            k = o.imageName, t1.iconsInText = t1.iconsInText || !0, S = e1.paddedRect;
                            const r = e1.displaySize;
                            g = g * Rh / h, v = {
                                width: r[0],
                                height: r[1],
                                left: Ap,
                                top: -wp,
                                advance: T ? r[1] : r[0],
                                localGlyph: !1
                            }, M = m ? -v.height * g : Mp + i * Rh - r[1] * g, I = v.advance;
                            const s = (T ? r[0] : r[1]) * g - Rh * i;
                            s > 0 && s > w && (w = s);
                        } else {
                            const t1 = r[o.fontStack];
                            if (!t1) continue;
                            t1[y] && (S = t1[y]);
                            const n = e1[o.fontStack];
                            if (!n) continue;
                            const s = n.glyphs[y];
                            if (!s) continue;
                            if (v = s.metrics, I = 8203 !== y ? Rh : 0, m) {
                                const t1 = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, e1 = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (t1 + e1) * g;
                                _ < r && (_ = r, A = (t1 - e1) / 2 * g), M = -t1 * g;
                            } else M = Mp + (i - g) * Rh;
                        }
                        T ? (t1.verticalizable = !0, b.push({
                            glyph: y,
                            imageName: k,
                            x: p,
                            y: d + M,
                            vertical: T,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: f,
                            metrics: v,
                            rect: S
                        }), p += I * g + u) : (b.push({
                            glyph: y,
                            imageName: k,
                            x: p,
                            y: d + M,
                            vertical: T,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: f,
                            metrics: v,
                            rect: S
                        }), p += v.advance * g + u);
                    }
                    0 !== b.length && (f = Math.max(p - u, f), m ? Up(b, y, w, A, s * i / 2) : Up(b, y, w, 0, s / 2)), p = 0;
                    const S = s * i + w;
                    v.lineOffset = Math.max(w, o), d += S, ++g;
                }
                var x;
                const v = d, { horizontalAlign: b, verticalAlign: w } = Rp(a);
                (function(t1, e1, r, n, i, s) {
                    const a = (e1 - r) * i, o = -s * n;
                    for (const e1 of t1)for (const t1 of e1.positionedGlyphs)t1.x += a, t1.y += o;
                })(t1.positionedLines, y, b, w, f, v), t1.top += -w * v, t1.bottom = t1.top + v, t1.left += -b * f, t1.right = t1.left + f, t1.hasBaseline = m;
            }(w, e1, r, n, m, a, o, l, h, u, p, f), !function(t1) {
                for (const e1 of t1)if (0 !== e1.positionedGlyphs.length) return !1;
                return !0;
            }(b) && w;
        }
        const Ep = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, Cp = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function Pp(t1, e1, r, n, i, s) {
            if (e1.imageName) {
                const t1 = n[e1.imageName];
                return t1 ? t1.displaySize[0] * e1.scale * Rh / s + i : 0;
            }
            {
                const n = r[e1.fontStack], s = n && n.glyphs[t1];
                return s ? s.metrics.advance * e1.scale + i : 0;
            }
        }
        function Dp(t1, e1, r, n) {
            const i = Math.pow(t1 - e1, 2);
            return n ? t1 < e1 ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function Vp(t1, e1, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e1 && 65289 !== e1 || (n += 50), n;
        }
        function Lp(t1, e1, r, n, i, s) {
            let a = null, o = Dp(e1, r, i, s);
            for (const t1 of n){
                const n = Dp(e1 - t1.x, r, i, s) + t1.badness;
                n <= o && (a = t1, o = n);
            }
            return {
                index: t1,
                x: e1,
                priorBreak: a,
                badness: o
            };
        }
        function Fp(t1) {
            return t1 ? Fp(t1.priorBreak).concat(t1.index) : [];
        }
        function Rp(t1) {
            let e1 = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e1 = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e1 = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e1,
                verticalAlign: r
            };
        }
        function Up(t1, e1, r, n, i) {
            if (!(e1 || r || n || i)) return;
            const s = t1.length - 1, a = t1[s], o = (a.x + a.metrics.advance * a.scale) * e1;
            for(let e1 = 0; e1 <= s; e1++)t1[e1].x -= o, t1[e1].y += r + n + i;
        }
        function $p(t1, e1, r) {
            const { horizontalAlign: n, verticalAlign: i } = Rp(r), s = e1[0] - t1.displaySize[0] * n, a = e1[1] - t1.displaySize[1] * i;
            return {
                image: t1,
                top: a,
                bottom: a + t1.displaySize[1],
                left: s,
                right: s + t1.displaySize[0]
            };
        }
        function jp(t1, e1, r, n, i, s) {
            const a = t1.image;
            let o;
            if (a.content) {
                const t1 = a.content, e1 = a.pixelRatio || 1;
                o = [
                    t1[0] / e1,
                    t1[1] / e1,
                    a.displaySize[0] - t1[2] / e1,
                    a.displaySize[1] - t1[3] / e1
                ];
            }
            const l = e1.left * s, u = e1.right * s;
            let c, h, p, d;
            "width" === r || "both" === r ? (d = i[0] + l - n[3], h = i[0] + u + n[1]) : (d = i[0] + (l + u - a.displaySize[0]) / 2, h = d + a.displaySize[0]);
            const f = e1.top * s, y = e1.bottom * s;
            return "height" === r || "both" === r ? (c = i[1] + f - n[0], p = i[1] + y + n[2]) : (c = i[1] + (f + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {
                image: a,
                top: c,
                right: h,
                bottom: p,
                left: d,
                collisionPadding: o
            };
        }
        class Op extends x {
            constructor(t1, e1, r, n, i){
                super(t1, e1), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }
            clone() {
                return new Op(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function qp(t1, e1, r, n, i) {
            if (void 0 === e1.segment) return !0;
            let s = e1, a = e1.segment + 1, o = 0;
            for(; o > -r / 2;){
                if (a--, a < 0) return !1;
                o -= t1[a].dist(s), s = t1[a];
            }
            o += t1[a].dist(t1[a + 1]), a++;
            const l = [];
            let u = 0;
            for(; o < r / 2;){
                const e1 = t1[a], r = t1[a + 1];
                if (!r) return !1;
                let s = t1[a - 1].angleTo(e1) - e1.angleTo(r);
                for(s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: o,
                    angleDelta: s
                }), u += s; o - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                a++, o += e1.dist(r);
            }
            return !0;
        }
        function Np(t1) {
            let e1 = 0;
            for(let r = 0; r < t1.length - 1; r++)e1 += t1[r].dist(t1[r + 1]);
            return e1;
        }
        function Gp(t1, e1, r) {
            return t1 ? .6 * e1 * r : 0;
        }
        function Zp(t1, e1) {
            return Math.max(t1 ? t1.right - t1.left : 0, e1 ? e1.right - e1.left : 0);
        }
        function Kp(t1, e1, r, n, i, s) {
            const a = Gp(r, i, s), o = Zp(r, n) * s;
            let l = 0;
            const u = Np(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], s = n.dist(i);
                if (l + s > u) {
                    const c = (u - l) / s, h = Er(n.x, i.x, c), p = Er(n.y, i.y, c), d = new Op(h, p, 0, i.angleTo(n), r);
                    return !a || qp(t1, d, o, a, e1) ? d : void 0;
                }
                l += s;
            }
        }
        function Xp(t1, e1, r, n, i, s, a, o, l) {
            const u = Gp(n, s, a), c = Zp(n, i), h = c * a, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e1 - h < e1 / 4 && (e1 = h + e1 / 4), Jp(t1, p ? e1 / 2 * o % e1 : (c / 2 + 2 * s) * a * o % e1, e1, u, r, h, p, !1, l);
        }
        function Jp(t1, e1, r, n, i, s, a, o, l) {
            const u = s / 2, c = Np(t1);
            let h = 0, p = e1 - r, d = [];
            for(let e1 = 0; e1 < t1.length - 1; e1++){
                const a = t1[e1], o = t1[e1 + 1], f = a.dist(o), y = o.angleTo(a);
                for(; p + r < h + f;){
                    p += r;
                    const m = (p - h) / f, g = Er(a.x, o.x, m), x = Er(a.y, o.y, m);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new Op(g, x, 0, y, e1);
                        r._round(), n && !qp(t1, r, s, n, i) || d.push(r);
                    }
                }
                h += f;
            }
            return o || d.length || a || (d = Jp(t1, h / 2, r, n, i, s, a, !0, l)), d;
        }
        function Hp(t1, e1, r, n, i) {
            const s = [];
            for(let a = 0; a < t1.length; a++){
                const o = t1[a];
                let l;
                for(let t1 = 0; t1 < o.length - 1; t1++){
                    let a = o[t1], u = o[t1 + 1];
                    a.x < e1 && u.x < e1 || (a.x < e1 ? a = new x(e1, a.y + (e1 - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e1 && (u = new x(e1, a.y + (e1 - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new x(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new x(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new x(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new x(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new x(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new x(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [
                        a
                    ], s.push(l)), l.push(u)))));
                }
            }
            return s;
        }
        Ji(Op, "Anchor");
        const Yp = 1e20;
        function Wp(t1, e1, r, n, i, s, a, o, l) {
            for(let u = e1; u < e1 + n; u++)Qp(t1, r * s + u, s, i, a, o, l);
            for(let u = r; u < r + i; u++)Qp(t1, u * s + e1, 1, n, a, o, l);
        }
        function Qp(t1, e1, r, n, i, s, a) {
            s[0] = 0, a[0] = -Yp, a[1] = Yp, i[0] = t1[e1];
            for(let o = 1, l = 0, u = 0; o < n; o++){
                i[o] = t1[e1 + o * r];
                const n = o * o;
                do {
                    const t1 = s[l];
                    u = (i[o] - i[t1] + n - t1 * t1) / (o - t1) / 2;
                }while (u <= a[l] && --l > -1);
                l++, s[l] = o, a[l] = u, a[l + 1] = Yp;
            }
            for(let o = 0, l = 0; o < n; o++){
                for(; a[l + 1] < o;)l++;
                const n = s[l], u = o - n;
                t1[e1 + o * r] = i[n] + u * u;
            }
        }
        const td = 2, ed = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class rd {
            constructor(t1, e1, r){
                this.requestManager = t1, this.localGlyphMode = e1, this.localFontFamily = r, this.entries = {}, this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t1) {
                this.url = t1;
            }
            getGlyphs(t1, e1) {
                const r = [];
                for(const e1 in t1)for (const n of t1[e1])r.push({
                    stack: e1,
                    id: n
                });
                B(r, ({ stack: t1, id: e1 }, r)=>{
                    let n = this.entries[t1];
                    n || (n = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let i = n.glyphs[e1];
                    if (void 0 !== i) return void r(null, {
                        stack: t1,
                        id: e1,
                        glyph: i
                    });
                    if (i = this._tinySDF(n, t1, e1), i) return n.glyphs[e1] = i, void r(null, {
                        stack: t1,
                        id: e1,
                        glyph: i
                    });
                    const s = Math.floor(e1 / 256);
                    if (256 * s > 65535) return void r(new Error("glyphs > 65535 not supported"));
                    if (n.ranges[s]) return void r(null, {
                        stack: t1,
                        id: e1,
                        glyph: i
                    });
                    let a = n.requests[s];
                    a || (a = n.requests[s] = [], rd.loadGlyphRange(t1, s, this.url, this.requestManager, (t1, e1)=>{
                        if (e1) {
                            n.ascender = e1.ascender, n.descender = e1.descender;
                            for(const t1 in e1.glyphs)this._doesCharSupportLocalGlyph(+t1) || (n.glyphs[+t1] = e1.glyphs[+t1]);
                            n.ranges[s] = !0;
                        }
                        for (const r of a)r(t1, e1);
                        delete n.requests[s];
                    })), a.push((n, i)=>{
                        n ? r(n) : i && r(null, {
                            stack: t1,
                            id: e1,
                            glyph: i.glyphs[e1] || null
                        });
                    });
                }, (t1, r)=>{
                    if (t1) e1(t1);
                    else if (r) {
                        const t1 = {};
                        for (const { stack: e1, id: n, glyph: i } of r)void 0 === t1[e1] && (t1[e1] = {}), void 0 === t1[e1].glyphs && (t1[e1].glyphs = {}), t1[e1].glyphs[n] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics
                        }, t1[e1].ascender = this.entries[e1].ascender, t1[e1].descender = this.entries[e1].descender;
                        e1(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t1) {
                return this.localGlyphMode !== ed.none && (this.localGlyphMode === ed.all ? !!this.localFontFamily : !!this.localFontFamily && (ts["CJK Unified Ideographs"](t1) || ts["Hangul Syllables"](t1) || ts.Hiragana(t1) || ts.Katakana(t1) || ts["CJK Symbols and Punctuation"](t1)));
            }
            _tinySDF(t1, e1, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r)) return;
                let i = t1.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e1) ? r = "900" : /medium/i.test(e1) ? r = "500" : /light/i.test(e1) && (r = "200"), i = t1.tinySDF = new rd.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 24 * td,
                        buffer: 3 * td,
                        radius: 8 * td
                    }), i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
                const s = String.fromCharCode(r), { data: a, width: o, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: d } = i.draw(s);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new Ru({
                        width: o,
                        height: l
                    }, a),
                    metrics: {
                        width: u / td,
                        height: c / td,
                        left: h / td,
                        top: p / td - 27,
                        advance: d / td,
                        localGlyph: !0
                    }
                };
            }
        }
        rd.loadGlyphRange = function(t1, e1, r, n, i) {
            const s = 256 * e1, a = s + 255, o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t1).replace("{range}", `${s}-${a}`), lt.Glyphs);
            pt(o, (t1, e1)=>{
                if (t1) i(t1);
                else if (e1) {
                    const t1 = {}, r = function(t1) {
                        return new mp(t1).readFields(xp, {});
                    }(e1);
                    for (const e1 of r.glyphs)t1[e1.id] = e1;
                    i(null, {
                        glyphs: t1,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            });
        }, rd.TinySDF = class {
            constructor({ fontSize: t1 = 24, buffer: e1 = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: s = "normal", fontStyle: a = "normal" } = {}){
                this.buffer = e1, this.cutoff = n, this.radius = r;
                const o = this.size = t1 + 4 * e1, l = this._createCanvas(o), u = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                u.font = `${a} ${s} ${t1}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
            }
            _createCanvas(t1) {
                const e1 = document.createElement("canvas");
                return e1.width = e1.height = t1, e1;
            }
            draw(t1) {
                const { width: e1, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: s } = this.ctx.measureText(t1), a = Math.ceil(r), o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))), l = Math.min(this.size - this.buffer, a + Math.ceil(n)), u = o + 2 * this.buffer, c = l + 2 * this.buffer, h = Math.max(u * c, 0), p = new Uint8ClampedArray(h), d = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: o,
                    glyphHeight: l,
                    glyphTop: a,
                    glyphLeft: 0,
                    glyphAdvance: e1
                };
                if (0 === o || 0 === l) return d;
                const { ctx: f, buffer: y, gridInner: m, gridOuter: g } = this;
                f.clearRect(y, y, o, l), f.fillText(t1, y, y + a);
                const x = f.getImageData(y, y, o, l);
                g.fill(Yp, 0, h), m.fill(0, 0, h);
                for(let t1 = 0; t1 < l; t1++)for(let e1 = 0; e1 < o; e1++){
                    const r = x.data[4 * (t1 * o + e1) + 3] / 255;
                    if (0 === r) continue;
                    const n = (t1 + y) * u + e1 + y;
                    if (1 === r) g[n] = 0, m[n] = Yp;
                    else {
                        const t1 = .5 - r;
                        g[n] = t1 > 0 ? t1 * t1 : 0, m[n] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                Wp(g, 0, 0, u, c, u, this.f, this.v, this.z), Wp(m, y, y, o, l, u, this.f, this.v, this.z);
                for(let t1 = 0; t1 < h; t1++){
                    const e1 = Math.sqrt(g[t1]) - Math.sqrt(m[t1]);
                    p[t1] = Math.round(255 - 255 * (e1 / this.radius + this.cutoff));
                }
                return d;
            }
        };
        const nd = Ap;
        function id(t1, e1, r, n) {
            const i = [], s = t1.image, a = s.pixelRatio, o = s.paddedRect.w - 2 * nd, l = s.paddedRect.h - 2 * nd, u = t1.right - t1.left, c = t1.bottom - t1.top, h = s.stretchX || [
                [
                    0,
                    o
                ]
            ], p = s.stretchY || [
                [
                    0,
                    l
                ]
            ], d = (t1, e1)=>t1 + e1[1] - e1[0], f = h.reduce(d, 0), y = p.reduce(d, 0), m = o - f, g = l - y;
            let v = 0, b = f, w = 0, _ = y, A = 0, S = m, k = 0, I = g;
            if (s.content && n) {
                const t1 = s.content;
                v = sd(h, 0, t1[0]), w = sd(p, 0, t1[1]), b = sd(h, t1[0], t1[2]), _ = sd(p, t1[1], t1[3]), A = t1[0] - v, k = t1[1] - w, S = t1[2] - t1[0] - b, I = t1[3] - t1[1] - _;
            }
            const M = (n, i, o, l)=>{
                const h = od(n.stretch - v, b, u, t1.left), p = ld(n.fixed - A, S, n.stretch, f), d = od(i.stretch - w, _, c, t1.top), m = ld(i.fixed - k, I, i.stretch, y), g = od(o.stretch - v, b, u, t1.left), M = ld(o.fixed - A, S, o.stretch, f), T = od(l.stretch - w, _, c, t1.top), z = ld(l.fixed - k, I, l.stretch, y), B = new x(h, d), E = new x(g, d), C = new x(g, T), P = new x(h, T), D = new x(p / a, m / a), V = new x(M / a, z / a), L = e1 * Math.PI / 180;
                if (L) {
                    const t1 = Math.sin(L), e1 = Math.cos(L), r = [
                        e1,
                        -t1,
                        t1,
                        e1
                    ];
                    B._matMult(r), E._matMult(r), P._matMult(r), C._matMult(r);
                }
                const F = n.stretch + n.fixed, R = i.stretch + i.fixed;
                return {
                    tl: B,
                    tr: E,
                    bl: P,
                    br: C,
                    tex: {
                        x: s.paddedRect.x + nd + F,
                        y: s.paddedRect.y + nd + R,
                        w: o.stretch + o.fixed - F,
                        h: l.stretch + l.fixed - R
                    },
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: D,
                    pixelOffsetBR: V,
                    minFontScaleX: S / a / u,
                    minFontScaleY: I / a / c,
                    isSDF: r
                };
            };
            if (n && (s.stretchX || s.stretchY)) {
                const t1 = ad(h, m, f), e1 = ad(p, g, y);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], s = t1[r + 1];
                    for(let t1 = 0; t1 < e1.length - 1; t1++)i.push(M(n, e1[t1], s, e1[t1 + 1]));
                }
            } else i.push(M({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: o + 1
            }, {
                fixed: 0,
                stretch: l + 1
            }));
            return i;
        }
        function sd(t1, e1, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e1, Math.min(r, i[1])) - Math.max(e1, Math.min(r, i[0]));
            return n;
        }
        function ad(t1, e1, r) {
            const n = [
                {
                    fixed: -nd,
                    stretch: 0
                }
            ];
            for (const [e1, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e1 - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e1 - t1.stretch,
                    stretch: t1.stretch + (r - e1)
                });
            }
            return n.push({
                fixed: e1 + nd,
                stretch: r
            }), n;
        }
        function od(t1, e1, r, n) {
            return t1 / e1 * r + n;
        }
        function ld(t1, e1, r, n) {
            return t1 - e1 * r / n;
        }
        function ud(t1, e1, r, n) {
            const i = e1 + t1.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e1 + t1.positionedLines[n - 1].lineOffset)) / 2;
        }
        class cd {
            constructor(t1 = [], e1 = hd){
                if (this.data = t1, this.length = this.data.length, this.compare = e1, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this.length++, this._up(this.length - 1);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e1 = this.data.pop();
                return this.length--, this.length > 0 && (this.data[0] = e1, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e1, compare: r } = this, n = e1[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, s = e1[i];
                    if (r(n, s) >= 0) break;
                    e1[t1] = s, t1 = i;
                }
                e1[t1] = n;
            }
            _down(t1) {
                const { data: e1, compare: r } = this, n = this.length >> 1, i = e1[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1), s = e1[n];
                    const a = n + 1;
                    if (a < this.length && r(e1[a], s) < 0 && (n = a, s = e1[a]), r(s, i) >= 0) break;
                    e1[t1] = s, t1 = n;
                }
                e1[t1] = i;
            }
        }
        function hd(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function pd(t1, e1 = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0;
            const o = t1[0];
            for(let t1 = 0; t1 < o.length; t1++){
                const e1 = o[t1];
                (!t1 || e1.x < n) && (n = e1.x), (!t1 || e1.y < i) && (i = e1.y), (!t1 || e1.x > s) && (s = e1.x), (!t1 || e1.y > a) && (a = e1.y);
            }
            const l = Math.min(s - n, a - i);
            let u = l / 2;
            const c = new cd([], dd);
            if (0 === l) return new x(n, i);
            for(let e1 = n; e1 < s; e1 += l)for(let r = i; r < a; r += l)c.push(new fd(e1 + u, r + u, u, t1));
            let h = function(t1) {
                let e1 = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, s = i.length, a = s - 1; t1 < s; a = t1++){
                    const s = i[t1], o = i[a], l = s.x * o.y - o.x * s.y;
                    r += (s.x + o.x) * l, n += (s.y + o.y) * l, e1 += 3 * l;
                }
                return new fd(r / e1, n / e1, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e1 || (u = n.h / 2, c.push(new fd(n.p.x - u, n.p.y - u, u, t1)), c.push(new fd(n.p.x + u, n.p.y - u, u, t1)), c.push(new fd(n.p.x - u, n.p.y + u, u, t1)), c.push(new fd(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function dd(t1, e1) {
            return e1.max - t1.max;
        }
        class fd {
            constructor(t1, e1, r, n){
                this.p = new x(t1, e1), this.h = r, this.d = function(t1, e1) {
                    let r = !1, n = 1 / 0;
                    for(let i = 0; i < e1.length; i++){
                        const s = e1[i];
                        for(let e1 = 0, i = s.length, a = i - 1; e1 < i; a = e1++){
                            const i = s[e1], o = s[a];
                            i.y > t1.y != o.y > t1.y && t1.x < (o.x - i.x) * (t1.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, xu(t1, i, o));
                        }
                    }
                    return (r ? 1 : -1) * Math.sqrt(n);
                }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
            }
        }
        const yd = 7, md = Number.POSITIVE_INFINITY, gd = Math.sqrt(2);
        function xd(t1, [e1, r]) {
            let n = 0, i = 0;
            if (r === md) {
                e1 < 0 && (e1 = 0);
                const r = e1 / gd;
                switch(t1){
                    case "top-right":
                    case "top-left":
                        i = r - yd;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i = -r + yd;
                        break;
                    case "bottom":
                        i = -e1 + yd;
                        break;
                    case "top":
                        i = e1 - yd;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        n = -r;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n = r;
                        break;
                    case "left":
                        n = e1;
                        break;
                    case "right":
                        n = -e1;
                }
            } else {
                switch(e1 = Math.abs(e1), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - yd;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = -r + yd;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e1;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e1;
                }
            }
            return [
                n,
                i
            ];
        }
        function vd(t1, e1, r, n, i, s, a, o, l, u) {
            t1.createArrays(), t1.tilePixelRatio = ao / (512 * t1.overscaling), t1.compareText = {}, t1.iconsNeedLinear = !1;
            const c = t1.layers[0].layout, h = t1.layers[0]._unevaluatedLayout._values, p = {};
            if ("composite" === t1.textSizeData.kind) {
                const { minZoom: e1, maxZoom: r } = t1.textSizeData;
                p.compositeTextSizes = [
                    h["text-size"].possiblyEvaluate(new ws(e1), o),
                    h["text-size"].possiblyEvaluate(new ws(r), o)
                ];
            }
            if ("composite" === t1.iconSizeData.kind) {
                const { minZoom: e1, maxZoom: r } = t1.iconSizeData;
                p.compositeIconSizes = [
                    h["icon-size"].possiblyEvaluate(new ws(e1), o),
                    h["icon-size"].possiblyEvaluate(new ws(r), o)
                ];
            }
            p.layoutTextSize = h["text-size"].possiblyEvaluate(new ws(l + 1), o), p.layoutIconSize = h["icon-size"].possiblyEvaluate(new ws(l + 1), o), p.textMaxSize = h["text-size"].possiblyEvaluate(new ws(18), o);
            const d = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement"), f = c.get("text-size");
            for (const s of t1.features){
                const l = c.get("text-font").evaluate(s, {}, o).join(","), h = f.evaluate(s, {}, o), y = p.layoutTextSize.evaluate(s, {}, o), m = (p.layoutIconSize.evaluate(s, {}, o), {
                    horizontal: {},
                    vertical: void 0
                }), g = s.text;
                let x, v = [
                    0,
                    0
                ];
                if (g) {
                    const n = g.toString(), a = c.get("text-letter-spacing").evaluate(s, {}, o) * Rh, u = c.get("text-line-height").evaluate(s, {}, o) * Rh, p = rs(n) ? a : 0, f = c.get("text-anchor").evaluate(s, {}, o), x = c.get("text-variable-anchor");
                    if (!x) {
                        const t1 = c.get("text-radial-offset").evaluate(s, {}, o);
                        v = t1 ? xd(f, [
                            t1 * Rh,
                            md
                        ]) : c.get("text-offset").evaluate(s, {}, o).map((t1)=>t1 * Rh);
                    }
                    let b = d ? "center" : c.get("text-justify").evaluate(s, {}, o);
                    const w = "point" === c.get("symbol-placement"), _ = w ? c.get("text-max-width").evaluate(s, {}, o) * Rh : 1 / 0, A = (s)=>{
                        t1.allowVerticalPlacement && es(n) && (m.vertical = Bp(g, e1, r, i, l, _, u, f, s, p, v, Ip.vertical, !0, y, h));
                    };
                    if (!d && x) {
                        const t1 = "auto" === b ? x.map((t1)=>bd(t1)) : [
                            b
                        ];
                        let n = !1;
                        for(let s = 0; s < t1.length; s++){
                            const a = t1[s];
                            if (!m.horizontal[a]) {
                                if (n) m.horizontal[a] = m.horizontal[0];
                                else {
                                    const t1 = Bp(g, e1, r, i, l, _, u, "center", a, p, v, Ip.horizontal, !1, y, h);
                                    t1 && (m.horizontal[a] = t1, n = 1 === t1.positionedLines.length);
                                }
                            }
                        }
                        A("left");
                    } else {
                        if ("auto" === b && (b = bd(f)), w || c.get("text-writing-mode").indexOf("horizontal") >= 0 || !es(n)) {
                            const t1 = Bp(g, e1, r, i, l, _, u, f, b, p, v, Ip.horizontal, !1, y, h);
                            t1 && (m.horizontal[b] = t1);
                        }
                        A(w ? "left" : b);
                    }
                }
                let b = !1;
                if (s.icon && s.icon.name) {
                    const e1 = n[s.icon.name];
                    e1 && (x = $p(i[s.icon.name], c.get("icon-offset").evaluate(s, {}, o), c.get("icon-anchor").evaluate(s, {}, o)), b = e1.sdf, void 0 === t1.sdfIcons ? t1.sdfIcons = e1.sdf : t1.sdfIcons !== e1.sdf && N("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e1.pixelRatio !== t1.pixelRatio || 0 !== c.get("icon-rotate").constantOr(1)) && (t1.iconsNeedLinear = !0));
                }
                const w = kd(m.horizontal) || m.vertical;
                t1.iconsInText || (t1.iconsInText = !!w && w.iconsInText), (w || x) && wd(t1, s, m, x, n, p, y, 0, v, b, a, o, u);
            }
            s && t1.generateCollisionDebugBuffers(l, t1.collisionBoxArray);
        }
        function bd(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function wd(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
            let d = s.textMaxSize.evaluate(e1, {}, h);
            void 0 === d && (d = a);
            const f = t1.layers[0].layout, y = f.get("icon-offset").evaluate(e1, {}, h), m = kd(r.horizontal) || r.vertical, g = "globe" === p.name, x = Rh, v = a / x, b = t1.tilePixelRatio * d / x, _ = (B = t1.overscaling, t1.zoom > 18 && B > 2 && (B >>= 1), Math.max(ao / (512 * B), 1) * f.get("symbol-spacing")), A = f.get("text-padding") * t1.tilePixelRatio, S = f.get("icon-padding") * t1.tilePixelRatio, k = w(f.get("text-max-angle")), I = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"), M = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"), T = f.get("symbol-placement"), z = _ / 2;
            var B;
            const E = f.get("icon-text-fit");
            let C;
            n && "none" !== E && (t1.allowVerticalPlacement && r.vertical && (C = jp(n, r.vertical, E, f.get("icon-text-fit-padding"), y, v)), m && (n = jp(n, m, E, f.get("icon-text-fit-padding"), y, v)));
            const P = (a, o, d)=>{
                if (o.x < 0 || o.x >= ao || o.y < 0 || o.y >= ao) return;
                let f = null;
                if (g) {
                    const { x: t1, y: e1, z: r } = p.projectTilePoint(o.x, o.y, d);
                    f = {
                        anchor: new Op(t1, e1, r, 0, void 0),
                        up: p.upVector(d, o.x, o.y)
                    };
                }
                !function(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S) {
                    const k = t1.addToLineVertexArray(e1, n);
                    let I, M, T, z, B, E, C, P = 0, D = 0, V = 0, L = 0, F = -1, R = -1;
                    const U = {};
                    let $ = Ba("");
                    const j = r ? r.anchor : e1;
                    let O = 0, q = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [O, q] = l.layout.get("text-offset").evaluate(b, {}, S).map((t1)=>t1 * Rh) : (O = l.layout.get("text-radial-offset").evaluate(b, {}, S) * Rh, q = md), t1.allowVerticalPlacement && i.vertical) {
                        const t1 = i.vertical;
                        if (f) E = Md(t1), o && (C = Md(o));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, S) + 90;
                            T = Id(u, j, e1, c, h, p, t1, d, r, y), o && (z = Id(u, j, e1, c, h, p, o, g, r));
                        }
                    }
                    if (s) {
                        const n = l.layout.get("icon-rotate").evaluate(b, {}, S), i = "none" !== l.layout.get("icon-text-fit"), a = id(s, n, _, i), d = o ? id(o, n, _, i) : void 0;
                        M = Id(u, j, e1, c, h, p, s, g, n), P = 4 * a.length;
                        const f = t1.iconSizeData;
                        let y = null;
                        "source" === f.kind ? (y = [
                            Uh * l.layout.get("icon-size").evaluate(b, {}, S)
                        ], y[0] > Ad && N(`${t1.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)) : "composite" === f.kind && (y = [
                            Uh * w.compositeIconSizes[0].evaluate(b, {}, S),
                            Uh * w.compositeIconSizes[1].evaluate(b, {}, S)
                        ], (y[0] > Ad || y[1] > Ad) && N(`${t1.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)), t1.addSymbols(t1.icon, a, y, v, x, b, !1, r, e1, k.lineStartIndex, k.lineLength, -1, A, S), F = t1.icon.placedSymbolArray.length - 1, d && (D = 4 * d.length, t1.addSymbols(t1.icon, d, y, v, x, b, Ip.vertical, r, e1, k.lineStartIndex, k.lineLength, -1, A, S), R = t1.icon.placedSymbolArray.length - 1);
                    }
                    for(const n in i.horizontal){
                        const s = i.horizontal[n];
                        I || ($ = Ba(s.text), f ? B = Md(s) : I = Id(u, j, e1, c, h, p, s, d, l.layout.get("text-rotate").evaluate(b, {}, S), y));
                        const o = 1 === s.positionedLines.length;
                        if (V += Sd(t1, r, e1, s, a, l, f, b, y, k, i.vertical ? Ip.horizontal : Ip.horizontalOnly, o ? Object.keys(i.horizontal) : [
                            n
                        ], U, F, w, A, S), o) break;
                    }
                    i.vertical && (L += Sd(t1, r, e1, i.vertical, a, l, f, b, y, k, Ip.vertical, [
                        "vertical"
                    ], U, R, w, A, S));
                    let G = -1;
                    const Z = (t1, e1)=>t1 ? Math.max(t1, e1) : e1;
                    G = Z(B, G), G = Z(E, G), G = Z(C, G);
                    const K = G > -1 ? 1 : 0;
                    t1.glyphOffsetArray.length >= of.MAX_GLYPHS && N("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t1.addToSortKeyRanges(t1.symbolInstances.length, b.sortKey), t1.symbolInstances.emplaceBack(j.x, j.y, j.z, e1.x, e1.y, U.right >= 0 ? U.right : -1, U.center >= 0 ? U.center : -1, U.left >= 0 ? U.left : -1, U.vertical >= 0 ? U.vertical : -1, F, R, $, void 0 !== I ? I : t1.collisionBoxArray.length, void 0 !== I ? I + 1 : t1.collisionBoxArray.length, void 0 !== T ? T : t1.collisionBoxArray.length, void 0 !== T ? T + 1 : t1.collisionBoxArray.length, void 0 !== M ? M : t1.collisionBoxArray.length, void 0 !== M ? M + 1 : t1.collisionBoxArray.length, z || t1.collisionBoxArray.length, z ? z + 1 : t1.collisionBoxArray.length, c, V, L, P, D, K, 0, O, q, G);
                }(t1, o, f, a, r, n, i, C, t1.layers[0], t1.collisionBoxArray, e1.index, e1.sourceLayerIndex, t1.index, A, I, l, 0, S, M, y, e1, s, u, c, h);
            };
            if ("line" === T) for (const i of Hp(e1.geometry, 0, 0, ao, ao)){
                const e1 = Xp(i, _, k, r.vertical || m, n, x, b, t1.overscaling, ao);
                for (const r of e1)m && Td(t1, m.text, z, r) || P(i, r, h);
            }
            else if ("line-center" === T) {
                for (const t1 of e1.geometry)if (t1.length > 1) {
                    const e1 = Kp(t1, k, r.vertical || m, n, x, b);
                    e1 && P(t1, e1, h);
                }
            } else if ("Polygon" === e1.type) for (const t1 of Ac(e1.geometry, 0)){
                const e1 = pd(t1, 16);
                P(t1[0], new Op(e1.x, e1.y, 0, 0, void 0), h);
            }
            else if ("LineString" === e1.type) for (const t1 of e1.geometry)P(t1, new Op(t1[0].x, t1[0].y, 0, 0, void 0), h);
            else if ("Point" === e1.type) for (const t1 of e1.geometry)for (const e1 of t1)P([
                e1
            ], new Op(e1.x, e1.y, 0, 0, void 0), h);
        }
        const _d = 255, Ad = _d * Uh;
        function Sd(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m) {
            const g = function(t1, e1, r, n, i, s, a, o) {
                const l = [];
                if (0 === e1.positionedLines.length) return l;
                const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180, c = function(t1) {
                    const e1 = t1[0], r = t1[1], n = e1 * r;
                    return n > 0 ? [
                        e1,
                        -r
                    ] : n < 0 ? [
                        -e1,
                        r
                    ] : 0 === e1 ? [
                        r,
                        e1
                    ] : [
                        r,
                        -e1
                    ];
                }(r);
                let h = Math.abs(e1.top - e1.bottom);
                for (const t1 of e1.positionedLines)h -= t1.lineOffset;
                const p = e1.positionedLines.length, d = h / p;
                let f = e1.top - r[1];
                for(let t1 = 0; t1 < p; ++t1){
                    const n = e1.positionedLines[t1];
                    f = ud(e1, d, f, t1);
                    for (const t1 of n.positionedGlyphs){
                        if (!t1.rect) continue;
                        const n = t1.rect || {};
                        let s = wp + 1, h = !0, p = 1, d = 0;
                        if (t1.imageName) {
                            const e1 = a[t1.imageName];
                            if (!e1) continue;
                            if (e1.sdf) {
                                N("SDF images are not supported in formatted text and will be ignored.");
                                continue;
                            }
                            h = !1, p = e1.pixelRatio, s = Ap / p;
                        }
                        const y = (i || o) && t1.vertical, m = t1.metrics.advance * t1.scale / 2, g = t1.metrics, v = t1.rect;
                        if (null === v) continue;
                        o && e1.verticalizable && (d = t1.imageName ? m - t1.metrics.width * t1.scale / 2 : 0);
                        const b = i ? [
                            t1.x + m,
                            t1.y
                        ] : [
                            0,
                            0
                        ];
                        let w = [
                            0,
                            0
                        ], _ = [
                            0,
                            0
                        ], A = !1;
                        i || (y ? (_ = [
                            t1.x + m + c[0],
                            t1.y + c[1] - d
                        ], A = !0) : w = [
                            t1.x + m + r[0],
                            t1.y + r[1] - d
                        ]);
                        const S = v.w * t1.scale / (p * (t1.localGlyph ? td : 1)), k = v.h * t1.scale / (p * (t1.localGlyph ? td : 1));
                        let I, M, T, z;
                        if (y) {
                            const e1 = t1.y - f, r = new x(-m, m - e1), n = -Math.PI / 2, i = new x(..._);
                            I = new x(-m + w[0], w[1]), I._rotateAround(n, r)._add(i), I.x += -e1 + m, I.y -= (g.left - s) * t1.scale;
                            const a = t1.imageName ? g.advance * t1.scale : Rh * t1.scale, o = String.fromCharCode(t1.glyph);
                            Zh(o) ? I.x += (1 - s) * t1.scale : Kh(o) ? I.x += a - g.height * t1.scale + (-s - 1) * t1.scale : I.x += t1.imageName || g.width + 2 * s === v.w && g.height + 2 * s === v.h ? (a - k) / 2 : (a - (g.height + 2 * s) * t1.scale) / 2, M = new x(I.x, I.y - S), T = new x(I.x + k, I.y), z = new x(I.x + k, I.y - S);
                        } else {
                            const e1 = (g.left - s) * t1.scale - m + w[0], r = (-g.top - s) * t1.scale + w[1], n = e1 + S, i = r + k;
                            I = new x(e1, r), M = new x(n, r), T = new x(e1, i), z = new x(n, i);
                        }
                        if (u) {
                            let t1;
                            t1 = i ? new x(0, 0) : A ? new x(c[0], c[1]) : new x(r[0], r[1]), I._rotateAround(u, t1), M._rotateAround(u, t1), T._rotateAround(u, t1), z._rotateAround(u, t1);
                        }
                        const B = new x(0, 0), E = new x(0, 0);
                        l.push({
                            tl: I,
                            tr: M,
                            bl: T,
                            br: z,
                            tex: n,
                            writingMode: e1.writingMode,
                            glyphOffset: b,
                            sectionIndex: t1.sectionIndex,
                            isSDF: h,
                            pixelOffsetTL: B,
                            pixelOffsetBR: E,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return l;
            }(0, n, l, s, a, o, i, t1.allowVerticalPlacement), v = t1.textSizeData;
            let b = null;
            "source" === v.kind ? (b = [
                Uh * s.layout.get("text-size").evaluate(o, {}, m)
            ], b[0] > Ad && N(`${t1.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)) : "composite" === v.kind && (b = [
                Uh * f.compositeTextSizes[0].evaluate(o, {}, m),
                Uh * f.compositeTextSizes[1].evaluate(o, {}, m)
            ], (b[0] > Ad || b[1] > Ad) && N(`${t1.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)), t1.addSymbols(t1.text, g, b, l, a, o, c, e1, r, u.lineStartIndex, u.lineLength, d, y, m);
            for (const e1 of h)p[e1] = t1.text.placedSymbolArray.length - 1;
            return 4 * g.length;
        }
        function kd(t1) {
            for(const e1 in t1)return t1[e1];
            return null;
        }
        function Id(t1, e1, r, n, i, s, a, o, l, u) {
            let c = a.top, h = a.bottom, p = a.left, d = a.right;
            const f = a.collisionPadding;
            if (f && (p -= f[0], c -= f[1], d += f[2], h += f[3]), l) {
                const t1 = new x(p, c), e1 = new x(d, c), r = new x(p, h), n = new x(d, h), i = w(l);
                let s = new x(0, 0);
                u && (s = new x(u[0], u[1])), t1._rotateAround(i, s), e1._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t1.x, e1.x, r.x, n.x), d = Math.max(t1.x, e1.x, r.x, n.x), c = Math.min(t1.y, e1.y, r.y, n.y), h = Math.max(t1.y, e1.y, r.y, n.y);
            }
            return t1.emplaceBack(e1.x, e1.y, e1.z, r.x, r.y, p, c, d, h, o, n, i, s), t1.length - 1;
        }
        function Md(t1) {
            t1.collisionPadding && (t1.top -= t1.collisionPadding[1], t1.bottom += t1.collisionPadding[3]);
            const e1 = t1.bottom - t1.top;
            return e1 > 0 ? Math.max(10, e1) : null;
        }
        function Td(t1, e1, r, n) {
            const i = t1.compareText;
            if (e1 in i) {
                const t1 = i[e1];
                for(let e1 = t1.length - 1; e1 >= 0; e1--)if (n.dist(t1[e1]) < r) return !0;
            } else i[e1] = [];
            return i[e1].push(n), !1;
        }
        function zd(t1, e1) {
            const r = t1.fovAboveCenter, n = t1.elevation ? t1.elevation.getMinElevationBelowMSL() * e1 : 0, i = (t1._camera.position[2] * t1.worldSize - n) / Math.cos(t1._pitch), s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t1._pitch - r, .01)), a = Math.sin(t1._pitch) * s + i;
            return Math.min(1.01 * a, i * (1 / t1._horizonShift));
        }
        function Bd(t1, e1) {
            if (!e1.isReprojectedInTileSpace) return {
                scale: 1 << t1.z,
                x: t1.x,
                y: t1.y,
                x2: t1.x + 1,
                y2: t1.y + 1,
                projection: e1
            };
            const r = Math.pow(2, -t1.z), n = t1.x * r, i = (t1.x + 1) * r, s = t1.y * r, a = (t1.y + 1) * r, o = Kl(n), l = Kl(i), u = Xl(s), c = Xl(a), h = e1.project(o, u), p = e1.project(l, u), d = e1.project(l, c), f = e1.project(o, c);
            let y = Math.min(h.x, p.x, d.x, f.x), m = Math.min(h.y, p.y, d.y, f.y), g = Math.max(h.x, p.x, d.x, f.x), x = Math.max(h.y, p.y, d.y, f.y);
            const v = r / 16;
            function b(t1, r, n, i, s, a) {
                const o = (n + s) / 2, l = (i + a) / 2, u = e1.project(Kl(o), Xl(l)), c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);
                y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t1, u, n, i, o, l), b(u, r, o, l, s, a));
            }
            b(h, p, n, s, i, s), b(p, d, i, s, i, a), b(d, f, i, a, n, a), b(f, h, n, a, n, s), y -= v, m -= v, g += v, x += v;
            const w = 1 / Math.max(g - y, x - m);
            return {
                scale: w,
                x: y * w,
                y: m * w,
                x2: g * w,
                y2: x * w,
                projection: e1
            };
        }
        const Ed = po(new Float32Array(16));
        class Cd {
            constructor(t1){
                this.spec = t1, this.name = t1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t1, e1) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t1, e1) {
                return new Ol(0, 0);
            }
            projectTilePoint(t1, e1, r) {
                return {
                    x: t1,
                    y: e1,
                    z: 0
                };
            }
            locationPoint(t1, e1, r = !0) {
                return t1._coordinatePoint(t1.locationCoordinate(e1), r);
            }
            pixelsPerMeter(t1, e1) {
                return Zl(1, t1) * e1;
            }
            pixelSpaceConversion(t1, e1, r) {
                return 1;
            }
            farthestPixelDistance(t1) {
                return zd(t1, t1.pixelsPerMeter);
            }
            pointCoordinate(t1, e1, r, n) {
                const i = t1.horizonLineFromTop(!1), s = new x(e1, Math.max(i, r));
                return t1.rayIntersectionCoordinate(t1.pointRayIntersection(s, n));
            }
            pointCoordinate3D(t1, e1, r) {
                const n = new x(e1, r);
                if (t1.elevation) return t1.elevation.pointCoordinate(n);
                {
                    const e1 = this.pointCoordinate(t1, n.x, n.y, 0);
                    return [
                        e1.x,
                        e1.y,
                        e1.z
                    ];
                }
            }
            isPointAboveHorizon(t1, e1) {
                if (t1.elevation) return !this.pointCoordinate3D(t1, e1.x, e1.y);
                const r = t1.horizonLineFromTop();
                return e1.y < r;
            }
            createInversionMatrix(t1, e1) {
                return Ed;
            }
            createTileMatrix(t1, e1, r) {
                let n, i, s;
                const a = r.canonical, o = po(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l = Bd(a, this);
                    n = 1, i = l.x + r.wrap * l.scale, s = l.y, go(o, o, [
                        n / l.scale,
                        n / l.scale,
                        t1.pixelsPerMeter / e1
                    ]);
                } else n = e1 / t1.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;
                return mo(o, o, [
                    i,
                    s,
                    0
                ]), go(o, o, [
                    n / ao,
                    n / ao,
                    1
                ]), o;
            }
            upVector(t1, e1, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t1, e1, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class Pd extends Cd {
            constructor(t1){
                super(t1), this.range = [
                    4,
                    7
                ], this.center = t1.center || [
                    -96,
                    37.5
                ];
                const [e1, r] = this.parallels = t1.parallels || [
                    29.5,
                    45.5
                ], n = Math.sin(w(e1));
                this.n = (n + Math.sin(w(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t1, e1) {
                const { n: r, c: n, r0: i } = this, s = w(t1 - this.center[0]), a = w(e1), o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
                return {
                    x: o * Math.sin(s * r),
                    y: o * Math.cos(s * r) - i,
                    z: 0
                };
            }
            unproject(t1, e1) {
                const { n: r, c: n, r0: i } = this, s = i + e1;
                let a = Math.atan2(t1, Math.abs(s)) * Math.sign(s);
                s * r < 0 && (a -= Math.PI * Math.sign(t1) * Math.sign(s));
                const o = w(this.center[0]) * r;
                a = z(a, -Math.PI - o, Math.PI - o);
                const l = M(_(a / r) + this.center[0], -180, 180), u = Math.asin(M((n - (t1 * t1 + s * s) * r * r) / (2 * r), -1, 1)), c = M(_(u), -Hl, Hl);
                return new Ol(l, c);
            }
        }
        const Dd = 1.340264, Vd = -0.081106, Ld = 893e-6, Fd = .003796, Rd = Math.sqrt(3) / 2;
        class Ud extends Cd {
            project(t1, e1) {
                e1 = e1 / 180 * Math.PI, t1 = t1 / 180 * Math.PI;
                const r = Math.asin(Rd * Math.sin(e1)), n = r * r, i = n * n * n;
                return {
                    x: .5 * (t1 * Math.cos(r) / (Rd * (Dd + 3 * Vd * n + i * (7 * Ld + 9 * Fd * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (Dd + Vd * n + i * (Ld + Fd * n)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e1 = (2 * (1 - e1) - 1) * Math.PI, n = r * r, i = n * n * n;
                for(let t1, s, a, o = 0; o < 12 && (s = r * (Dd + Vd * n + i * (Ld + Fd * n)) - e1, a = Dd + 3 * Vd * n + i * (7 * Ld + 9 * Fd * n), t1 = s / a, r = M(r - t1, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t1) < 1e-12)); ++o);
                const s = Rd * t1 * (Dd + 3 * Vd * n + i * (7 * Ld + 9 * Fd * n)) / Math.cos(r), a = Math.asin(Math.sin(r) / Rd), o = M(180 * s / Math.PI, -180, 180), l = M(180 * a / Math.PI, -Hl, Hl);
                return new Ol(o, l);
            }
        }
        class $d extends Cd {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e1) {
                return {
                    x: .5 + t1 / 360,
                    y: .5 - e1 / 360,
                    z: 0
                };
            }
            unproject(t1, e1) {
                const r = 360 * (t1 - .5), n = M(360 * (.5 - e1), -Hl, Hl);
                return new Ol(r, n);
            }
        }
        const jd = Math.PI / 2;
        function Od(t1) {
            return Math.tan((jd + t1) / 2);
        }
        class qd extends Cd {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    30
                ];
                const [e1, r] = this.parallels = t1.parallels || [
                    30,
                    30
                ];
                let n = w(e1), i = w(r);
                this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
                const s = Math.cos(n), a = Od(n);
                this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Od(i) / a), this.f = s * Math.pow(Od(n), this.n) / this.n;
            }
            project(t1, e1) {
                e1 = w(e1), this.southernCenter && (e1 = -e1), t1 = w(t1 - this.center[0]);
                const r = 1e-6, { n: n, f: i } = this;
                i > 0 ? e1 < -jd + r && (e1 = -jd + r) : e1 > jd - r && (e1 = jd - r);
                const s = i / Math.pow(Od(e1), n);
                let a = s * Math.sin(n * t1), o = i - s * Math.cos(n * t1);
                return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {
                    x: a,
                    y: this.southernCenter ? o : 1 - o,
                    z: 0
                };
            }
            unproject(t1, e1) {
                t1 = (2 * t1 - .5) * Math.PI, this.southernCenter && (e1 = 1 - e1), e1 = (2 * (1 - e1) - .5) * Math.PI;
                const { n: r, f: n } = this, i = n - e1, s = Math.sign(i), a = Math.sign(r) * Math.sqrt(t1 * t1 + i * i);
                let o = Math.atan2(t1, Math.abs(i)) * s;
                i * r < 0 && (o -= Math.PI * Math.sign(t1) * s);
                const l = M(_(o / r) + this.center[0], -180, 180), u = M(_(2 * Math.atan(Math.pow(n / a, 1 / r)) - jd), -Hl, Hl);
                return new Ol(l, this.southernCenter ? -u : u);
            }
        }
        class Nd extends Cd {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t1, e1) {
                return {
                    x: Nl(t1),
                    y: Gl(e1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                const r = Kl(t1), n = Xl(e1);
                return new Ol(r, n);
            }
        }
        const Gd = w(Hl);
        class Zd extends Cd {
            project(t1, e1) {
                const r = (e1 = w(e1)) * e1, n = r * r;
                return {
                    x: .5 * ((t1 = w(t1)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e1 * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e1 = (2 * (1 - e1) - 1) * Math.PI, n = 25, i = 0, s = r * r;
                do {
                    s = r * r;
                    const t1 = s * s;
                    i = (r * (1.007226 + s * (.015085 + t1 * (.028874 * s - .044475 - .005916 * t1))) - e1) / (1.007226 + s * (.045255 + t1 * (.259866 * s - .311325 - .005916 * 11 * t1))), r = M(r - i, -Gd, Gd);
                }while (Math.abs(i) > 1e-6 && --n > 0);
                s = r * r;
                const a = M(_(t1 / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180), o = _(r);
                return new Ol(a, o);
            }
        }
        const Kd = w(Hl);
        class Xd extends Cd {
            project(t1, e1) {
                e1 = w(e1), t1 = w(t1);
                const r = Math.cos(e1), n = 2 / Math.PI, i = Math.acos(r * Math.cos(t1 / 2)), s = Math.sin(i) / i, a = .5 * (t1 * n + 2 * r * Math.sin(t1 / 2) / s) || 0, o = .5 * (e1 + Math.sin(e1) / s) || 0;
                return {
                    x: .5 * (a / Math.PI + .5),
                    y: 1 - .5 * (o / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                let r = t1 = (2 * t1 - .5) * Math.PI, n = e1 = (2 * (1 - e1) - 1) * Math.PI, i = 25;
                const s = 1e-6;
                let a = 0, o = 0;
                do {
                    const i = Math.cos(n), s = Math.sin(n), l = 2 * s * i, u = s * s, c = i * i, h = Math.cos(r / 2), p = Math.sin(r / 2), d = 2 * h * p, f = p * p, y = 1 - c * h * h, m = y ? 1 / y : 0, g = y ? Math.acos(i * h) * Math.sqrt(1 / y) : 0, x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t1, v = .5 * (g * s + n) - e1, b = .5 * m * (c * f + g * i * h * u) + 1 / Math.PI, w = m * (d * l / 4 - g * s * p), _ = .125 * m * (l * p - g * s * c * d), A = .5 * m * (u * h + g * f * i) + .5, S = w * _ - A * b;
                    a = (v * w - x * A) / S, o = (x * _ - v * b) / S, r = M(r - a, -Math.PI, Math.PI), n = M(n - o, -Kd, Kd);
                }while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);
                return new Ol(_(r), _(n));
            }
        }
        class Jd extends Cd {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    0
                ], this.parallels = t1.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(.01, Math.cos(w(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e1) {
                const { scale: r, cosPhi: n } = this;
                return {
                    x: w(t1) * n * r + .5,
                    y: -Math.sin(w(e1)) / n * r + .5,
                    z: 0
                };
            }
            unproject(t1, e1) {
                const { scale: r, cosPhi: n } = this, i = -(e1 - .5) / r, s = M(_((t1 - .5) / r) / n, -180, 180), a = Math.asin(M(i * n, -1, 1)), o = M(_(a), -Hl, Hl);
                return new Ol(s, o);
            }
        }
        class Hd extends Nd {
            constructor(t1){
                super(t1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(t1, e1, r) {
                const n = Ml(t1, e1, r);
                return Fo(n, n, Bl(xl(r))), {
                    x: n[0],
                    y: n[1],
                    z: n[2]
                };
            }
            locationPoint(t1, e1) {
                const r = Il(e1.lat, e1.lng), n = Do([], r), i = t1.elevation ? t1.elevation.getAtPointOrZero(t1.locationCoordinate(e1), t1._centerAltitude) : t1._centerAltitude;
                Po(r, r, n, Zl(1, 0) * ao * i);
                const s = po(new Float64Array(16));
                return yo(s, t1.pixelMatrix, t1.globeMatrix), Fo(r, r, s), new x(r[0], r[1]);
            }
            pixelsPerMeter(t1, e1) {
                return Zl(1, 0) * e1;
            }
            pixelSpaceConversion(t1, e1, r) {
                const n = Zl(1, t1) * e1, i = Er(Zl(1, 45) * e1, n, r);
                return this.pixelsPerMeter(t1, e1) / i;
            }
            createTileMatrix(t1, e1, r) {
                const n = El(xl(r.canonical));
                return yo(new Float64Array(16), t1.globeMatrix, n);
            }
            createInversionMatrix(t1, e1) {
                const { center: r } = t1, n = Bl(xl(e1));
                return vo(n, n, w(r.lng)), xo(n, n, w(r.lat)), go(n, n, [
                    t1._pixelsPerMercatorPixel,
                    t1._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(n);
            }
            pointCoordinate(t1, e1, r, n) {
                return yl(t1, e1, r, !0) || new Wl(0, 0);
            }
            pointCoordinate3D(t1, e1, r) {
                const n = this.pointCoordinate(t1, e1, r, 0);
                return [
                    n.x,
                    n.y,
                    n.z
                ];
            }
            isPointAboveHorizon(t1, e1) {
                return !yl(t1, e1.x, e1.y, !1);
            }
            farthestPixelDistance(t1) {
                const e1 = function(t1, e1) {
                    const r = t1.cameraToCenterDistance, n = t1._centerAltitude * e1, i = t1._camera, s = t1._camera.forward(), a = Mo([], Co([], s, -r), [
                        0,
                        0,
                        n
                    ]), o = t1.worldSize / (2 * Math.PI), l = [
                        0,
                        0,
                        -o
                    ], u = t1.width / t1.height, c = Math.tan(t1.fovAboveCenter), h = Co([], i.up(), c), p = Co([], i.right(), c * u), d = Do([], Mo([], Mo([], s, h), p)), f = [];
                    let y;
                    if (new el(a, d).closestPointOnSphere(l, o, f)) {
                        const e1 = Mo([], f, l), r = $o([], e1, a);
                        y = Math.cos(t1.fovAboveCenter) * ko(r);
                    } else {
                        const t1 = $o([], a, l), e1 = $o([], l, a);
                        Do(e1, e1);
                        const r = ko(t1) - o;
                        y = Math.sqrt(r * (r + 2 * o));
                        const n = Math.acos(y / (o + r)) - Math.acos(Vo(s, e1));
                        y *= Math.cos(n);
                    }
                    return 1.01 * y;
                }(t1, this.pixelsPerMeter(t1.center.lat, t1.worldSize)), r = Pl(t1.zoom);
                if (r > 0) {
                    const n = zd(t1, Zl(1, t1.center.lat) * t1.worldSize), i = t1.worldSize / (2 * Math.PI), s = Math.max(t1.width, t1.height) / t1.worldSize * Math.PI;
                    return Er(e1, n + i * (1 - Math.cos(s)), Math.pow(r, 10));
                }
                return e1;
            }
            upVector(t1, e1, r) {
                return Ml(e1, r, t1, 1);
            }
            upVectorScale(t1) {
                return {
                    metersToTile: fl(Tl(xl(t1)))
                };
            }
        }
        function Yd(t1) {
            const e1 = t1.parallels, r = !!e1 && Math.abs(e1[0] + e1[1]) < .01;
            switch(t1.name){
                case "mercator":
                    return new Nd(t1);
                case "equirectangular":
                    return new $d(t1);
                case "naturalEarth":
                    return new Zd(t1);
                case "equalEarth":
                    return new Ud(t1);
                case "winkelTripel":
                    return new Xd(t1);
                case "albers":
                    return r ? new Jd(t1) : new Pd(t1);
                case "lambertConformalConic":
                    return r ? new Jd(t1) : new qd(t1);
                case "globe":
                    return new Hd(t1);
            }
            throw new Error(`Invalid projection name: ${t1.name}`);
        }
        const Wd = Kc.types, Qd = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function tf(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
            const d = o ? Math.min(Ad, Math.round(o[0])) : 0, f = o ? Math.min(Ad, Math.round(o[1])) : 0;
            t1.emplaceBack(e1, r, Math.round(32 * n), Math.round(32 * i), s, a, (d << 1) + (l ? 1 : 0), f, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function ef(t1, e1, r, n, i, s, a) {
            t1.emplaceBack(e1, r, n, i, s, a);
        }
        function rf(t1, e1, r, n, i) {
            t1.emplaceBack(e1, r, n, i), t1.emplaceBack(e1, r, n, i), t1.emplaceBack(e1, r, n, i), t1.emplaceBack(e1, r, n, i);
        }
        function nf(t1) {
            for (const e1 of t1.sections)if (ls(e1.text)) return !0;
            return !1;
        }
        class sf {
            constructor(t1){
                this.layoutVertexArray = new Xs, this.indexArray = new ra, this.programConfigurations = t1, this.segments = new so, this.dynamicLayoutVertexArray = new Ns, this.opacityVertexArray = new Hs, this.placedSymbolArray = new fa, this.globeExtVertexArray = new Js;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t1, e1, r, n) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Eh.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e1), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, Ph.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, Qd, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Ch.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
        }
        Ji(sf, "SymbolBuffers");
        class af {
            constructor(t1, e1, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e1, this.indexArray = new r, this.segments = new so, this.collisionVertexArray = new ta, this.collisionVertexArrayExt = new ea;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, Dh.members, !0), this.collisionVertexBufferExt = t1.createVertexBuffer(this.collisionVertexArrayExt, Vh.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        Ji(af, "CollisionBuffers");
        class of {
            constructor(t1){
                this.collisionBoxArray = t1.collisionBoxArray, this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.pixelRatio = t1.pixelRatio, this.sourceLayerIndex = t1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = po([]), this.placementViewportMatrix = po([]);
                const e1 = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = $h(this.zoom, e1["text-size"]), this.iconSizeData = $h(this.zoom, e1["icon-size"]);
                const r = this.layers[0].layout, n = r.get("symbol-sort-key"), i = r.get("symbol-z-order");
                this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map((t1)=>Ip[t1]), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = t1.sourceID, this.projection = t1.projection;
            }
            createArrays() {
                this.text = new sf(new Ja(this.layers, this.zoom, (t1)=>/^text/.test(t1))), this.icon = new sf(new Ja(this.layers, this.zoom, (t1)=>/^icon/.test(t1))), this.glyphOffsetArray = new ga, this.lineVertexArray = new xa, this.symbolInstances = new ma;
            }
            calculateGlyphDependencies(t1, e1, r, n, i) {
                for(let r = 0; r < t1.length; r++)if (e1[t1.charCodeAt(r)] = !0, n && i) {
                    const n = Gh[t1.charAt(r)];
                    n && (e1[n.charCodeAt(0)] = !0);
                }
            }
            populate(t1, e1, r, n) {
                const i = this.layers[0], s = i.layout, a = "globe" === this.projection.name, o = s.get("text-font"), l = s.get("text-field"), u = s.get("icon-image"), c = ("constant" !== l.value.kind || l.value.value instanceof De && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0), h = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0, p = s.get("symbol-sort-key");
                if (this.features = [], !c && !h) return;
                const d = e1.iconDependencies, f = e1.glyphDependencies, y = e1.availableImages, m = new ws(this.zoom);
                for (const { feature: e1, id: l, index: u, sourceLayerIndex: g } of t1){
                    const t1 = i._featureFilter.needGeometry, x = ou(e1, t1);
                    if (!i._featureFilter.filter(m, x, r)) continue;
                    if (t1 || (x.geometry = au(e1, r, n)), a && 1 !== e1.type && r.z <= 5) {
                        const t1 = x.geometry, e1 = .98078528056, n = (t1, n)=>Vo(Ml(t1.x, t1.y, r, 1), Ml(n.x, n.y, r, 1)) < e1;
                        for(let e1 = 0; e1 < t1.length; e1++)t1[e1] = ru(t1[e1], n);
                    }
                    let v, b;
                    if (c) {
                        const t1 = i.getValueAndResolveTokens("text-field", x, r, y), e1 = De.factory(t1);
                        nf(e1) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === xs() || this.hasRTLText && bs.isParsed()) && (v = Nh(e1, i, x));
                    }
                    if (h) {
                        const t1 = i.getValueAndResolveTokens("icon-image", x, r, y);
                        b = t1 instanceof Ve ? t1 : Ve.fromString(t1);
                    }
                    if (!v && !b) continue;
                    const w = this.sortFeaturesByKey ? p.evaluate(x, {}, r) : void 0;
                    if (this.features.push({
                        id: l,
                        text: v,
                        icon: b,
                        index: u,
                        sourceLayerIndex: g,
                        geometry: x.geometry,
                        properties: e1.properties,
                        type: Wd[e1.type],
                        sortKey: w
                    }), b && (d[b.name] = !0), v) {
                        const t1 = o.evaluate(x, {}, r).join(","), e1 = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ip.vertical) >= 0;
                        for (const r of v.sections)if (r.image) d[r.image.name] = !0;
                        else {
                            const n = es(v.toString()), i = r.fontStack || t1, s = f[i] = f[i] || {};
                            this.calculateGlyphDependencies(r.text, s, e1, this.allowVerticalPlacement, n);
                        }
                    }
                }
                "line" === s.get("symbol-placement") && (this.features = function(t1) {
                    const e1 = {}, r = {}, n = [];
                    let i = 0;
                    function s(e1) {
                        n.push(t1[e1]), i++;
                    }
                    function a(t1, e1, i) {
                        const s = r[t1];
                        return delete r[t1], r[e1] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
                    }
                    function o(t1, r, i) {
                        const s = e1[r];
                        return delete e1[r], e1[t1] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
                    }
                    function l(t1, e1, r) {
                        const n = r ? e1[0][e1[0].length - 1] : e1[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            s(u);
                            continue;
                        }
                        const d = l(p, h), f = l(p, h, !0);
                        if (d in r && f in e1 && r[d] !== e1[f]) {
                            const t1 = o(d, f, h), i = a(d, f, n[t1].geometry);
                            delete e1[d], delete r[f], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else d in r ? a(d, f, h) : f in e1 ? o(d, f, h) : (s(u), e1[d] = i - 1, r[f] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), this.sortFeaturesByKey && this.features.sort((t1, e1)=>t1.sortKey - e1.sortKey);
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t1, e1, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t1, e1, this.layers, r, n));
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = Yd(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t1, e1) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) for (const { x: t1, y: r } of e1)this.lineVertexArray.emplaceBack(t1, r);
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(t1, e1, r, n, i, s, a, o, l, u, c, h, p, d) {
                const f = t1.indexArray, y = t1.layoutVertexArray, m = t1.globeExtVertexArray, g = t1.segments.prepareSegment(4 * e1.length, y, f, this.canOverlap ? s.sortKey : void 0), x = this.glyphOffsetArray.length, v = g.vertexLength, b = this.allowVerticalPlacement && a === Ip.vertical ? Math.PI / 2 : 0, w = s.text && s.text.sections;
                for(let n = 0; n < e1.length; n++){
                    const { tl: i, tr: a, bl: u, br: c, tex: h, pixelOffsetTL: x, pixelOffsetBR: v, minFontScaleX: _, minFontScaleY: A, glyphOffset: S, isSDF: k, sectionIndex: I } = e1[n], M = g.vertexLength, T = S[1];
                    if (tf(y, l.x, l.y, i.x, T + i.y, h.x, h.y, r, k, x.x, x.y, _, A), tf(y, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, k, v.x, x.y, _, A), tf(y, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, k, x.x, v.y, _, A), tf(y, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, k, v.x, v.y, _, A), o) {
                        const { x: e1, y: r, z: n } = o.anchor, [i, s, a] = o.up;
                        ef(m, e1, r, n, i, s, a), ef(m, e1, r, n, i, s, a), ef(m, e1, r, n, i, s, a), ef(m, e1, r, n, i, s, a), rf(t1.dynamicLayoutVertexArray, e1, r, n, b);
                    } else rf(t1.dynamicLayoutVertexArray, l.x, l.y, l.z, b);
                    f.emplaceBack(M, M + 1, M + 2), f.emplaceBack(M + 1, M + 2, M + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S[0]), n !== e1.length - 1 && I === e1[n + 1].sectionIndex || t1.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, d, w && w[I]);
                }
                const _ = o ? o.anchor : l;
                t1.placedSymbolArray.emplaceBack(_.x, _.y, _.z, l.x, l.y, x, this.glyphOffsetArray.length - x, v, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
            }
            _commitLayoutVertex(t1, e1, r, n, i, s, a) {
                t1.emplaceBack(e1, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }
            _addCollisionDebugVertices(t1, e1, r, n, i, s, a) {
                const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l = o.vertexLength, u = a.tileAnchorX, c = a.tileAnchorY;
                for(let t1 = 0; t1 < 4; t1++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                r.collisionVertexArrayExt.emplaceBack(e1, -t1.padding, -t1.padding), r.collisionVertexArrayExt.emplaceBack(e1, t1.padding, -t1.padding), r.collisionVertexArrayExt.emplaceBack(e1, t1.padding, t1.padding), r.collisionVertexArrayExt.emplaceBack(e1, -t1.padding, t1.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t1.x1, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t1.x2, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t1.x2, t1.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t1.x1, t1.y2)), o.vertexLength += 4;
                const h = r.indexArray;
                h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e1, a);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e1, s.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t1, e1) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new af(Ws, Lh.members, la), this.iconCollisionBox = new af(Ws, Lh.members, la);
                const r = Oh(this.iconSizeData, t1), n = Oh(this.textSizeData, t1);
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const s = this.symbolInstances.get(i);
                    this._addTextDebugCollisionBoxes(n, t1, e1, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t1, e1, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t1, e1, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t1, e1, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }
            getSymbolInstanceTextSize(t1, e1, r, n) {
                const i = this.text.placedSymbolArray.get(e1.rightJustifiedTextSymbolIndex >= 0 ? e1.rightJustifiedTextSymbolIndex : e1.centerJustifiedTextSymbolIndex >= 0 ? e1.centerJustifiedTextSymbolIndex : e1.leftJustifiedTextSymbolIndex >= 0 ? e1.leftJustifiedTextSymbolIndex : e1.verticalPlacedTextSymbolIndex >= 0 ? e1.verticalPlacedTextSymbolIndex : n), s = jh(this.textSizeData, t1, i) / Rh;
                return this.tilePixelRatio * s;
            }
            getSymbolInstanceIconSize(t1, e1, r) {
                const n = this.icon.placedSymbolArray.get(r), i = jh(this.iconSizeData, t1, n);
                return this.tilePixelRatio * i;
            }
            _commitDebugCollisionVertexUpdate(t1, e1, r) {
                t1.emplaceBack(e1, -r, -r), t1.emplaceBack(e1, r, -r), t1.emplaceBack(e1, r, r), t1.emplaceBack(e1, -r, r);
            }
            _updateTextDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e1, a);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }
            _updateIconDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e1, s);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }
            updateCollisionDebugBuffers(t1, e1) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const r = Oh(this.iconSizeData, t1), n = Oh(this.textSizeData, t1);
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const s = this.symbolInstances.get(i);
                    this._updateTextDebugCollisionBoxes(n, t1, e1, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t1, e1, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t1, e1, s.iconBoxStartIndex, s.iconBoxEndIndex, s.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r, t1, e1, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s.placedIconSymbolIndex);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t1, e1, r, n, i, s, a, o, l) {
                const u = {};
                if (e1 < r) {
                    const { x1: r, y1: n, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(e1);
                    u.textBox = {
                        x1: r,
                        y1: n,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.textFeatureIndex = d;
                }
                if (n < i) {
                    const { x1: e1, y1: r, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(n);
                    u.verticalTextBox = {
                        x1: e1,
                        y1: r,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalTextFeatureIndex = d;
                }
                if (s < a) {
                    const { x1: e1, y1: r, x2: n, y2: i, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(s);
                    u.iconBox = {
                        x1: e1,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.iconFeatureIndex = d;
                }
                if (o < l) {
                    const { x1: e1, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(o);
                    u.verticalIconBox = {
                        x1: e1,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalIconFeatureIndex = d;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e1 = 0; e1 < this.symbolInstances.length; e1++){
                    const r = this.symbolInstances.get(e1);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t1, e1) {
                const r = t1.placedSymbolArray.get(e1), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e1 = r.vertexStartIndex; e1 < n; e1 += 4)t1.indexArray.emplaceBack(e1, e1 + 1, e1 + 2), t1.indexArray.emplaceBack(e1 + 1, e1 + 2, e1 + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e1 = Math.sin(t1), r = Math.cos(t1), n = [], i = [], s = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    s.push(t1);
                    const a = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e1 * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
                }
                return s.sort((t1, e1)=>n[t1] - n[e1] || i[e1] - i[t1]), s;
            }
            addToSortKeyRanges(t1, e1) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e1 ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e1,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e1 = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e1.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: s, placedIconSymbolIndex: a, verticalPlacedIconSymbolIndex: o } = e1;
                        r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        Ji(of, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), of.MAX_GLYPHS = 65535, of.addDynamicAttributes = rf;
        const lf = new Ps({
            "symbol-placement": new Bs(te.layout_symbol["symbol-placement"]),
            "symbol-spacing": new Bs(te.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new Bs(te.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new Es(te.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new Bs(te.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new Bs(te.layout_symbol["icon-allow-overlap"]),
            "icon-ignore-placement": new Bs(te.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new Bs(te.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new Bs(te.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new Es(te.layout_symbol["icon-size"]),
            "icon-text-fit": new Bs(te.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new Bs(te.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new Es(te.layout_symbol["icon-image"]),
            "icon-rotate": new Es(te.layout_symbol["icon-rotate"]),
            "icon-padding": new Bs(te.layout_symbol["icon-padding"]),
            "icon-keep-upright": new Bs(te.layout_symbol["icon-keep-upright"]),
            "icon-offset": new Es(te.layout_symbol["icon-offset"]),
            "icon-anchor": new Es(te.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new Bs(te.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new Bs(te.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new Bs(te.layout_symbol["text-rotation-alignment"]),
            "text-field": new Es(te.layout_symbol["text-field"]),
            "text-font": new Es(te.layout_symbol["text-font"]),
            "text-size": new Es(te.layout_symbol["text-size"]),
            "text-max-width": new Es(te.layout_symbol["text-max-width"]),
            "text-line-height": new Es(te.layout_symbol["text-line-height"]),
            "text-letter-spacing": new Es(te.layout_symbol["text-letter-spacing"]),
            "text-justify": new Es(te.layout_symbol["text-justify"]),
            "text-radial-offset": new Es(te.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new Bs(te.layout_symbol["text-variable-anchor"]),
            "text-anchor": new Es(te.layout_symbol["text-anchor"]),
            "text-max-angle": new Bs(te.layout_symbol["text-max-angle"]),
            "text-writing-mode": new Bs(te.layout_symbol["text-writing-mode"]),
            "text-rotate": new Es(te.layout_symbol["text-rotate"]),
            "text-padding": new Bs(te.layout_symbol["text-padding"]),
            "text-keep-upright": new Bs(te.layout_symbol["text-keep-upright"]),
            "text-transform": new Es(te.layout_symbol["text-transform"]),
            "text-offset": new Es(te.layout_symbol["text-offset"]),
            "text-allow-overlap": new Bs(te.layout_symbol["text-allow-overlap"]),
            "text-ignore-placement": new Bs(te.layout_symbol["text-ignore-placement"]),
            "text-optional": new Bs(te.layout_symbol["text-optional"])
        });
        var uf = {
            paint: new Ps({
                "icon-opacity": new Es(te.paint_symbol["icon-opacity"]),
                "icon-color": new Es(te.paint_symbol["icon-color"]),
                "icon-halo-color": new Es(te.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new Es(te.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new Es(te.paint_symbol["icon-halo-blur"]),
                "icon-translate": new Bs(te.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new Bs(te.paint_symbol["icon-translate-anchor"]),
                "text-opacity": new Es(te.paint_symbol["text-opacity"]),
                "text-color": new Es(te.paint_symbol["text-color"], {
                    runtimeType: pe,
                    getOverride: (t1)=>t1.textColor,
                    hasOverride: (t1)=>!!t1.textColor
                }),
                "text-halo-color": new Es(te.paint_symbol["text-halo-color"]),
                "text-halo-width": new Es(te.paint_symbol["text-halo-width"]),
                "text-halo-blur": new Es(te.paint_symbol["text-halo-blur"]),
                "text-translate": new Bs(te.paint_symbol["text-translate"]),
                "text-translate-anchor": new Bs(te.paint_symbol["text-translate-anchor"])
            }),
            layout: lf
        };
        class cf {
            constructor(t1){
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : le, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e1 = this.defaultValue.property.overrides;
                    if (e1 && e1.hasOverride(t1.formattedSection)) return e1.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        Ji(cf, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        class hf extends ro {
            constructor(t1){
                super(t1, uf);
            }
            recalculate(t1, e1) {
                super.recalculate(t1, e1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t1 = [];
                    for (const e1 of r)t1.indexOf(e1) < 0 && t1.push(e1);
                    this.layout._values["text-writing-mode"] = t1;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getValueAndResolveTokens(t1, e1, r, n) {
                const i = this.layout.get(t1).evaluate(e1, {}, r, n), s = this._unevaluatedLayout._values[t1];
                return s.isDataDriven() || Jn(s.value) || !i ? i : function(t1, e1) {
                    return e1.replace(/{([^{}]+)}/g, (e1, r)=>r in t1 ? String(t1[r]) : "");
                }(e1.properties, i);
            }
            createBucket(t1) {
                return new of(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t1 of uf.paint.overridableProperties){
                    if (!hf.hasPaintOverride(this.layout, t1)) continue;
                    const e1 = this.paint.get(t1), r = new cf(e1), n = new Xn(r, e1.property.specification);
                    let i = null;
                    i = "constant" === e1.value.kind || "source" === e1.value.kind ? new Yn("source", n) : new Wn("composite", n, e1.value.zoomStops, e1.value._interpolationType), this.paint._values[t1] = new Ts(e1.property, i, e1.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e1, r) {
                return !(!this.layout || e1.isDataDriven() || r.isDataDriven()) && hf.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e1) {
                const r = t1.get("text-field"), n = uf.paint.properties[e1];
                let i = !1;
                const s = (t1)=>{
                    for (const e1 of t1)if (n.overrides && n.overrides.hasOverride(e1)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof De) s(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e1)=>{
                        i || (e1 instanceof je && Re(e1.value) === me ? s(e1.value.sections) : e1 instanceof Ze ? s(e1.sections) : e1.eachChild(t1));
                    }, e1 = r.value;
                    e1._styleExpression && t1(e1._styleExpression.expression);
                }
                return i;
            }
            getProgramConfiguration(t1) {
                return new Xa(this, t1);
            }
        }
        var pf = {
            paint: new Ps({
                "background-color": new Bs(te.paint_background["background-color"]),
                "background-pattern": new Bs(te.paint_background["background-pattern"]),
                "background-opacity": new Bs(te.paint_background["background-opacity"])
            })
        }, df = {
            paint: new Ps({
                "raster-opacity": new Bs(te.paint_raster["raster-opacity"]),
                "raster-hue-rotate": new Bs(te.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new Bs(te.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new Bs(te.paint_raster["raster-brightness-max"]),
                "raster-saturation": new Bs(te.paint_raster["raster-saturation"]),
                "raster-contrast": new Bs(te.paint_raster["raster-contrast"]),
                "raster-resampling": new Bs(te.paint_raster["raster-resampling"]),
                "raster-fade-duration": new Bs(te.paint_raster["raster-fade-duration"])
            })
        };
        class ff extends ro {
            constructor(t1){
                super(t1, {}), this.implementation = t1;
            }
            is3D() {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            isLayerDraped() {
                return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {}
            onAdd(t1) {
                this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
            }
            onRemove(t1) {
                this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
            }
        }
        var yf = {
            paint: new Ps({
                "sky-type": new Bs(te.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new Bs(te.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new Bs(te.paint_sky["sky-atmosphere-sun-intensity"]),
                "sky-gradient-center": new Bs(te.paint_sky["sky-gradient-center"]),
                "sky-gradient-radius": new Bs(te.paint_sky["sky-gradient-radius"]),
                "sky-gradient": new Cs(te.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new Bs(te.paint_sky["sky-atmosphere-halo-color"]),
                "sky-atmosphere-color": new Bs(te.paint_sky["sky-atmosphere-color"]),
                "sky-opacity": new Bs(te.paint_sky["sky-opacity"])
            })
        };
        function mf(t1, e1, r) {
            const n = [
                0,
                0,
                1
            ], i = Ko([]);
            return Jo(i, i, r ? -w(t1) + Math.PI : w(t1)), Xo(i, i, -w(e1)), Ro(n, n, i), Do(n, n);
        }
        const gf = {
            circle: class extends ro {
                constructor(t1){
                    super(t1, Tu);
                }
                createBucket(t1) {
                    return new cu(t1);
                }
                queryRadius(t1) {
                    const e1 = t1;
                    return Au("circle-radius", this, e1) + Au("circle-stroke-width", this, e1) + Su(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, s, a, o) {
                    const l = Iu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), u = this.paint.get("circle-radius").evaluate(e1, r) + this.paint.get("circle-stroke-width").evaluate(e1, r);
                    return zu(t1, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new Xa(this, t1);
                }
            },
            heatmap: class extends ro {
                createBucket(t1) {
                    return new Du(t1);
                }
                constructor(t1){
                    super(t1, $u), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = ju({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                queryRadius(t1) {
                    return Au("heatmap-radius", this, t1);
                }
                queryIntersectsFeature(t1, e1, r, n, i, s, a, o) {
                    const l = this.paint.get("heatmap-radius").evaluate(e1, r);
                    return zu(t1, n, s, a, o, !0, !0, new x(0, 0), l);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new Xa(this, t1);
                }
            },
            hillshade: class extends ro {
                constructor(t1){
                    super(t1, Ou);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
            },
            fill: class extends ro {
                constructor(t1){
                    super(t1, zc);
                }
                getProgramIds() {
                    const t1 = this.paint.get("fill-pattern"), e1 = t1 && t1.constantOr(1), r = [
                        e1 ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r.push(e1 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }
                getProgramConfiguration(t1) {
                    return new Xa(this, t1);
                }
                recalculate(t1, e1) {
                    super.recalculate(t1, e1);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new Mc(t1);
                }
                queryRadius() {
                    return Su(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, s) {
                    return !t1.queryGeometry.isAboveHorizon && du(ku(t1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return !0;
                }
            },
            "fill-extrusion": class extends ro {
                constructor(t1){
                    super(t1, ch);
                }
                createBucket(t1) {
                    return new th(t1);
                }
                queryRadius() {
                    return Su(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new Xa(this, t1);
                }
                queryIntersectsFeature(t1, e1, r, n, i, s, a, o, l) {
                    const u = Iu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), c = this.paint.get("fill-extrusion-height").evaluate(e1, r), h = this.paint.get("fill-extrusion-base").evaluate(e1, r), p = [
                        0,
                        0
                    ], d = o && s.elevation, f = s.elevation ? s.elevation.exaggeration() : 1, y = t1.tile.getBucket(this);
                    if (d && y instanceof th) {
                        const t1 = y.centroidVertexArray, e1 = l + 1;
                        e1 < t1.length && (p[0] = t1.geta_centroid_pos0(e1), p[1] = t1.geta_centroid_pos1(e1));
                    }
                    if (0 === p[0] && 1 === p[1]) return !1;
                    "globe" === s.projection.name && (n = lh([
                        n
                    ], [
                        new x(0, 0),
                        new x(ao, ao)
                    ], t1.tileID.canonical).map((t1)=>t1.polygon).flat());
                    const m = d ? o : null, [g, v] = function(t1, e1, r, n, i, s, a, o, l, u, c) {
                        return "globe" === t1.projection.name ? function(t1, e1, r, n, i, s, a, o, l, u, c) {
                            const h = [], p = [], d = t1.projection.upVectorScale(c, t1.center.lat, t1.worldSize).metersToTile, f = [
                                0,
                                0,
                                0,
                                1
                            ], y = [
                                0,
                                0,
                                0,
                                1
                            ], m = (t1, e1, r, n)=>{
                                t1[0] = e1, t1[1] = r, t1[2] = n, t1[3] = 1;
                            }, g = oh();
                            r > 0 && (r += g), n += g;
                            for (const g of e1){
                                const e1 = [], x = [];
                                for (const h of g){
                                    const p = h.x + i.x, g = h.y + i.y, v = t1.projection.projectTilePoint(p, g, c), b = t1.projection.upVector(c, h.x, h.y);
                                    let w = r, _ = n;
                                    if (a) {
                                        const t1 = vh(p, g, r, n, a, o, l, u);
                                        w += t1.base, _ += t1.top;
                                    }
                                    0 !== r ? m(f, v.x + b[0] * d * w, v.y + b[1] * d * w, v.z + b[2] * d * w) : m(f, v.x, v.y, v.z), m(y, v.x + b[0] * d * _, v.y + b[1] * d * _, v.z + b[2] * d * _), Fo(f, f, s), Fo(y, y, s), e1.push(new mh(f[0], f[1], f[2])), x.push(new mh(y[0], y[1], y[2]));
                                }
                                h.push(e1), p.push(x);
                            }
                            return [
                                h,
                                p
                            ];
                        }(t1, e1, r, n, i, s, a, o, l, u, c) : a ? function(t1, e1, r, n, i, s, a, o, l) {
                            const u = [], c = [], h = [
                                0,
                                0,
                                0,
                                1
                            ];
                            for (const p of t1){
                                const t1 = [], d = [];
                                for (const u of p){
                                    const c = u.x + n.x, p = u.y + n.y, f = vh(c, p, e1, r, s, a, o, l);
                                    h[0] = c, h[1] = p, h[2] = f.base, h[3] = 1, Go(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const y = new mh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    h[0] = c, h[1] = p, h[2] = f.top, h[3] = 1, Go(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const m = new mh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    t1.push(y), d.push(m);
                                }
                                u.push(t1), c.push(d);
                            }
                            return [
                                u,
                                c
                            ];
                        }(e1, r, n, i, s, a, o, l, u) : function(t1, e1, r, n, i) {
                            const s = [], a = [], o = i[8] * e1, l = i[9] * e1, u = i[10] * e1, c = i[11] * e1, h = i[8] * r, p = i[9] * r, d = i[10] * r, f = i[11] * r;
                            for (const e1 of t1){
                                const t1 = [], r = [];
                                for (const s of e1){
                                    const e1 = s.x + n.x, a = s.y + n.y, y = i[0] * e1 + i[4] * a + i[12], m = i[1] * e1 + i[5] * a + i[13], g = i[2] * e1 + i[6] * a + i[14], x = i[3] * e1 + i[7] * a + i[15], v = y + o, b = m + l, w = g + u, _ = Math.max(x + c, 1e-5), A = y + h, S = m + p, k = g + d, I = Math.max(x + f, 1e-5);
                                    t1.push(new mh(v / _, b / _, w / _)), r.push(new mh(A / I, S / I, k / I));
                                }
                                s.push(t1), a.push(r);
                            }
                            return [
                                s,
                                a
                            ];
                        }(e1, r, n, i, s);
                    }(s, n, h, c, u, a, m, p, f, s.center.lat, t1.tileID.canonical), b = t1.queryGeometry;
                    return function(t1, e1, r) {
                        let n = 1 / 0;
                        du(r, e1) && (n = xh(r, e1[0]));
                        for(let i = 0; i < e1.length; i++){
                            const s = e1[i], a = t1[i];
                            for(let t1 = 0; t1 < s.length - 1; t1++){
                                const e1 = s[t1], i = [
                                    e1,
                                    s[t1 + 1],
                                    a[t1 + 1],
                                    a[t1],
                                    e1
                                ];
                                hu(r, i) && (n = Math.min(n, xh(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n;
                    }(g, v, b.isPointQuery() ? b.screenBounds : b.screenGeometry);
                }
            },
            line: class extends ro {
                constructor(t1){
                    super(t1, Th), this.gradientVersion = 0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    if ("line-gradient" === t1) {
                        const t1 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t1._styleExpression && t1._styleExpression.expression instanceof Br, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }
                recalculate(t1, e1) {
                    super.recalculate(t1, e1), this.paint._values["line-floorwidth"] = zh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new Ih(t1);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new Xa(this, t1);
                }
                queryRadius(t1) {
                    const e1 = t1, r = Bh(Au("line-width", this, e1), Au("line-gap-width", this, e1)), n = Au("line-offset", this, e1);
                    return r / 2 + Math.abs(n) + Su(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, s) {
                    if (t1.queryGeometry.isAboveHorizon) return !1;
                    const a = ku(t1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), o = t1.pixelToTileUnitsFactor / 2 * Bh(this.paint.get("line-width").evaluate(e1, r), this.paint.get("line-gap-width").evaluate(e1, r)), l = this.paint.get("line-offset").evaluate(e1, r);
                    return l && (n = function(t1, e1) {
                        const r = [], n = new x(0, 0);
                        for(let i = 0; i < t1.length; i++){
                            const s = t1[i], a = [];
                            for(let t1 = 0; t1 < s.length; t1++){
                                const r = s[t1], i = s[t1 + 1], o = 0 === t1 ? n : r.sub(s[t1 - 1])._unit()._perp(), l = t1 === s.length - 1 ? n : i.sub(r)._unit()._perp(), u = o._add(l)._unit();
                                u._mult(1 / (u.x * l.x + u.y * l.y)), a.push(u._mult(e1)._add(r));
                            }
                            r.push(a);
                        }
                        return r;
                    }(n, l * t1.pixelToTileUnitsFactor)), function(t1, e1, r) {
                        for(let n = 0; n < e1.length; n++){
                            const i = e1[n];
                            if (t1.length >= 3) {
                                for(let e1 = 0; e1 < i.length; e1++)if (bu(t1, i[e1])) return !0;
                            }
                            if (fu(t1, i, r)) return !0;
                        }
                        return !1;
                    }(a, n, o);
                }
                isTileClipped() {
                    return !0;
                }
            },
            symbol: hf,
            background: class extends ro {
                constructor(t1){
                    super(t1, pf);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
            },
            raster: class extends ro {
                constructor(t1){
                    super(t1, df);
                }
                getProgramIds() {
                    return [
                        "raster"
                    ];
                }
            },
            sky: class extends ro {
                constructor(t1){
                    super(t1, yf), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "sky-gradient" === t1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t1 && "sky-atmosphere-halo-color" !== t1 && "sky-atmosphere-color" !== t1 && "sky-atmosphere-sun-intensity" !== t1 || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = ju({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t1) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e1 = t1.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e1.azimuthal || this._lightPosition.polar !== e1.polar;
                    }
                    return !1;
                }
                getCenter(t1, e1) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = t1.style.light, s = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && N("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? mf(s.azimuthal, 90 - s.polar, e1) : mf(r[0], 90 - r[1], e1);
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return mf(r[0], 90 - r[1], e1);
                }
                is3D() {
                    return !1;
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t1) {
                    this._skyboxInvalidated = !1, this._lightPosition = t1.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t1 = this.paint.get("sky-type");
                    return "atmosphere" === t1 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t1 ? [
                        "skyboxGradient"
                    ] : null;
                }
            }
        };
        class xf {
            constructor(t1, e1, r, n){
                this.context = t1, this.format = r, this.texture = t1.gl.createTexture(), this.update(e1, n);
            }
            update(t1, r, n) {
                const { width: i, height: s } = t1, { context: a } = this, { gl: o } = a, { HTMLImageElement: l, HTMLCanvasElement: u, HTMLVideoElement: c, ImageData: h, ImageBitmap: p } = e1;
                if (o.bindTexture(o.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i && this.size[1] === s) {
                    const { x: e1, y: r } = n || {
                        x: 0,
                        y: 0
                    };
                    t1 instanceof l || t1 instanceof u || t1 instanceof c || t1 instanceof h || p && t1 instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e1, r, o.RGBA, o.UNSIGNED_BYTE, t1) : o.texSubImage2D(o.TEXTURE_2D, 0, e1, r, i, s, o.RGBA, o.UNSIGNED_BYTE, t1.data);
                } else this.size = [
                    i,
                    s
                ], t1 instanceof l || t1 instanceof u || t1 instanceof c || t1 instanceof h || p && t1 instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t1) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, s, 0, this.format, o.UNSIGNED_BYTE, t1.data);
                this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);
            }
            bind(t1, e1) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_2D, this.texture), t1 !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t1 === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t1), this.filter = t1), e1 !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e1), this.wrap = e1);
            }
            isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        class vf {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{};
            }
        }
        class bf {
            constructor(){
                this.tasks = {}, this.taskQueue = [], R([
                    "process"
                ], this), this.invoker = new vf(this.process), this.nextId = 0;
            }
            add(t1, e1) {
                const r = this.nextId++, n = function({ type: t1, isSymbolTile: e1, zoom: r }) {
                    return r = r || 0, "message" === t1 ? 0 : "maybePrepare" !== t1 || e1 ? "parseTile" !== t1 || e1 ? "parseTile" === t1 && e1 ? 300 - r : "maybePrepare" === t1 && e1 ? 400 - r : 500 : 200 - r : 100 - r;
                }(e1);
                if (0 === n) {
                    K();
                    t1();
                    return {
                        cancel: ()=>{}
                    };
                }
                return this.tasks[r] = {
                    fn: t1,
                    metadata: e1,
                    priority: n,
                    id: r
                }, this.taskQueue.push(r), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r];
                    }
                };
            }
            process() {
                K();
                {
                    if (this.taskQueue = this.taskQueue.filter((t1)=>!!this.tasks[t1]), !this.taskQueue.length) return;
                    const t1 = this.pick();
                    if (null === t1) return;
                    const e1 = this.tasks[t1];
                    if (delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), !e1) return;
                    e1.fn();
                }
            }
            pick() {
                let t1 = null, e1 = 1 / 0;
                for(let r = 0; r < this.taskQueue.length; r++){
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e1 && (e1 = n.priority, t1 = r);
                }
                if (null === t1) return null;
                const r = this.taskQueue[t1];
                return this.taskQueue.splice(t1, 1), r;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class wf {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e1 = 0; e1 < t1.length; e1++){
                    const r = t1[e1];
                    this._stringToNumber[r] = e1, this._numberToString[e1] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                return this._numberToString[t1];
            }
        }
        const _f = [
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class Af {
            constructor(t1, e1, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, this._z = e1, this._x = r, this._y = n, this.properties = t1.properties, this.id = i;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    type: "Feature",
                    state: void 0,
                    geometry: this.geometry,
                    properties: this.properties
                };
                void 0 !== this.id && (t1.id = this.id);
                for (const e1 of _f)void 0 !== this[e1] && (t1[e1] = this[e1]);
                return t1;
            }
        }
        const Sf = 32, kf = 33, If = new Uint16Array(8184);
        for(let t1 = 0; t1 < 2046; t1++){
            let e1 = t1 + 2, r = 0, n = 0, i = 0, s = 0, a = 0, o = 0;
            for(1 & e1 ? i = s = a = Sf : r = n = o = Sf; (e1 >>= 1) > 1;){
                const t1 = r + i >> 1, l = n + s >> 1;
                1 & e1 ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t1, o = l;
            }
            const l = 4 * t1;
            If[l + 0] = r, If[l + 1] = n, If[l + 2] = i, If[l + 3] = s;
        }
        const Mf = new Uint16Array(2178), Tf = new Uint8Array(1089), zf = new Uint16Array(1089);
        function Bf(t1) {
            return 0 === t1 ? -0.03125 : 32 === t1 ? .03125 : 0;
        }
        var Ef = Rs([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        const Cf = {
            type: 2,
            extent: ao,
            loadGeometry: ()=>[
                    [
                        new x(0, 0),
                        new x(ao + 1, 0),
                        new x(ao + 1, ao + 1),
                        new x(0, ao + 1),
                        new x(0, 0)
                    ]
                ]
        };
        class Pf {
            constructor(t1, e1, r, n, i){
                this.tileID = t1, this.uid = D(), this.uses = 0, this.tileSize = e1, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection);
            }
            registerFadeDuration(t1) {
                const e1 = t1 + this.timeAdded;
                e1 < Xt.now() || this.fadeEndTime && e1 < this.fadeEndTime || (this.fadeEndTime = e1);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = Bd(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t1, e1, r) {
                if (this.unloadVectorData(), this.state = "loaded", t1) {
                    t1.featureIndex && (this.latestFeatureIndex = t1.featureIndex, t1.rawTileData ? (this.latestRawTileData = t1.rawTileData, this.latestFeatureIndex.rawTileData = t1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t1.collisionBoxArray, this.buckets = function(t1, e1) {
                        const r = {};
                        if (!e1) return r;
                        for (const n of t1){
                            const t1 = n.layerIds.map((t1)=>e1.getLayer(t1)).filter(Boolean);
                            if (0 !== t1.length) {
                                n.layers = t1, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((e1)=>t1.filter((t1)=>t1.id === e1)[0]));
                                for (const e1 of t1)r[e1.id] = n;
                            }
                        }
                        return r;
                    }(t1.buckets, e1.style), this.hasSymbolBuckets = !1;
                    for(const t1 in this.buckets){
                        const e1 = this.buckets[t1];
                        if (e1 instanceof of) {
                            if (this.hasSymbolBuckets = !0, !r) break;
                            e1.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t1 in this.buckets){
                        const e1 = this.buckets[t1];
                        if (e1 instanceof of && e1.hasRTLText) {
                            this.hasRTLText = !0, bs.isLoading() || bs.isLoaded() || "deferred" !== xs() || vs();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const t1 in this.buckets){
                        const r = this.buckets[t1];
                        this.queryPadding = Math.max(this.queryPadding, e1.style.getLayer(t1).queryRadius(r));
                    }
                    t1.imageAtlas && (this.imageAtlas = t1.imageAtlas), t1.glyphAtlasImage && (this.glyphAtlasImage = t1.glyphAtlasImage), t1.lineAtlas && (this.lineAtlas = t1.lineAtlas);
                } else this.collisionBoxArray = new pa;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const t1 in this.buckets)this.buckets[t1].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            getBucket(t1) {
                return this.buckets[t1.id];
            }
            upload(t1) {
                for(const e1 in this.buckets){
                    const r = this.buckets[e1];
                    r.uploadPending() && r.upload(t1);
                }
                const e1 = t1.gl;
                this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new xf(t1, this.imageAtlas.image, e1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new xf(t1, this.glyphAtlasImage, e1.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new xf(t1, this.lineAtlas.image, e1.ALPHA), this.lineAtlas.uploaded = !0);
            }
            prepare(t1) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t1, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t1, e1, r, n, i, s, a, o) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                    tileResult: n,
                    pixelPosMatrix: a,
                    transform: s,
                    params: i,
                    tileTransform: this.tileTransform
                }, t1, e1, r) : {};
            }
            querySourceFeatures(t1, e1) {
                const r = this.latestFeatureIndex;
                if (!r || !r.rawTileData) return;
                const n = r.loadVTLayers(), i = e1 ? e1.sourceLayer : "", s = n._geojsonTileLayer || n[i];
                if (!s) return;
                const a = hi(e1 && e1.filter), { z: o, x: l, y: u } = this.tileID.canonical, c = {
                    z: o,
                    x: l,
                    y: u
                };
                for(let e1 = 0; e1 < s.length; e1++){
                    const n = s.feature(e1);
                    if (a.needGeometry) {
                        const t1 = ou(n, !0);
                        if (!a.filter(new ws(this.tileID.overscaledZ), t1, this.tileID.canonical)) continue;
                    } else if (!a.filter(new ws(this.tileID.overscaledZ), n)) continue;
                    const h = r.getId(n, i), p = new Af(n, o, l, u, h);
                    p.tile = c, t1.push(p);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t1) {
                const e1 = this.expirationTime;
                if (t1.cacheControl) {
                    const e1 = X(t1.cacheControl);
                    e1["max-age"] && (this.expirationTime = Date.now() + 1e3 * e1["max-age"]);
                } else t1.expires && (this.expirationTime = new Date(t1.expires).getTime());
                if (this.expirationTime) {
                    const t1 = Date.now();
                    let r = !1;
                    if (this.expirationTime > t1) r = !1;
                    else if (e1) {
                        if (this.expirationTime < e1) r = !0;
                        else {
                            const n = this.expirationTime - e1;
                            n ? this.expirationTime = t1 + Math.max(n, 3e4) : r = !0;
                        }
                    } else r = !0;
                    r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t1, e1) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t1).length || !e1) return;
                const r = this.latestFeatureIndex.loadVTLayers(), n = e1.style.listImages();
                for(const i in this.buckets){
                    if (!e1.style.hasLayer(i)) continue;
                    const s = this.buckets[i], a = s.layers[0].sourceLayer || "_geojsonTileLayer", o = r[a], l = t1[a];
                    if (!o || !l || 0 === Object.keys(l).length) continue;
                    if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof Ih || s instanceof Mc) {
                        const t1 = e1.style._getSourceCache(s.layers[0].source);
                        e1._terrain && e1._terrain.enabled && t1 && s.programConfigurations.needsUpload && e1._terrain._clearRenderCacheForTile(t1.id, this.tileID);
                    }
                    const u = e1 && e1.style && e1.style.getLayer(i);
                    u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Xt.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t1) {
                this.symbolFadeHoldUntil = Xt.now() + t1;
            }
            setTexture(t1, e1) {
                const r = e1.context, n = r.gl;
                this.texture = this.texture || e1.getTileTexture(t1.width), this.texture ? this.texture.update(t1, {
                    useMipmap: !0
                }) : (this.texture = new xf(r, t1, n.RGBA, {
                    useMipmap: !0
                }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
            }
            setDependencies(t1, e1) {
                const r = {};
                for (const t1 of e1)r[t1] = !0;
                this.dependencies[t1] = r;
            }
            hasDependency(t1, e1) {
                for (const r of t1){
                    const t1 = this.dependencies[r];
                    if (t1) {
                        for (const r of e1)if (t1[r]) return !0;
                    }
                }
                return !1;
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t1, e1) {
                if (!e1 || "mercator" === e1.name || this._tileDebugBuffer) return;
                const r = au(Cf, this.tileID.canonical, this.tileTransform)[0], n = new $s, i = new ua;
                for(let t1 = 0; t1 < r.length; t1++){
                    const { x: e1, y: s } = r[t1];
                    n.emplaceBack(e1, s), i.emplaceBack(t1);
                }
                i.emplaceBack(0), this._tileDebugIndexBuffer = t1.createIndexBuffer(i), this._tileDebugBuffer = t1.createVertexBuffer(n, tl.members), this._tileDebugSegments = so.simpleSegment(0, 0, n.length, i.length);
            }
            _makeTileBoundsBuffers(t1, e1) {
                if (this._tileBoundsBuffer || !e1 || "mercator" === e1.name) return;
                const r = au(Cf, this.tileID.canonical, this.tileTransform)[0];
                let n, i;
                if (this.isRaster) {
                    const t1 = function(t1, e1) {
                        const r = Bd(t1, e1), n = Math.pow(2, t1.z);
                        for(let i = 0; i < kf; i++)for(let s = 0; s < kf; s++){
                            const a = Kl((t1.x + (s + Bf(s)) / Sf) / n), o = Xl((t1.y + (i + Bf(i)) / Sf) / n), l = e1.project(a, o), u = i * kf + s;
                            Mf[2 * u + 0] = Math.round((l.x * r.scale - r.x) * ao), Mf[2 * u + 1] = Math.round((l.y * r.scale - r.y) * ao);
                        }
                        Tf.fill(0), zf.fill(0);
                        for(let t1 = 2045; t1 >= 0; t1--){
                            const e1 = 4 * t1, r = If[e1 + 0], n = If[e1 + 1], i = If[e1 + 2], s = If[e1 + 3], a = r + i >> 1, o = n + s >> 1, l = a + o - n, u = o + r - a, c = n * kf + r, h = s * kf + i, p = o * kf + a, d = Math.hypot((Mf[2 * c + 0] + Mf[2 * h + 0]) / 2 - Mf[2 * p + 0], (Mf[2 * c + 1] + Mf[2 * h + 1]) / 2 - Mf[2 * p + 1]) >= 16;
                            Tf[p] = Tf[p] || (d ? 1 : 0), t1 < 1022 && (Tf[p] = Tf[p] || Tf[(n + u >> 1) * kf + (r + l >> 1)] || Tf[(s + u >> 1) * kf + (i + l >> 1)]);
                        }
                        const i = new Os, s = new ra;
                        let a = 0;
                        function o(t1, e1) {
                            const r = e1 * kf + t1;
                            return 0 === zf[r] && (i.emplaceBack(Mf[2 * r + 0], Mf[2 * r + 1], t1 * ao / Sf, e1 * ao / Sf), zf[r] = ++a), zf[r] - 1;
                        }
                        function l(t1, e1, r, n, i, a) {
                            const u = t1 + r >> 1, c = e1 + n >> 1;
                            if (Math.abs(t1 - i) + Math.abs(e1 - a) > 1 && Tf[c * kf + u]) l(i, a, t1, e1, u, c), l(r, n, i, a, u, c);
                            else {
                                const l = o(t1, e1), u = o(r, n), c = o(i, a);
                                s.emplaceBack(l, u, c);
                            }
                        }
                        return l(0, 0, Sf, Sf, Sf, 0), l(Sf, Sf, 0, 0, 0, Sf), {
                            vertices: i,
                            indices: s
                        };
                    }(this.tileID.canonical, e1);
                    n = t1.vertices, i = t1.indices;
                } else {
                    n = new Os, i = new ra;
                    for (const { x: t1, y: e1 } of r)n.emplaceBack(t1, e1, 0, 0);
                    const t1 = xc(n.int16, void 0, 4);
                    for(let e1 = 0; e1 < t1.length; e1 += 3)i.emplaceBack(t1[e1], t1[e1 + 1], t1[e1 + 2]);
                }
                this._tileBoundsBuffer = t1.createVertexBuffer(n, Ef.members), this._tileBoundsIndexBuffer = t1.createIndexBuffer(i), this._tileBoundsSegments = so.simpleSegment(0, 0, n.length, i.length);
            }
            _makeGlobeTileDebugBuffers(t1, e1) {
                const r = e1.projection;
                if (!r || "globe" !== r.name || e1.freezeTileCoverage) return;
                const n = this.tileID.canonical, i = Bl(bl(n, e1)), s = Pl(e1.zoom);
                let a;
                s > 0 && (a = fo(new Float64Array(16), e1.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t1, n, e1, i, a, s), this._makeGlobeTileDebugTextBuffer(t1, n, e1, i, a, s);
            }
            _globePoint(t1, e1, r, n, i, s, a) {
                let o = Ml(t1, e1, r);
                if (s) {
                    const i = 1 << r.z, l = Nl(n.center.lng), u = Gl(n.center.lat), c = (r.x + .5) / i - l;
                    let h = 0;
                    c > .5 ? h = -1 : c < -0.5 && (h = 1);
                    let p = (t1 / ao + r.x) / i + h, d = (e1 / ao + r.y) / i;
                    p = (p - l) * n._pixelsPerMercatorPixel + l, d = (d - u) * n._pixelsPerMercatorPixel + u;
                    const f = [
                        p * n.worldSize,
                        d * n.worldSize,
                        0
                    ];
                    Fo(f, f, s), o = vl(o, f, a);
                }
                return Fo(o, o, i);
            }
            _makeGlobeTileDebugBorderBuffer(t1, e1, r, n, i, s) {
                const a = new $s, o = new ua, l = new js, u = (t1, u, c, h, p)=>{
                    const d = (c - t1) / (p - 1), f = (h - u) / (p - 1), y = a.length;
                    for(let c = 0; c < p; c++){
                        const h = t1 + c * d, p = u + c * f;
                        a.emplaceBack(h, p);
                        const m = this._globePoint(h, p, e1, r, n, i, s);
                        l.emplaceBack(m[0], m[1], m[2]), o.emplaceBack(y + c);
                    }
                }, c = ao;
                u(0, 0, c, 0, 16), u(c, 0, c, c, 16), u(c, c, 0, c, 16), u(0, c, 0, 0, 16), this._tileDebugIndexBuffer = t1.createIndexBuffer(o), this._tileDebugBuffer = t1.createVertexBuffer(a, tl.members), this._globeTileDebugBorderBuffer = t1.createVertexBuffer(l, Qo.members), this._tileDebugSegments = so.simpleSegment(0, 0, a.length, o.length);
            }
            _makeGlobeTileDebugTextBuffer(t1, e1, r, n, i, s) {
                const a = ao / 4, o = new $s, l = new ra, u = new js, c = 25;
                l.reserve(32), o.reserve(c), u.reserve(c);
                const h = (t1, e1)=>c * t1 + e1;
                for(let t1 = 0; t1 < c; t1++){
                    const l = t1 * a;
                    for(let t1 = 0; t1 < c; t1++){
                        const c = t1 * a;
                        o.emplaceBack(c, l);
                        const h = this._globePoint(c, l, e1, r, n, i, s);
                        u.emplaceBack(h[0], h[1], h[2]);
                    }
                }
                for(let t1 = 0; t1 < 4; t1++)for(let e1 = 0; e1 < 4; e1++){
                    const r = h(t1, e1), n = h(t1, e1 + 1), i = h(t1 + 1, e1), s = h(t1 + 1, e1 + 1);
                    l.emplaceBack(r, n, i), l.emplaceBack(i, n, s);
                }
                this._tileDebugTextIndexBuffer = t1.createIndexBuffer(l), this._tileDebugTextBuffer = t1.createVertexBuffer(o, tl.members), this._globeTileDebugTextBuffer = t1.createVertexBuffer(u, Qo.members), this._tileDebugTextSegments = so.simpleSegment(0, 0, c, 32);
            }
        }
        class Df {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t1, e1, r) {
                const n = String(e1);
                if (this.stateChanges[t1] = this.stateChanges[t1] || {}, this.stateChanges[t1][n] = this.stateChanges[t1][n] || {}, C(this.stateChanges[t1][n], r), null === this.deletedStates[t1]) {
                    this.deletedStates[t1] = {};
                    for(const e1 in this.state[t1])e1 !== n && (this.deletedStates[t1][e1] = null);
                } else if (this.deletedStates[t1] && null === this.deletedStates[t1][n]) {
                    this.deletedStates[t1][n] = {};
                    for(const e1 in this.state[t1][n])r[e1] || (this.deletedStates[t1][n][e1] = null);
                } else for(const e1 in r)this.deletedStates[t1] && this.deletedStates[t1][n] && null === this.deletedStates[t1][n][e1] && delete this.deletedStates[t1][n][e1];
            }
            removeFeatureState(t1, e1, r) {
                if (null === this.deletedStates[t1]) return;
                const n = String(e1);
                if (this.deletedStates[t1] = this.deletedStates[t1] || {}, r && void 0 !== e1) null !== this.deletedStates[t1][n] && (this.deletedStates[t1][n] = this.deletedStates[t1][n] || {}, this.deletedStates[t1][n][r] = null);
                else if (void 0 !== e1) {
                    if (this.stateChanges[t1] && this.stateChanges[t1][n]) for(r in this.deletedStates[t1][n] = {}, this.stateChanges[t1][n])this.deletedStates[t1][n][r] = null;
                    else this.deletedStates[t1][n] = null;
                } else this.deletedStates[t1] = null;
            }
            getState(t1, e1) {
                const r = String(e1), n = C({}, (this.state[t1] || {})[r], (this.stateChanges[t1] || {})[r]);
                if (null === this.deletedStates[t1]) return {};
                if (this.deletedStates[t1]) {
                    const r = this.deletedStates[t1][e1];
                    if (null === r) return {};
                    for(const t1 in r)delete n[t1];
                }
                return n;
            }
            initializeTileState(t1, e1) {
                t1.setFeatureState(this.state, e1);
            }
            coalesceChanges(t1, e1) {
                const r = {};
                for(const t1 in this.stateChanges){
                    this.state[t1] = this.state[t1] || {};
                    const e1 = {};
                    for(const r in this.stateChanges[t1])this.state[t1][r] || (this.state[t1][r] = {}), C(this.state[t1][r], this.stateChanges[t1][r]), e1[r] = this.state[t1][r];
                    r[t1] = e1;
                }
                for(const t1 in this.deletedStates){
                    this.state[t1] = this.state[t1] || {};
                    const e1 = {};
                    if (null === this.deletedStates[t1]) for(const r in this.state[t1])e1[r] = {}, this.state[t1][r] = {};
                    else for(const r in this.deletedStates[t1]){
                        if (null === this.deletedStates[t1][r]) this.state[t1][r] = {};
                        else if (this.state[t1][r]) for (const e1 of Object.keys(this.deletedStates[t1][r]))delete this.state[t1][r][e1];
                        e1[r] = this.state[t1][r];
                    }
                    r[t1] = r[t1] || {}, C(r[t1], e1);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for(const n in t1)t1[n].setFeatureState(r, e1);
            }
        }
        class Vf {
            constructor(t1){
                this.size = t1, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t1, e1) {
                const r = this.toIdx(t1, e1);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                };
            }
            isLeaf(t1, e1) {
                return this.leaves[this.toIdx(t1, e1)];
            }
            toIdx(t1, e1) {
                return e1 * this.size + t1;
            }
        }
        function Lf(t1, e1, r, n) {
            let i = 0, s = Number.MAX_VALUE;
            for(let a = 0; a < 3; a++)if (Math.abs(n[a]) < 1e-15) {
                if (r[a] < t1[a] || r[a] > e1[a]) return null;
            } else {
                const o = 1 / n[a];
                let l = (t1[a] - r[a]) * o, u = (e1[a] - r[a]) * o;
                if (l > u) {
                    const t1 = l;
                    l = u, u = t1;
                }
                if (l > i && (i = l), u < s && (s = u), i > s) return null;
            }
            return i;
        }
        function Ff(t1, e1, r, n, i, s, a, o, l, u, c) {
            const h = n - t1, p = i - e1, d = s - r, f = a - t1, y = o - e1, m = l - r, g = c[1] * m - c[2] * y, x = c[2] * f - c[0] * m, v = c[0] * y - c[1] * f, b = h * g + p * x + d * v;
            if (Math.abs(b) < 1e-15) return null;
            const w = 1 / b, _ = u[0] - t1, A = u[1] - e1, S = u[2] - r, k = (_ * g + A * x + S * v) * w;
            if (k < 0 || k > 1) return null;
            const I = A * d - S * p, M = S * h - _ * d, T = _ * p - A * h, z = (c[0] * I + c[1] * M + c[2] * T) * w;
            return z < 0 || k + z > 1 ? null : (f * I + y * M + m * T) * w;
        }
        function Rf(t1, e1, r) {
            return (t1 - e1) / (r - e1);
        }
        function Uf(t1, e1, r, n, i, s, a, o, l) {
            const u = 1 << r, c = s - n, h = a - i, p = (t1 + 1) / u * c + n, d = (e1 + 0) / u * h + i, f = (e1 + 1) / u * h + i;
            o[0] = (t1 + 0) / u * c + n, o[1] = d, l[0] = p, l[1] = f;
        }
        class $f {
            constructor(t1){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t1, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e1 = function(t1) {
                    const e1 = Math.ceil(Math.log2(t1.dim / 8)), r = [];
                    let n = Math.ceil(Math.pow(2, e1));
                    const i = 1 / n, s = (t1, e1, r, n, i)=>{
                        const s = n ? 1 : 0, a = (t1 + 1) * r - s, o = e1 * r, l = (e1 + 1) * r - s;
                        i[0] = t1 * r, i[1] = o, i[2] = a, i[3] = l;
                    };
                    let a = new Vf(n);
                    const o = [];
                    for(let e1 = 0; e1 < n * n; e1++){
                        s(e1 % n, Math.floor(e1 / n), i, !1, o);
                        const r = Of(o[0], o[1], t1), l = Of(o[2], o[1], t1), u = Of(o[2], o[3], t1), c = Of(o[0], o[3], t1);
                        a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
                    }
                    for(r.push(a), n /= 2; n >= 1; n /= 2){
                        const t1 = r[r.length - 1];
                        a = new Vf(n);
                        for(let e1 = 0; e1 < n * n; e1++){
                            s(e1 % n, Math.floor(e1 / n), 2, !0, o);
                            const r = t1.getElevation(o[0], o[1]), i = t1.getElevation(o[2], o[1]), l = t1.getElevation(o[2], o[3]), u = t1.getElevation(o[0], o[3]), c = t1.isLeaf(o[0], o[1]), h = t1.isLeaf(o[2], o[1]), p = t1.isLeaf(o[2], o[3]), d = t1.isLeaf(o[0], o[3]), f = Math.min(r.min, i.min, l.min, u.min), y = Math.max(r.max, i.max, l.max, u.max), m = c && h && p && d;
                            a.maximums.push(y), a.minimums.push(f), a.leaves.push(y - f <= 5 && m ? 1 : 0);
                        }
                        r.push(a);
                    }
                    return r;
                }(this.dem), r = e1.length - 1, n = e1[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e1, 0, 0, r, 0);
            }
            raycastRoot(t1, e1, r, n, i, s, a = 1) {
                return Lf([
                    t1,
                    e1,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * a
                ], i, s);
            }
            raycast(t1, e1, r, n, i, s, a = 1) {
                if (!this.nodeCount) return null;
                const o = this.raycastRoot(t1, e1, r, n, i, s, a);
                if (null == o) return null;
                const l = [], u = [], c = [], h = [], p = [
                    {
                        idx: 0,
                        t: o,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; p.length > 0;){
                    const { idx: o, t: d, nodex: f, nodey: y, depth: m } = p.pop();
                    if (this.leaves[o]) {
                        Uf(f, y, m, t1, e1, r, n, c, h);
                        const o = 1 << m, l = (f + 0) / o, u = (f + 1) / o, p = (y + 0) / o, g = (y + 1) / o, x = Of(l, p, this.dem) * a, v = Of(u, p, this.dem) * a, b = Of(u, g, this.dem) * a, w = Of(l, g, this.dem) * a, _ = Ff(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s), A = Ff(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s), S = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
                        if (S !== Number.MAX_VALUE) return S;
                        {
                            const t1 = Po([], i, s, d);
                            if (jf(x, v, w, b, Rf(t1[0], c[0], h[0]), Rf(t1[1], c[1], h[1])) >= t1[2]) return d;
                        }
                        continue;
                    }
                    let g = 0;
                    for(let p = 0; p < this._siblingOffset.length; p++){
                        Uf((f << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t1, e1, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;
                        const d = Lf(c, h, i, s);
                        if (null != d) {
                            const t1 = d;
                            l[p] = t1;
                            let e1 = !1;
                            for(let r = 0; r < g && !e1; r++)t1 >= l[u[r]] && (u.splice(r, 0, p), e1 = !0);
                            e1 || (u[g] = p), g++;
                        }
                    }
                    for(let t1 = 0; t1 < g; t1++){
                        const e1 = u[t1];
                        p.push({
                            idx: this.childOffsets[o] + e1,
                            t: l[e1],
                            nodex: (f << 1) + this._siblingOffset[e1][0],
                            nodey: (y << 1) + this._siblingOffset[e1][1],
                            depth: m + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t1, e1, r) {
                return this.minimums.push(t1), this.maximums.push(e1), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t1, e1, r, n, i) {
                if (1 === t1[n].isLeaf(e1, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s = n - 1, a = t1[s];
                let o = 0, l = 0;
                for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                    const n = 2 * e1 + this._siblingOffset[t1][0], i = 2 * r + this._siblingOffset[t1][1], s = a.getElevation(n, i), u = a.isLeaf(n, i), c = this._addNode(s.min, s.max, u);
                    u && (o |= 1 << t1), l || (l = c);
                }
                for(let n = 0; n < this._siblingOffset.length; n++)o & 1 << n || this._construct(t1, 2 * e1 + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }
        function jf(t1, e1, r, n, i, s) {
            return Er(Er(t1, r, s), Er(e1, n, s), i);
        }
        function Of(t1, e1, r) {
            const n = r.dim, i = M(t1 * n - .5, 0, n - 1), s = M(e1 * n - .5, 0, n - 1), a = Math.floor(i), o = Math.floor(s), l = Math.min(a + 1, n - 1), u = Math.min(o + 1, n - 1);
            return jf(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
        }
        const qf = {
            mapbox: [
                6553.6,
                25.6,
                .1,
                1e4
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        function Nf(t1, e1, r) {
            return (256 * t1 * 256 + 256 * e1 + r) / 10 - 1e4;
        }
        function Gf(t1, e1, r) {
            return 256 * t1 + e1 + r / 256 - 32768;
        }
        class Zf {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t1, e1, r, n = !1, i = !1){
                if (this.uid = t1, e1.height !== e1.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return N(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e1.height;
                const s = this.dim = e1.height - 2, a = new Uint32Array(e1.data.buffer);
                if (this.pixels = new Uint8Array(e1.data.buffer), this.encoding = r || "mapbox", this.borderReady = n, !n) {
                    for(let t1 = 0; t1 < s; t1++)a[this._idx(-1, t1)] = a[this._idx(0, t1)], a[this._idx(s, t1)] = a[this._idx(s - 1, t1)], a[this._idx(t1, -1)] = a[this._idx(t1, 0)], a[this._idx(t1, s)] = a[this._idx(t1, s - 1)];
                    a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();
                }
            }
            _buildQuadTree() {
                this._tree = new $f(this);
            }
            get(t1, e1, r = !1) {
                r && (t1 = M(t1, -1, this.dim), e1 = M(e1, -1, this.dim));
                const n = 4 * this._idx(t1, e1);
                return ("terrarium" === this.encoding ? Gf : Nf)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);
            }
            static getUnpackVector(t1) {
                return qf[t1];
            }
            get unpackVector() {
                return qf[this.encoding];
            }
            _idx(t1, e1) {
                if (t1 < -1 || t1 >= this.dim + 1 || e1 < -1 || e1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e1 + 1) * this.stride + (t1 + 1);
            }
            static pack(t1, e1) {
                const r = [
                    0,
                    0,
                    0,
                    0
                ], n = Zf.getUnpackVector(e1);
                let i = Math.floor((t1 + n[3]) / n[2]);
                return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }
            getPixels() {
                return new Uu({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t1, e1, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e1 * this.dim, i = e1 * this.dim + this.dim, s = r * this.dim, a = r * this.dim + this.dim;
                switch(e1){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        s = a - 1;
                        break;
                    case 1:
                        a = s + 1;
                }
                const o = -e1 * this.dim, l = -r * this.dim;
                for(let e1 = s; e1 < a; e1++)for(let r = n; r < i; r++){
                    const n = 4 * this._idx(r, e1), i = 4 * this._idx(r + o, e1 + l);
                    this.pixels[n + 0] = t1.pixels[i + 0], this.pixels[n + 1] = t1.pixels[i + 1], this.pixels[n + 2] = t1.pixels[i + 2], this.pixels[n + 3] = t1.pixels[i + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        Ji(Zf, "DEMData"), Ji($f, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        class Kf {
            constructor(t1, e1){
                this.max = t1, this.onRemove = e1, this.reset();
            }
            reset() {
                for(const t1 in this.data)for (const e1 of this.data[t1])e1.timeout && clearTimeout(e1.timeout), this.onRemove(e1.value);
                return this.data = {}, this.order = [], this;
            }
            add(t1, e1, r) {
                const n = t1.wrapped().key;
                void 0 === this.data[n] && (this.data[n] = []);
                const i = {
                    value: e1,
                    timeout: void 0
                };
                if (void 0 !== r && (i.timeout = setTimeout(()=>{
                    this.remove(t1, i);
                }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            has(t1) {
                return t1.wrapped().key in this.data;
            }
            getAndRemove(t1) {
                return this.has(t1) ? this._getAndRemoveByKey(t1.wrapped().key) : null;
            }
            _getAndRemoveByKey(t1) {
                const e1 = this.data[t1].shift();
                return e1.timeout && clearTimeout(e1.timeout), 0 === this.data[t1].length && delete this.data[t1], this.order.splice(this.order.indexOf(t1), 1), e1.value;
            }
            getByKey(t1) {
                const e1 = this.data[t1];
                return e1 ? e1[0].value : null;
            }
            get(t1) {
                return this.has(t1) ? this.data[t1.wrapped().key][0].value : null;
            }
            remove(t1, e1) {
                if (!this.has(t1)) return this;
                const r = t1.wrapped().key, n = void 0 === e1 ? 0 : this.data[r].indexOf(e1), i = this.data[r][n];
                return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;
            }
            setMaxSize(t1) {
                for(this.max = t1; this.order.length > this.max;){
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            filter(t1) {
                const e1 = [];
                for(const r in this.data)for (const n of this.data[r])t1(n.value) || e1.push(n);
                for (const t1 of e1)this.remove(t1.value.tileID, t1);
            }
        }
        class Xf {
            constructor(t1, e1, r){
                this.func = t1, this.mask = e1, this.range = r;
            }
        }
        Xf.ReadOnly = !1, Xf.ReadWrite = !0, Xf.disabled = new Xf(519, Xf.ReadOnly, [
            0,
            1
        ]);
        const Jf = 7680;
        class Hf {
            constructor(t1, e1, r, n, i, s){
                this.test = t1, this.ref = e1, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;
            }
        }
        Hf.disabled = new Hf({
            func: 519,
            mask: 0
        }, 0, 0, Jf, Jf, Jf);
        class Yf {
            constructor(t1, e1, r){
                this.blendFunction = t1, this.blendColor = e1, this.mask = r;
            }
        }
        Yf.Replace = [
            1,
            0
        ], Yf.disabled = new Yf(Yf.Replace, Ee.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), Yf.unblended = new Yf(Yf.Replace, Ee.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Yf.alphaBlended = new Yf([
            1,
            771
        ], Ee.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        const Wf = 1029, Qf = 2305;
        class ty {
            constructor(t1, e1, r){
                this.enable = t1, this.mode = e1, this.frontFace = r;
            }
        }
        ty.disabled = new ty(!1, Wf, Qf), ty.backCCW = new ty(!0, Wf, Qf), ty.backCW = new ty(!0, Wf, 2304), ty.frontCW = new ty(!0, 1028, 2304), ty.frontCCW = new ty(!0, 1028, Qf);
        class ey extends Qt {
            constructor(t1, e1, r){
                super(), this.id = t1, this._onlySymbols = r, e1.on("data", (t1)=>{
                    "source" === t1.dataType && "metadata" === t1.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t1.dataType && "content" === t1.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), e1.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = e1, this._tiles = {}, this._cache = new Kf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e1.minTileCacheSize, this._maxTileCacheSize = e1.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Df, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(t1) {
                this.map = t1, this._minTileCacheSize = void 0 === this._minTileCacheSize && t1 ? t1._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t1 ? t1._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const t1 in this._tiles){
                    const e1 = this._tiles[t1];
                    if ("loaded" !== e1.state && "errored" !== e1.state) return !1;
                }
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const t1 = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, t1 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(t1, e1) {
                return t1.isSymbolTile = this._onlySymbols, this._source.loadTile(t1, e1);
            }
            _unloadTile(t1) {
                if (this._source.unloadTile) return this._source.unloadTile(t1, ()=>{});
            }
            _abortTile(t1) {
                if (this._source.abortTile) return this._source.abortTile(t1, ()=>{});
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(t1) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const e1 in this._tiles){
                    const r = this._tiles[e1];
                    r.upload(t1), r.prepare(this.map.style.imageManager);
                }
            }
            getIds() {
                return E(this._tiles).map((t1)=>t1.tileID).sort(ry).map((t1)=>t1.key);
            }
            getRenderableIds(t1) {
                const e1 = [];
                for(const r in this._tiles)this._isIdRenderable(+r, t1) && e1.push(this._tiles[r]);
                return t1 ? e1.sort((t1, e1)=>{
                    const r = t1.tileID, n = e1.tileID, i = new x(r.canonical.x, r.canonical.y)._rotate(this.transform.angle), s = new x(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);
                    return r.overscaledZ - n.overscaledZ || s.y - i.y || s.x - i.x;
                }).map((t1)=>t1.tileID.key) : e1.map((t1)=>t1.tileID).sort(ry).map((t1)=>t1.key);
            }
            hasRenderableParent(t1) {
                const e1 = this.findLoadedParent(t1, 0);
                return !!e1 && this._isIdRenderable(e1.tileID.key);
            }
            _isIdRenderable(t1, e1) {
                return this._tiles[t1] && this._tiles[t1].hasData() && !this._coveredTiles[t1] && (e1 || !this._tiles[t1].holdingForFade());
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const t1 in this._tiles)"errored" !== this._tiles[t1].state && this._reloadTile(+t1, "reloading");
                }
            }
            _reloadTile(t1, e1) {
                const r = this._tiles[t1];
                r && ("loading" !== r.state && (r.state = e1), this._loadTile(r, this._tileLoaded.bind(this, r, t1, e1)));
            }
            _tileLoaded(t1, e1, r, n) {
                if (n) {
                    if (t1.state = "errored", 404 !== n.status) this._source.fire(new Wt(n, {
                        tile: t1
                    }));
                    else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const t1 = this.map.painter.terrain;
                        this.update(this.transform, t1.getScaledDemTileSize(), !0), t1.resetTileLookupCache(this.id);
                    } else this.update(this.transform);
                } else t1.timeAdded = Xt.now(), "expired" === r && (t1.refreshedUponExpiration = !0), this._setTileReloadTimer(e1, t1), "raster-dem" === this._source.type && t1.dem && this._backfillDEM(t1), this._state.initializeTileState(t1, this.map ? this.map.painter : null), this._source.fire(new Yt("data", {
                    dataType: "source",
                    tile: t1,
                    coord: t1.tileID,
                    sourceCacheId: this.id
                }));
            }
            _backfillDEM(t1) {
                const e1 = this.getRenderableIds();
                for(let n = 0; n < e1.length; n++){
                    const i = e1[n];
                    if (t1.neighboringTiles && t1.neighboringTiles[i]) {
                        const e1 = this.getTileByID(i);
                        r(t1, e1), r(e1, t1);
                    }
                }
                function r(t1, e1) {
                    if (!t1.dem || t1.dem.borderReady) return;
                    t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0;
                    let r = e1.tileID.canonical.x - t1.tileID.canonical.x;
                    const n = e1.tileID.canonical.y - t1.tileID.canonical.y, i = Math.pow(2, t1.tileID.canonical.z), s = e1.tileID.key;
                    0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e1.dem && t1.dem && (t1.dem.backfillBorder(e1.dem, r, n), t1.neighboringTiles && t1.neighboringTiles[s] && (t1.neighboringTiles[s].backfilled = !0)));
                }
            }
            getTile(t1) {
                return this.getTileByID(t1.key);
            }
            getTileByID(t1) {
                return this._tiles[t1];
            }
            _retainLoadedChildren(t1, e1, r, n) {
                for(const i in this._tiles){
                    let s = this._tiles[i];
                    if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e1 || s.tileID.overscaledZ > r) continue;
                    let a = s.tileID;
                    for(; s && s.tileID.overscaledZ > e1 + 1;){
                        const t1 = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
                        s = this._tiles[t1.key], s && s.hasData() && (a = t1);
                    }
                    let o = a;
                    for(; o.overscaledZ > e1;)if (o = o.scaledTo(o.overscaledZ - 1), t1[o.key]) {
                        n[a.key] = a;
                        break;
                    }
                }
            }
            findLoadedParent(t1, e1) {
                if (t1.key in this._loadedParentTiles) {
                    const r = this._loadedParentTiles[t1.key];
                    return r && r.tileID.overscaledZ >= e1 ? r : null;
                }
                for(let r = t1.overscaledZ - 1; r >= e1; r--){
                    const e1 = t1.scaledTo(r), n = this._getLoadedTile(e1);
                    if (n) return n;
                }
            }
            _getLoadedTile(t1) {
                const e1 = this._tiles[t1.key];
                return e1 && e1.hasData() ? e1 : this._cache.getByKey(this._source.reparseOverscaled ? t1.wrapped().key : t1.canonical.key);
            }
            updateCacheSize(t1, e1) {
                e1 = e1 || this._source.tileSize;
                const r = Math.ceil(t1.width / e1) + 1, n = Math.ceil(t1.height / e1) + 1, i = Math.floor(r * n * 5), s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i, a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;
                this._cache.setMaxSize(a);
            }
            handleWrapJump(t1) {
                const e1 = Math.round((t1 - (void 0 === this._prevLng ? t1 : this._prevLng)) / 360);
                if (this._prevLng = t1, e1) {
                    const t1 = {};
                    for(const r in this._tiles){
                        const n = this._tiles[r];
                        n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e1), t1[n.tileID.key] = n;
                    }
                    this._tiles = t1;
                    for(const t1 in this._timers)clearTimeout(this._timers[t1]), delete this._timers[t1];
                    for(const t1 in this._tiles)this._setTileReloadTimer(+t1, this._tiles[t1]);
                }
            }
            update(t1, e1, r) {
                if (this.transform = t1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !r) return;
                let n;
                this.updateCacheSize(t1, e1), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t1.getVisibleUnwrappedCoordinates(this._source.tileID).map((t1)=>new fh(t1.canonical.z, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y)) : (n = t1.coveringTiles({
                    tileSize: e1 || this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !r,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain
                }), this._source.hasTile && (n = n.filter((t1)=>this._source.hasTile(t1)))) : n = [];
                const i = this._updateRetainedTiles(n);
                if (ny(this._source.type) && 0 !== n.length) {
                    const t1 = {}, e1 = {}, r = Object.keys(i);
                    for (const n of r){
                        const r = i[n], s = this._tiles[n];
                        if (!s || s.fadeEndTime && s.fadeEndTime <= Xt.now()) continue;
                        const a = this.findLoadedParent(r, Math.max(r.overscaledZ - ey.maxOverzooming, this._source.minzoom));
                        a && (this._addTile(a.tileID), t1[a.tileID.key] = a.tileID), e1[n] = r;
                    }
                    const s = n[n.length - 1].overscaledZ;
                    for(const t1 in this._tiles){
                        const r = this._tiles[t1];
                        if (i[t1] || !r.hasData()) continue;
                        let n = r.tileID;
                        for(; n.overscaledZ > s;){
                            n = n.scaledTo(n.overscaledZ - 1);
                            const s = this._tiles[n.key];
                            if (s && s.hasData() && e1[n.key]) {
                                i[t1] = r.tileID;
                                break;
                            }
                        }
                    }
                    for(const e1 in t1)i[e1] || (this._coveredTiles[e1] = !0, i[e1] = t1[e1]);
                }
                for(const t1 in i)this._tiles[t1].clearFadeHold();
                const s = function(t1, e1) {
                    const r = [];
                    for(const n in t1)n in e1 || r.push(n);
                    return r;
                }(this._tiles, i);
                for (const t1 of s){
                    const e1 = this._tiles[t1];
                    e1.hasSymbolBuckets && !e1.holdingForFade() ? e1.setHoldDuration(this.map._fadeDuration) : e1.hasSymbolBuckets && !e1.symbolFadeFinished() || this._removeTile(+t1);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const t1 in this._tiles)this._tiles[t1].holdingForFade() && this._removeTile(+t1);
            }
            _updateRetainedTiles(t1) {
                const e1 = {};
                if (0 === t1.length) return e1;
                const r = {}, n = t1.reduce((t1, e1)=>Math.min(t1, e1.overscaledZ), 1 / 0), i = t1[0].overscaledZ, s = Math.max(i - ey.maxOverzooming, this._source.minzoom), a = Math.max(i + ey.maxUnderzooming, this._source.minzoom), o = {};
                for (const r of t1){
                    const t1 = this._addTile(r);
                    e1[r.key] = r, t1.hasData() || n < this._source.maxzoom && (o[r.key] = r);
                }
                this._retainLoadedChildren(o, n, a, e1);
                for (const n of t1){
                    let t1 = this._tiles[n.key];
                    if (t1.hasData()) continue;
                    if (n.canonical.z >= this._source.maxzoom) {
                        const t1 = n.children(this._source.maxzoom)[0], r = this.getTile(t1);
                        if (r && r.hasData()) {
                            e1[t1.key] = t1;
                            continue;
                        }
                    } else {
                        const t1 = n.children(this._source.maxzoom);
                        if (e1[t1[0].key] && e1[t1[1].key] && e1[t1[2].key] && e1[t1[3].key]) continue;
                    }
                    let i = t1.wasRequested();
                    for(let a = n.overscaledZ - 1; a >= s; --a){
                        const s = n.scaledTo(a);
                        if (r[s.key]) break;
                        if (r[s.key] = !0, t1 = this.getTile(s), !t1 && i && (t1 = this._addTile(s)), t1 && (e1[s.key] = s, i = t1.wasRequested(), t1.hasData())) break;
                    }
                }
                return e1;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const t1 in this._tiles){
                    const e1 = [];
                    let r, n = this._tiles[t1].tileID;
                    for(; n.overscaledZ > 0;){
                        if (n.key in this._loadedParentTiles) {
                            r = this._loadedParentTiles[n.key];
                            break;
                        }
                        e1.push(n.key);
                        const t1 = n.scaledTo(n.overscaledZ - 1);
                        if (r = this._getLoadedTile(t1), r) break;
                        n = t1;
                    }
                    for (const t1 of e1)this._loadedParentTiles[t1] = r;
                }
            }
            _addTile(t1) {
                let e1 = this._tiles[t1.key];
                if (e1) return e1;
                e1 = this._cache.getAndRemove(t1), e1 && (this._setTileReloadTimer(t1.key, e1), e1.tileID = t1, this._state.initializeTileState(e1, this.map ? this.map.painter : null), this._cacheTimers[t1.key] && (clearTimeout(this._cacheTimers[t1.key]), delete this._cacheTimers[t1.key], this._setTileReloadTimer(t1.key, e1)));
                const r = Boolean(e1);
                if (!r) {
                    const r = this.map ? this.map.painter : null;
                    e1 = new Pf(t1, this._source.tileSize * t1.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._loadTile(e1, this._tileLoaded.bind(this, e1, t1.key, e1.state));
                }
                return e1 ? (e1.uses++, this._tiles[t1.key] = e1, r || this._source.fire(new Yt("dataloading", {
                    tile: e1,
                    coord: e1.tileID,
                    dataType: "source"
                })), e1) : null;
            }
            _setTileReloadTimer(t1, e1) {
                t1 in this._timers && (clearTimeout(this._timers[t1]), delete this._timers[t1]);
                const r = e1.getExpiryTimeout();
                r && (this._timers[t1] = setTimeout(()=>{
                    this._reloadTile(t1, "expired"), delete this._timers[t1];
                }, r));
            }
            _removeTile(t1) {
                const e1 = this._tiles[t1];
                e1 && (e1.uses--, delete this._tiles[t1], this._timers[t1] && (clearTimeout(this._timers[t1]), delete this._timers[t1]), e1.uses > 0 || (e1.hasData() && "reloading" !== e1.state ? this._cache.add(e1.tileID, e1, e1.getExpiryTimeout()) : (e1.aborted = !0, this._abortTile(e1), this._unloadTile(e1))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const t1 in this._tiles)this._removeTile(+t1);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t1, e1, r) {
                const n = [], i = this.transform;
                if (!i) return n;
                const s = "globe" === i.projection.name, a = Nl(i.center.lng);
                for(const o in this._tiles){
                    const l = this._tiles[o];
                    if (r && l.clearQueryDebugViz(), l.holdingForFade()) continue;
                    let u;
                    if (s) {
                        const t1 = l.tileID.canonical;
                        if (0 === t1.z) {
                            const e1 = [
                                Math.abs(M(a, ...iy(t1, -1)) - a),
                                Math.abs(M(a, ...iy(t1, 1)) - a)
                            ];
                            u = [
                                0,
                                2 * e1.indexOf(Math.min(...e1)) - 1
                            ];
                        } else {
                            const e1 = [
                                Math.abs(M(a, ...iy(t1, -1)) - a),
                                Math.abs(M(a, ...iy(t1, 0)) - a),
                                Math.abs(M(a, ...iy(t1, 1)) - a)
                            ];
                            u = [
                                e1.indexOf(Math.min(...e1)) - 1
                            ];
                        }
                    } else u = [
                        0
                    ];
                    for (const r of u){
                        const s = t1.containsTile(l, i, e1, r);
                        s && n.push(s);
                    }
                }
                return n;
            }
            getVisibleCoordinates(t1) {
                const e1 = this.getRenderableIds(t1).map((t1)=>this._tiles[t1].tileID);
                for (const t1 of e1)t1.projMatrix = this.transform.calculateProjMatrix(t1.toUnwrapped());
                return e1;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (ny(this._source.type)) for(const t1 in this._tiles){
                    const e1 = this._tiles[t1];
                    if (void 0 !== e1.fadeEndTime && e1.fadeEndTime >= Xt.now()) return !0;
                }
                return !1;
            }
            setFeatureState(t1, e1, r) {
                this._state.updateState(t1 = t1 || "_geojsonTileLayer", e1, r);
            }
            removeFeatureState(t1, e1, r) {
                this._state.removeFeatureState(t1 = t1 || "_geojsonTileLayer", e1, r);
            }
            getFeatureState(t1, e1) {
                return this._state.getState(t1 = t1 || "_geojsonTileLayer", e1);
            }
            setDependencies(t1, e1, r) {
                const n = this._tiles[t1];
                n && n.setDependencies(e1, r);
            }
            reloadTilesForDependencies(t1, e1) {
                for(const r in this._tiles)this._tiles[r].hasDependency(t1, e1) && this._reloadTile(+r, "reloading");
                this._cache.filter((r)=>!r.hasDependency(t1, e1));
            }
            _preloadTiles(t1, e1) {
                if (!this._sourceLoaded) {
                    const r = ()=>{
                        this._sourceLoaded && (this._source.off("data", r), this._preloadTiles(t1, e1));
                    };
                    return void this._source.on("data", r);
                }
                const r = new Map, n = Array.isArray(t1) ? t1 : [
                    t1
                ], i = this.map.painter.terrain, s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;
                for (const t1 of n){
                    const e1 = t1.coveringTiles({
                        tileSize: s,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const t1 of e1)r.set(t1.key, t1);
                    this.usedForTerrain && t1.updateElevation(!1);
                }
                B(Array.from(r.values()), (t1, e1)=>{
                    const r = new Pf(t1, this._source.tileSize * t1.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                    this._loadTile(r, (t1)=>{
                        "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), e1(t1, r);
                    });
                }, e1);
            }
        }
        function ry(t1, e1) {
            const r = Math.abs(2 * t1.wrap) - +(t1.wrap < 0), n = Math.abs(2 * e1.wrap) - +(e1.wrap < 0);
            return t1.overscaledZ - e1.overscaledZ || n - r || e1.canonical.y - t1.canonical.y || e1.canonical.x - t1.canonical.x;
        }
        function ny(t1) {
            return "raster" === t1 || "image" === t1 || "video" === t1 || "custom" === t1;
        }
        function iy(t1, e1) {
            const r = 1 << t1.z;
            return [
                t1.x / r + e1,
                (t1.x + 1) / r + e1
            ];
        }
        ey.maxOverzooming = 10, ey.maxUnderzooming = 3;
        class sy {
            constructor(t1, e1, r){
                this._demTile = t1, this._dem = this._demTile.dem, this._scale = e1, this._offset = r;
            }
            static create(t1, e1, r) {
                const n = r || t1.findDEMTileFor(e1);
                if (!n || !n.dem) return;
                const i = n.dem, s = n.tileID, a = 1 << e1.canonical.z - s.canonical.z;
                return new sy(n, n.tileSize / ao / a, [
                    (e1.canonical.x / a - s.canonical.x) * i.dim,
                    (e1.canonical.y / a - s.canonical.y) * i.dim
                ]);
            }
            tileCoordToPixel(t1, e1) {
                const r = e1 * this._scale + this._offset[1], n = Math.floor(t1 * this._scale + this._offset[0]), i = Math.floor(r);
                return new x(n, i);
            }
            getElevationAt(t1, e1, r, n) {
                const i = t1 * this._scale + this._offset[0], s = e1 * this._scale + this._offset[1], a = Math.floor(i), o = Math.floor(s), l = this._dem;
                return n = !!n, r ? Er(Er(l.get(a, o, n), l.get(a, o + 1, n), s - o), Er(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
            }
            getElevationAtPixel(t1, e1, r) {
                return this._dem.get(t1, e1, !!r);
            }
            getMeterToDEM(t1) {
                return (1 << this._demTile.tileID.canonical.z) * Zl(1, t1) * this._dem.stride;
            }
        }
        class ay {
            constructor(t1, e1){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new Ki(ao, 16, 0), this.featureIndexArray = new ba, this.promoteId = e1;
            }
            insert(t1, e1, r, n, i, s = 0) {
                const a = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const o = this.grid;
                for(let t1 = 0; t1 < e1.length; t1++){
                    const r = e1[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e1 = r[t1];
                        n[0] = Math.min(n[0], e1.x), n[1] = Math.min(n[1], e1.y), n[2] = Math.max(n[2], e1.x), n[3] = Math.max(n[3], e1.y);
                    }
                    n[0] < ao && n[1] < ao && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new Zc(new mp(this.rawTileData)).layers, this.sourceLayerCoder = new wf(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {};
                    for(const t1 in this.vtLayers)this.vtFeatures[t1] = [];
                }
                return this.vtLayers;
            }
            query(t1, e1, r, n) {
                this.loadVTLayers();
                const i = t1.params || {}, s = hi(i.filter), a = t1.tileResult, o = t1.transform, l = a.bufferedTilespaceBounds, u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t1, e1, r, n)=>wu(a.bufferedTilespaceGeometry, t1, e1, r, n));
                u.sort(ly);
                let c = null;
                o.elevation && u.length > 0 && (c = sy.create(o.elevation, this.tileID));
                const h = {};
                let p;
                for(let o = 0; o < u.length; o++){
                    const l = u[o];
                    if (l === p) continue;
                    p = l;
                    const d = this.featureIndexArray.get(l);
                    let f = null;
                    this.loadMatchingFeature(h, d, s, i.layers, i.availableImages, e1, r, n, (e1, r, n, i = 0)=>(f || (f = au(e1, this.tileID.canonical, t1.tileTransform)), r.queryIntersectsFeature(a, e1, n, f, this.z, t1.transform, t1.pixelPosMatrix, c, i)));
                }
                return h;
            }
            loadMatchingFeature(t1, e1, r, n, i, s, a, o, l) {
                const { featureIndex: u, bucketIndex: c, sourceLayerIndex: h, layoutVertexArrayOffset: p } = e1, d = this.bucketLayerIDs[c];
                if (n && !function(t1, e1) {
                    for(let r = 0; r < t1.length; r++)if (e1.indexOf(t1[r]) >= 0) return !0;
                    return !1;
                }(n, d)) return;
                const f = this.sourceLayerCoder.decode(h), y = this.vtLayers[f].feature(u);
                if (r.needGeometry) {
                    const t1 = ou(y, !0);
                    if (!r.filter(new ws(this.tileID.overscaledZ), t1, this.tileID.canonical)) return;
                } else if (!r.filter(new ws(this.tileID.overscaledZ), y)) return;
                const m = this.getId(y, f);
                for(let e1 = 0; e1 < d.length; e1++){
                    const r = d[e1];
                    if (n && n.indexOf(r) < 0) continue;
                    const c = s[r];
                    if (!c) continue;
                    let h = {};
                    void 0 !== m && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", m));
                    const f = C({}, a[r]);
                    f.paint = oy(f.paint, c.paint, y, h, i), f.layout = oy(f.layout, c.layout, y, h, i);
                    const g = !l || l(y, c, h, p);
                    if (!g) continue;
                    const x = new Af(y, this.z, this.x, this.y, m);
                    x.layer = f;
                    let v = t1[r];
                    void 0 === v && (v = t1[r] = []), v.push({
                        featureIndex: u,
                        feature: x,
                        intersectionZ: g
                    });
                }
            }
            lookupSymbolFeatures(t1, e1, r, n, i, s, a, o) {
                const l = {};
                this.loadVTLayers();
                const u = hi(i);
                for (const i of t1)this.loadMatchingFeature(l, {
                    bucketIndex: r,
                    sourceLayerIndex: n,
                    featureIndex: i,
                    layoutVertexArrayOffset: 0
                }, u, s, a, o, e1);
                return l;
            }
            loadFeature(t1) {
                const { featureIndex: e1, sourceLayerIndex: r } = t1;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n];
                if (i[e1]) return i[e1];
                const s = this.vtLayers[n].feature(e1);
                return i[e1] = s, s;
            }
            hasLayer(t1) {
                for (const e1 of this.bucketLayerIDs)for (const r of e1)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e1) {
                let r = t1.id;
                if (this.promoteId) {
                    const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e1];
                    null != n && (r = t1.properties[n]), "boolean" == typeof r && (r = Number(r));
                }
                return r;
            }
        }
        function oy(t1, e1, r, n, i) {
            return $(t1, (t1, s)=>{
                const a = e1 instanceof zs ? e1.get(s) : null;
                return a && a.evaluate ? a.evaluate(r, n, i) : a;
            });
        }
        function ly(t1, e1) {
            return e1 - t1;
        }
        Ji(ay, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        class uy {
            constructor(t1, e1){
                this.width = t1, this.height = e1, this.nextRow = 0, this.image = new Ru({
                    width: t1,
                    height: e1
                }), this.positions = {}, this.uploaded = !1;
            }
            getDash(t1, e1) {
                const r = this.getKey(t1, e1);
                return this.positions[r];
            }
            trim() {
                const t1 = this.width, e1 = this.height = L(this.nextRow);
                this.image.resize({
                    width: t1,
                    height: e1
                });
            }
            getKey(t1, e1) {
                return t1.join(",") + e1;
            }
            getDashRanges(t1, e1, r) {
                const n = [];
                let i = t1.length % 2 == 1 ? -t1[t1.length - 1] * r : 0, s = t1[0] * r, a = !0;
                n.push({
                    left: i,
                    right: s,
                    isDash: a,
                    zeroLength: 0 === t1[0]
                });
                let o = t1[0];
                for(let e1 = 1; e1 < t1.length; e1++){
                    a = !a;
                    const l = t1[e1];
                    i = o * r, o += l, s = o * r, n.push({
                        left: i,
                        right: s,
                        isDash: a,
                        zeroLength: 0 === l
                    });
                }
                return n;
            }
            addRoundDash(t1, e1, r) {
                const n = e1 / 2;
                for(let e1 = -r; e1 <= r; e1++){
                    const i = this.width * (this.nextRow + r + e1);
                    let s = 0, a = t1[s];
                    for(let o = 0; o < this.width; o++){
                        o / a.right > 1 && (a = t1[++s]);
                        const l = Math.abs(o - a.left), u = Math.abs(o - a.right), c = Math.min(l, u);
                        let h;
                        const p = e1 / r * (n + 1);
                        if (a.isDash) {
                            const t1 = n - Math.abs(p);
                            h = Math.sqrt(c * c + t1 * t1);
                        } else h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t1, e1) {
                for(let e1 = t1.length - 1; e1 >= 0; --e1){
                    const r = t1[e1], n = t1[e1 + 1];
                    r.zeroLength ? t1.splice(e1, 1) : n && n.isDash === r.isDash && (n.left = r.left, t1.splice(e1, 1));
                }
                const r = t1[0], n = t1[t1.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let s = 0, a = t1[s];
                for(let r = 0; r < this.width; r++){
                    r / a.right > 1 && (a = t1[++s]);
                    const n = Math.abs(r - a.left), o = Math.abs(r - a.right), l = Math.min(n, o);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e1 + 128));
                }
            }
            addDash(t1, e1) {
                const r = this.getKey(t1, e1);
                if (this.positions[r]) return this.positions[r];
                const n = "round" === e1, i = n ? 7 : 0, s = 2 * i + 1;
                if (this.nextRow + s > this.height) return N("LineAtlas out of space"), null;
                0 === t1.length && t1.push(1);
                let a = 0;
                for(let e1 = 0; e1 < t1.length; e1++)t1[e1] < 0 && (N("Negative value is found in line dasharray, replacing values with 0"), t1[e1] = 0), a += t1[e1];
                if (0 !== a) {
                    const r = this.width / a, s = this.getDashRanges(t1, this.width, r);
                    n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e1 ? .5 * r : 0);
                }
                const o = this.nextRow + i;
                this.nextRow += s;
                const l = {
                    tl: [
                        o,
                        i
                    ],
                    br: [
                        a,
                        0
                    ]
                };
                return this.positions[r] = l, l;
            }
        }
        Ji(uy, "LineAtlas");
        const cy = 1 * td;
        class hy {
            constructor(t1){
                const e1 = {}, r = [];
                for(const n in t1){
                    const i = t1[n], s = e1[n] = {};
                    for(const t1 in i.glyphs){
                        const e1 = i.glyphs[+t1];
                        if (!e1 || 0 === e1.bitmap.width || 0 === e1.bitmap.height) continue;
                        const n = e1.metrics.localGlyph ? cy : 1, a = {
                            x: 0,
                            y: 0,
                            w: e1.bitmap.width + 2 * n,
                            h: e1.bitmap.height + 2 * n
                        };
                        r.push(a), s[t1] = a;
                    }
                }
                const { w: n, h: i } = _p(r), s = new Ru({
                    width: n || 1,
                    height: i || 1
                });
                for(const r in t1){
                    const n = t1[r];
                    for(const t1 in n.glyphs){
                        const i = n.glyphs[+t1];
                        if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;
                        const a = e1[r][t1], o = i.metrics.localGlyph ? cy : 1;
                        Ru.copy(i.bitmap, s, {
                            x: 0,
                            y: 0
                        }, {
                            x: a.x + o,
                            y: a.y + o
                        }, i.bitmap);
                    }
                }
                this.image = s, this.positions = e1;
            }
        }
        Ji(hy, "GlyphAtlas");
        class py {
            constructor(t1){
                this.tileID = new fh(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.collectResourceTiming, this.returnDependencies = !!t1.returnDependencies, this.promoteId = t1.promoteId, this.enableTerrain = !!t1.enableTerrain, this.isSymbolTile = t1.isSymbolTile, this.tileTransform = Bd(t1.tileID.canonical, t1.projection), this.projection = t1.projection;
            }
            parse(t1, e1, r, n, i) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new pa;
                const s = new wf(Object.keys(t1.layers).sort()), a = new ay(this.tileID, this.promoteId);
                a.bucketLayerIDs = [];
                const o = {}, l = new uy(256, 256), u = {
                    featureIndex: a,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: l,
                    availableImages: r
                }, c = e1.familiesBySource[this.source];
                for(const e1 in c){
                    const n = t1.layers[e1];
                    if (!n) continue;
                    let i = !1, l = !1;
                    for (const t1 of c[e1])"symbol" === t1[0].type ? i = !0 : l = !0;
                    if (!0 === this.isSymbolTile && !i) continue;
                    if (!1 === this.isSymbolTile && !l) continue;
                    1 === n.version && N(`Vector tile source "${this.source}" layer "${e1}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const h = s.encode(e1), p = [];
                    for(let t1 = 0; t1 < n.length; t1++){
                        const r = n.feature(t1), i = a.getId(r, e1);
                        p.push({
                            feature: r,
                            id: i,
                            index: t1,
                            sourceLayerIndex: h
                        });
                    }
                    for (const t1 of c[e1]){
                        const e1 = t1[0];
                        void 0 !== this.isSymbolTile && "symbol" === e1.type !== this.isSymbolTile || e1.minzoom && this.zoom < Math.floor(e1.minzoom) || e1.maxzoom && this.zoom >= e1.maxzoom || "none" !== e1.visibility && (dy(t1, this.zoom, r), (o[e1.id] = e1.createBucket({
                            index: a.bucketLayerIDs.length,
                            layers: t1,
                            zoom: this.zoom,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: h,
                            sourceID: this.source,
                            enableTerrain: this.enableTerrain,
                            projection: this.projection.spec,
                            availableImages: r
                        })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t1.map((t1)=>t1.id)));
                    }
                }
                let h, p, d, f;
                l.trim();
                const y = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }, m = ()=>{
                    if (h) return i(h);
                    if (p && d && f) {
                        const t1 = new hy(p), e1 = new kp(d, f);
                        for(const n in o){
                            const i = o[n];
                            i instanceof of ? (dy(i.layers, this.zoom, r), vd(i, p, t1.positions, d, e1.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof Ih || i instanceof Mc || i instanceof th) && (dy(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e1.patternPositions, r, this.tileTransform));
                        }
                        this.status = "done", i(null, {
                            buckets: E(o).filter((t1)=>!t1.isEmpty()),
                            featureIndex: a,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t1.image,
                            lineAtlas: l,
                            imageAtlas: e1,
                            glyphMap: this.returnDependencies ? p : null,
                            iconMap: this.returnDependencies ? d : null,
                            glyphPositions: this.returnDependencies ? t1.positions : null
                        });
                    }
                }, g = $(u.glyphDependencies, (t1)=>Object.keys(t1).map(Number));
                Object.keys(g).length ? n.send("getGlyphs", {
                    uid: this.uid,
                    stacks: g
                }, (t1, e1)=>{
                    h || (h = t1, p = e1, m());
                }, void 0, !1, y) : p = {};
                const x = Object.keys(u.iconDependencies);
                x.length ? n.send("getImages", {
                    icons: x,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                }, (t1, e1)=>{
                    h || (h = t1, d = e1, m());
                }, void 0, !1, y) : d = {};
                const v = Object.keys(u.patternDependencies);
                v.length ? n.send("getImages", {
                    icons: v,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                }, (t1, e1)=>{
                    h || (h = t1, f = e1, m());
                }, void 0, !1, y) : f = {}, m();
            }
        }
        function dy(t1, e1, r) {
            const n = new ws(e1);
            for (const e1 of t1)e1.recalculate(n, r);
        }
        class fy {
            constructor(t1){
                this.entries = {}, this.scheduler = t1;
            }
            request(t1, e1, r, n) {
                const i = this.entries[t1] = this.entries[t1] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t1, r] = i.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t1, r);
                    }, e1) : n(t1, r), ()=>{};
                }
                return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n)=>{
                    i.result = [
                        r,
                        n
                    ];
                    for (const t1 of i.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t1(r, n);
                    }, e1) : t1(r, n);
                    setTimeout(()=>delete this.entries[t1], 3e3);
                })), ()=>{
                    i.result || (i.callbacks = i.callbacks.filter((t1)=>t1 !== n), i.callbacks.length || (i.cancel(), delete this.entries[t1]));
                };
            }
        }
        function yy(t1, e1, r) {
            const n = JSON.stringify(t1.request);
            return t1.data && (this.deduped.entries[n] = {
                result: [
                    null,
                    t1.data
                ]
            }), this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t1.isSymbolTile,
                zoom: t1.tileZoom
            }, (e1)=>{
                const n = pt(t1.request, (t1, n, i, s)=>{
                    t1 ? e1(t1) : n && e1(null, {
                        vectorTile: r ? void 0 : new Zc(new mp(n)),
                        rawData: n,
                        cacheControl: i,
                        expires: s
                    });
                });
                return ()=>{
                    n.cancel(), e1();
                };
            }, e1);
        }
        const my = [
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        ];
        class gy {
            static from(t1) {
                if (!(t1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                const [e1, r] = new Uint8Array(t1, 0, 2);
                if (219 !== e1) throw new Error("Data does not appear to be in a KDBush format.");
                const n = r >> 4;
                if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);
                const i = my[15 & r];
                if (!i) throw new Error("Unrecognized array type.");
                const [s] = new Uint16Array(t1, 2, 1), [a] = new Uint32Array(t1, 4, 1);
                return new gy(a, s, i, t1);
            }
            constructor(t1, e1 = 64, r = Float64Array, n){
                if (isNaN(t1) || t1 < 0) throw new Error(`Unpexpected numItems value: ${t1}.`);
                this.numItems = +t1, this.nodeSize = Math.min(Math.max(+e1, 2), 65535), this.ArrayType = r, this.IndexArrayType = t1 < 65536 ? Uint16Array : Uint32Array;
                const i = my.indexOf(this.ArrayType), s = 2 * t1 * this.ArrayType.BYTES_PER_ELEMENT, a = t1 * this.IndexArrayType.BYTES_PER_ELEMENT, o = (8 - a % 8) % 8;
                if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);
                n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t1), this._pos = 2 * t1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + a + o), this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([
                    219,
                    16 + i
                ]), new Uint16Array(this.data, 2, 1)[0] = e1, new Uint32Array(this.data, 4, 1)[0] = t1);
            }
            add(t1, e1) {
                const r = this._pos >> 1;
                return this.ids[r] = r, this.coords[this._pos++] = t1, this.coords[this._pos++] = e1, r;
            }
            finish() {
                const t1 = this._pos >> 1;
                if (t1 !== this.numItems) throw new Error(`Added ${t1} items when expected ${this.numItems}.`);
                return xy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
            }
            range(t1, e1, r, n) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: i, coords: s, nodeSize: a } = this, o = [
                    0,
                    i.length - 1,
                    0
                ], l = [];
                for(; o.length;){
                    const u = o.pop() || 0, c = o.pop() || 0, h = o.pop() || 0;
                    if (c - h <= a) {
                        for(let a = h; a <= c; a++){
                            const o = s[2 * a], u = s[2 * a + 1];
                            o >= t1 && o <= r && u >= e1 && u <= n && l.push(i[a]);
                        }
                        continue;
                    }
                    const p = h + c >> 1, d = s[2 * p], f = s[2 * p + 1];
                    d >= t1 && d <= r && f >= e1 && f <= n && l.push(i[p]), (0 === u ? t1 <= d : e1 <= f) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= d : n >= f) && (o.push(p + 1), o.push(c), o.push(1 - u));
                }
                return l;
            }
            within(t1, e1, r) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: n, coords: i, nodeSize: s } = this, a = [
                    0,
                    n.length - 1,
                    0
                ], o = [], l = r * r;
                for(; a.length;){
                    const u = a.pop() || 0, c = a.pop() || 0, h = a.pop() || 0;
                    if (c - h <= s) {
                        for(let r = h; r <= c; r++)_y(i[2 * r], i[2 * r + 1], t1, e1) <= l && o.push(n[r]);
                        continue;
                    }
                    const p = h + c >> 1, d = i[2 * p], f = i[2 * p + 1];
                    _y(d, f, t1, e1) <= l && o.push(n[p]), (0 === u ? t1 - r <= d : e1 - r <= f) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? t1 + r >= d : e1 + r >= f) && (a.push(p + 1), a.push(c), a.push(1 - u));
                }
                return o;
            }
        }
        function xy(t1, e1, r, n, i, s) {
            if (i - n <= r) return;
            const a = n + i >> 1;
            vy(t1, e1, a, n, i, s), xy(t1, e1, r, n, a - 1, 1 - s), xy(t1, e1, r, a + 1, i, 1 - s);
        }
        function vy(t1, e1, r, n, i, s) {
            for(; i > n;){
                if (i - n > 600) {
                    const a = i - n + 1, o = r - n + 1, l = Math.log(a), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1);
                    vy(t1, e1, r, Math.max(n, Math.floor(r - o * u / a + c)), Math.min(i, Math.floor(r + (a - o) * u / a + c)), s);
                }
                const a = e1[2 * r + s];
                let o = n, l = i;
                for(by(t1, e1, n, r), e1[2 * i + s] > a && by(t1, e1, n, i); o < l;){
                    for(by(t1, e1, o, l), o++, l--; e1[2 * o + s] < a;)o++;
                    for(; e1[2 * l + s] > a;)l--;
                }
                e1[2 * n + s] === a ? by(t1, e1, n, l) : (l++, by(t1, e1, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);
            }
        }
        function by(t1, e1, r, n) {
            wy(t1, r, n), wy(e1, 2 * r, 2 * n), wy(e1, 2 * r + 1, 2 * n + 1);
        }
        function wy(t1, e1, r) {
            const n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        function _y(t1, e1, r, n) {
            const i = t1 - r, s = e1 - n;
            return i * i + s * s;
        }
        t1.ARRAY_TYPE = uo, t1.AUTH_ERR_MSG = xt, t1.Aabb = il, t1.Actor = class {
            constructor(t1, r, n){
                this.target = t1, this.parent = r, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, R([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = K() ? t1 : e1, this.scheduler = new bf;
            }
            send(t1, e1, r, n, i = !1, s) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s, this.callbacks[a] = r);
                const o = H(this.globalScope) ? void 0 : [];
                return this.target.postMessage({
                    id: a,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Wi(e1, o)
                }, o), {
                    cancel: ()=>{
                        r && delete this.callbacks[a], this.target.postMessage({
                            id: a,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e1 = t1.data, r = e1.id;
                if (r && (!e1.targetMapId || this.mapId === e1.targetMapId)) {
                    if ("<cancel>" === e1.type) {
                        const t1 = this.cancelCallbacks[r];
                        delete this.cancelCallbacks[r], t1 && t1.cancel();
                    } else if (e1.mustQueue || K()) {
                        const t1 = this.callbacks[r];
                        this.cancelCallbacks[r] = this.scheduler.add(()=>this.processTask(r, e1), t1 && t1.metadata || {
                            type: "message"
                        });
                    } else this.processTask(r, e1);
                }
            }
            processTask(t1, e1) {
                if ("<response>" === e1.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e1.error ? r(Qi(e1.error)) : r(null, Qi(e1.data)));
                } else {
                    const r = H(this.globalScope) ? void 0 : [], n = e1.hasCallback ? (e1, n)=>{
                        delete this.cancelCallbacks[t1], this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e1 ? Wi(e1) : null,
                            data: Wi(n, r)
                        }, r);
                    } : (t1)=>{}, i = Qi(e1.data);
                    if (this.parent[e1.type]) this.parent[e1.type](e1.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e1.type.split(".");
                        this.parent.getWorkerSource(e1.sourceMapId, t1[0], i.source)[t1[1]](i, n);
                    } else n(new Error(`Could not find function ${e1.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }, t1.CanonicalTileID = ph, t1.Color = Ee, t1.ColorMode = Yf, t1.CullFaceMode = ty, t1.DEMData = Zf, t1.DataConstantProperty = Bs, t1.DedupedRequest = fy, t1.DepthMode = Xf, t1.EXTENT = ao, t1.Elevation = class {
            isDataAvailableAtPoint(t1) {
                const e1 = this._source();
                if (this.isUsingMockSource() || !e1 || t1.y < 0 || t1.y > 1) return !1;
                const r = e1.getSource().maxzoom, n = 1 << r, i = Math.floor(t1.x), s = Math.floor((t1.x - i) * n), a = Math.floor(t1.y * n), o = this.findDEMTileFor(new fh(r, i, r, s, a));
                return !(!o || !o.dem);
            }
            getAtPointOrZero(t1, e1 = 0) {
                return this.getAtPoint(t1, e1) || 0;
            }
            getAtPoint(t1, e1, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e1 && (e1 = null);
                const n = this._source();
                if (!n) return e1;
                if (t1.y < 0 || t1.y > 1) return e1;
                const i = n.getSource().maxzoom, s = 1 << i, a = Math.floor(t1.x), o = t1.x - a, l = new fh(i, a, i, Math.floor(o * s), Math.floor(t1.y * s)), u = this.findDEMTileFor(l);
                if (!u || !u.dem) return e1;
                const c = u.dem, h = 1 << u.tileID.canonical.z, p = (o * h - u.tileID.canonical.x) * c.dim, d = (t1.y * h - u.tileID.canonical.y) * c.dim, f = Math.floor(p), y = Math.floor(d);
                return (r ? this.exaggeration() : 1) * Er(Er(c.get(f, y), c.get(f, y + 1), d - y), Er(c.get(f + 1, y), c.get(f + 1, y + 1), d - y), p - f);
            }
            getAtTileOffset(t1, e1, r) {
                const n = 1 << t1.canonical.z;
                return this.getAtPointOrZero(new Wl(t1.wrap + (t1.canonical.x + e1 / ao) / n, (t1.canonical.y + r / ao) / n));
            }
            getAtTileOffsetFunc(t1, e1, r, n) {
                return (i)=>{
                    const s = this.getAtTileOffset(t1, i.x, i.y), a = n.upVector(t1.canonical, i.x, i.y);
                    return Co(a, a, s * n.upVectorScale(t1.canonical, e1, r).metersToTile), a;
                };
            }
            getForTilePoints(t1, e1, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i = sy.create(this, t1, n);
                return !!i && (e1.forEach((t1)=>{
                    t1[2] = this.exaggeration() * i.getElevationAt(t1[0], t1[1], r);
                }), !0);
            }
            getMinMaxForTile(t1) {
                if (this.isUsingMockSource()) return null;
                const e1 = this.findDEMTileFor(t1);
                if (!e1 || !e1.dem) return null;
                const r = e1.dem.tree, n = e1.tileID, i = 1 << t1.canonical.z - n.canonical.z;
                let s = t1.canonical.x / i - n.canonical.x, a = t1.canonical.y / i - n.canonical.y, o = 0;
                for(let e1 = 0; e1 < t1.canonical.z - n.canonical.z && !r.leaves[o]; e1++){
                    s *= 2, a *= 2;
                    const t1 = 2 * Math.floor(a) + Math.floor(s);
                    o = r.childOffsets[o] + t1, s %= 1, a %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[o],
                    max: this.exaggeration() * r.maximums[o]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t1, e1, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t1) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t1) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
        }, t1.ErrorEvent = Wt, t1.EvaluationParameters = ws, t1.Event = Yt, t1.Evented = Qt, t1.FillExtrusionBucket = th, t1.Frustum = nl, t1.FrustumCorners = rl, t1.GLOBE_RADIUS = ol, t1.GLOBE_SCALE_MATCH_LATITUDE = 45, t1.GLOBE_ZOOM_THRESHOLD_MAX = al, t1.GLOBE_ZOOM_THRESHOLD_MIN = sl, t1.GlobeSharedBuffers = class {
            constructor(t1){
                this._createGrid(t1), this._createPoles(t1);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t1 of this._poleSegments)t1.destroy();
                for (const t1 of this._gridSegments)t1.withSkirts.destroy(), t1.withoutSkirts.destroy();
                if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const t1 of this._wireframeSegments)t1.destroy();
                }
            }
            _fillGridMeshWithLods(t1, e1) {
                const r = new $s, n = new ra, i = [], s = t1 + 1 + 2, a = e1[0] + 1, o = e1[0] + 1 + (1 + e1.length), l = (t1, e1, r)=>{
                    let n = t1 === s - 1 ? t1 - 2 : 0 === t1 ? t1 : t1 - 1;
                    return n += r ? 24575 : 0, [
                        n,
                        e1
                    ];
                };
                for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, 0, !0));
                for(let t1 = 0; t1 < a; ++t1)for(let e1 = 0; e1 < s; ++e1)r.emplaceBack(...l(e1, t1, (0 === e1 || e1 === s - 1) && !0));
                for(let t1 = 0; t1 < e1.length; ++t1){
                    const n = e1[t1];
                    for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, n, !0));
                }
                for(let t1 = 0; t1 < e1.length; ++t1){
                    const a = n.length, l = e1[t1] + 1 + 2, u = new ra;
                    for(let r = 0; r < l - 1; r++){
                        const i = r === l - 2, a = i ? s * (o - e1.length + t1 - r) : s;
                        for(let t1 = 0; t1 < s - 1; t1++){
                            const e1 = r * s + t1;
                            0 === r || i || 0 === t1 || t1 === s - 2 ? (u.emplaceBack(e1 + 1, e1, e1 + a), u.emplaceBack(e1 + a, e1 + a + 1, e1 + 1)) : (n.emplaceBack(e1 + 1, e1, e1 + a), n.emplaceBack(e1 + a, e1 + a + 1, e1 + 1));
                        }
                    }
                    const c = so.simpleSegment(0, a, r.length, n.length - a);
                    for(let t1 = 0; t1 < u.uint16.length; t1 += 3)n.emplaceBack(u.uint16[t1], u.uint16[t1 + 1], u.uint16[t1 + 2]);
                    const h = so.simpleSegment(0, a, r.length, n.length - a);
                    i.push({
                        withoutSkirts: c,
                        withSkirts: h
                    });
                }
                return {
                    vertices: r,
                    indices: n,
                    segments: i
                };
            }
            _createGrid(t1) {
                const e1 = this._fillGridMeshWithLods(ul, cl);
                this._gridSegments = e1.segments, this._gridBuffer = t1.createVertexBuffer(e1.vertices, tl.members), this._gridIndexBuffer = t1.createIndexBuffer(e1.indices, !0);
            }
            _createPoles(t1) {
                const e1 = new ra;
                for(let t1 = 0; t1 <= ul; t1++)e1.emplaceBack(0, t1 + 1, t1 + 2);
                this._poleIndexBuffer = t1.createIndexBuffer(e1, !0);
                const r = new aa, n = new aa;
                this._poleSegments = [];
                for(let t1 = 0, e1 = 0; t1 < sl; t1++){
                    const i = 360 / (1 << t1);
                    r.emplaceBack(0, -ol, 0, .5, 0), n.emplaceBack(0, -ol, 0, .5, 1);
                    for(let t1 = 0; t1 <= ul; t1++){
                        const e1 = t1 / ul, s = Er(0, i, e1), [a, o, l] = kl(Fl, Rl, s, ol);
                        r.emplaceBack(a, o, l, e1, 0), n.emplaceBack(a, o, l, e1, 1);
                    }
                    this._poleSegments.push(so.simpleSegment(e1, 0, 66, 64)), e1 += 66;
                }
                this._poleNorthVertexBuffer = t1.createVertexBuffer(r, Wo, !1), this._poleSouthVertexBuffer = t1.createVertexBuffer(n, Wo, !1);
            }
            getGridBuffers(t1, e1) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e1 ? this._gridSegments[t1].withSkirts : this._gridSegments[t1].withoutSkirts
                ];
            }
            getPoleBuffers(t1) {
                return [
                    this._poleNorthVertexBuffer,
                    this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t1]
                ];
            }
            getWirefameBuffers(t1, e1) {
                if (!this._wireframeSegments) {
                    const e1 = new la, r = ul, n = r + 1 + 2, i = 1;
                    this._wireframeSegments = [];
                    for(let t1 = 0, s = 0; t1 < cl.length; t1++){
                        const a = cl[t1];
                        for(let t1 = i; t1 < a + i; t1++)for(let s = i; s < r + i; s++){
                            const r = t1 * n + s;
                            e1.emplaceBack(r, r + 1), e1.emplaceBack(r, r + n), e1.emplaceBack(r, r + n + 1);
                        }
                        const o = a * r * 3;
                        this._wireframeSegments.push(so.simpleSegment(0, s, (a + 1) * n, o)), s += o;
                    }
                    this._wireframeIndexBuffer = t1.createIndexBuffer(e1);
                }
                return [
                    this._gridBuffer,
                    this._wireframeIndexBuffer,
                    this._wireframeSegments[e1]
                ];
            }
        }, t1.GlyphManager = rd, t1.ImagePosition = Sp, t1.KDBush = gy, t1.LivePerformanceUtils = $t, t1.LngLat = Ol, t1.LngLatBounds = oo, t1.LocalGlyphMode = ed, t1.MAX_MERCATOR_LATITUDE = Hl, t1.MercatorCoordinate = Wl, t1.ONE_EM = Rh, t1.OverscaledTileID = fh, t1.PerformanceMarkers = Ut, t1.Point = x, t1.Properties = Ps, t1.RGBAImage = Uu, t1.Ray = el, t1.RequestManager = class {
            constructor(t1, e1, r){
                this._transformRequestFn = t1, this._customAccessToken = e1, this._silenceAuthErrors = !!r, this._createSkuToken();
            }
            _createSkuToken() {
                const t1 = function() {
                    let t1 = "";
                    for(let e1 = 0; e1 < 10; e1++)t1 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            h,
                            t1
                        ].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    };
                }();
                this._skuToken = t1.token, this._skuTokenExpiresAt = t1.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(t1, e1) {
                return this._transformRequestFn && this._transformRequestFn(t1, e1) || {
                    url: t1
                };
            }
            normalizeStyleURL(t1, e1) {
                if (!vt(t1)) return t1;
                const r = kt(t1);
                return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e1);
            }
            normalizeGlyphsURL(t1, e1) {
                if (!vt(t1)) return t1;
                const r = kt(t1);
                return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e1);
            }
            normalizeSourceURL(t1, e1, r, n) {
                if (!vt(t1)) return t1;
                const i = kt(t1);
                return i.path = `/v4/${i.authority}.json`, i.params.push("secure"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e1);
            }
            normalizeSpriteURL(t1, e1, r, n) {
                const i = kt(t1);
                return vt(t1) ? (i.path = `/styles/v1${i.path}/sprite${e1}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e1}${r}`, It(i));
            }
            normalizeTileURL(t1, e1, r) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t1 && !vt(t1)) return t1;
                const n = kt(t1);
                n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e1 || r && "raster" !== n.authority && 512 === r ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), "raster" === n.authority ? n.path = `/${i.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${i.TILE_URL_VERSION}${n.path}`);
                const a = this._customAccessToken || function(t1) {
                    for (const e1 of t1){
                        const t1 = e1.match(/^access_token=(.*)$/);
                        if (t1) return t1[1];
                    }
                    return null;
                }(n.params) || i.ACCESS_TOKEN;
                return i.REQUIRE_ACCESS_TOKEN && a && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, a);
            }
            canonicalizeTileURL(t1, e1) {
                const r = kt(t1);
                if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t1;
                let n = "mapbox://";
                r.path.match(/^\/raster\/v1\//) ? n += `raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
                let s = r.params;
                return e1 && (s = s.filter((t1)=>!t1.match(/^access_token=/))), s.length && (n += `?${s.join("&")}`), n;
            }
            canonicalizeTileset(t1, e1) {
                const r = !!e1 && vt(e1), n = [];
                for (const e1 of t1.tiles || [])bt(e1) ? n.push(this.canonicalizeTileURL(e1, r)) : n.push(e1);
                return n;
            }
            _makeAPIURL(t1, e1) {
                const r = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n = kt(i.API_URL);
                if (t1.protocol = n.protocol, t1.authority = n.authority, "http" === t1.protocol) {
                    const e1 = t1.params.indexOf("secure");
                    e1 >= 0 && t1.params.splice(e1, 1);
                }
                if ("/" !== n.path && (t1.path = `${n.path}${t1.path}`), !i.REQUIRE_ACCESS_TOKEN) return It(t1);
                if (e1 = e1 || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!e1) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);
                    if ("s" === e1[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
                }
                return t1.params = t1.params.filter((t1)=>-1 === t1.indexOf("access_token")), t1.params.push(`access_token=${e1 || ""}`), It(t1);
            }
        }, t1.ResourceType = lt, t1.SegmentVector = so, t1.SourceCache = ey, t1.StencilMode = Hf, t1.StructArrayLayout1ui2 = ua, t1.StructArrayLayout2f1f2i16 = Qs, t1.StructArrayLayout2i4 = $s, t1.StructArrayLayout2ui4 = la, t1.StructArrayLayout3f12 = ea, t1.StructArrayLayout3ui6 = ra, t1.StructArrayLayout4i8 = Os, t1.StructArrayLayout5f20 = aa, t1.Texture = xf, t1.Tile = Pf, t1.Transitionable = Ss, t1.Uniform1f = La, t1.Uniform1i = class extends Va {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }, t1.Uniform2f = class extends Va {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0
                ];
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }, t1.Uniform3f = class extends Va {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }, t1.Uniform4f = Fa, t1.UniformColor = Ra, t1.UniformMatrix2f = class extends Va {
            constructor(t1){
                super(t1), this.current = ja;
            }
            set(t1, e1, r) {
                if (this.fetchUniformLocation(t1, e1)) {
                    for(let t1 = 0; t1 < 4; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.UniformMatrix3f = class extends Va {
            constructor(t1){
                super(t1), this.current = $a;
            }
            set(t1, e1, r) {
                if (this.fetchUniformLocation(t1, e1)) {
                    for(let t1 = 0; t1 < 9; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.UniformMatrix4f = class extends Va {
            constructor(t1){
                super(t1), this.current = Ua;
            }
            set(t1, e1, r) {
                if (this.fetchUniformLocation(t1, e1)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t1 = 1; t1 < 16; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.UnwrappedTileID = dh, t1.ValidationError = ri, t1.VectorTileFeature = Kc, t1.VectorTileWorkerSource = class extends Qt {
            constructor(t1, e1, r, n, i){
                super(), this.actor = t1, this.layerIndex = e1, this.availableImages = r, this.loadVectorData = i || yy, this.loading = {}, this.loaded = {}, this.deduped = new fy(t1.scheduler), this.isSpriteLoaded = n, this.scheduler = t1.scheduler;
            }
            loadTile(t1, e1) {
                const r = t1.uid, n = t1 && t1.request, i = n && n.collectResourceTiming, s = this.loading[r] = new py(t1);
                s.abort = this.loadVectorData(t1, (a, o)=>{
                    const l = !this.loading[r];
                    if (delete this.loading[r], l || a || !o) return s.status = "done", l || (this.loaded[r] = s), e1(a);
                    const u = o.rawData, c = {};
                    o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new Zc(new mp(u));
                    const h = ()=>{
                        s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t1, r)=>{
                            if (t1 || !r) return e1(t1);
                            const s = {};
                            if (i) {
                                const t1 = qt(n);
                                t1.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t1)));
                            }
                            e1(null, C({
                                rawTileData: u.slice(0)
                            }, r, c, s));
                        });
                    };
                    this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(h, {
                            type: "parseTile",
                            isSymbolTile: t1.isSymbolTile,
                            zoom: t1.tileZoom
                        }) : h();
                    }), this.loaded = this.loaded || {}, this.loaded[r] = s;
                });
            }
            reloadTile(t1, e1) {
                const r = this.loaded, n = t1.uid, i = this;
                if (r && r[n]) {
                    const s = r[n];
                    s.showCollisionBoxes = t1.showCollisionBoxes, s.enableTerrain = !!t1.enableTerrain, s.projection = t1.projection, s.tileTransform = Bd(t1.tileID.canonical, t1.projection);
                    const a = (t1, r)=>{
                        const n = s.reloadCallback;
                        n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e1(t1, r);
                    };
                    "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());
                }
            }
            abortTile(t1, e1) {
                const r = t1.uid, n = this.loading[r];
                n && (n.abort && n.abort(), delete this.loading[r]), e1();
            }
            removeTile(t1, e1) {
                const r = this.loaded, n = t1.uid;
                r && r[n] && delete r[n], e1();
            }
        }, t1.WritingMode = Ip, t1.ZoomDependentExpression = Wn, t1.add = Mo, t1.addDynamicAttributes = rf, t1.adjoint = function(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = e1[4], o = e1[5], l = e1[6], u = e1[7], c = e1[8];
            return t1[0] = a * c - o * u, t1[1] = i * u - n * c, t1[2] = n * o - i * a, t1[3] = o * l - s * c, t1[4] = r * c - i * l, t1[5] = i * s - r * o, t1[6] = s * u - a * l, t1[7] = n * l - r * u, t1[8] = r * a - n * s, t1;
        }, t1.asyncAll = B, t1.bezier = k, t1.bindAll = R, t1.boundsAttributes = Ef, t1.bufferConvexPolygon = function(t1, e1) {
            const r = [];
            for(let n = 0; n < t1.length; n++){
                const i = z(n - 1, -1, t1.length - 1), s = z(n + 1, -1, t1.length - 1), a = t1[n], o = t1[s], l = t1[i].sub(a).unit(), u = o.sub(a).unit(), c = u.angleWithSep(l.x, l.y), h = l.add(u).unit().mult(-1 * e1 / Math.sin(c / 2));
                r.push(a.add(h));
            }
            return r;
        }, t1.cacheEntryPossiblyAdded = function(t1) {
            ot++, ot > et && (t1.getActor().send("enforceCacheSizeLimit", tt), ot = 0);
        }, t1.calculateGlobeLabelMatrix = function(t1, e1) {
            const { x: r, y: n } = t1.point, i = Cl(r, n, t1.worldSize / t1._pixelsPerMercatorPixel, 0, 0);
            return yo(i, i, El(xl(e1)));
        }, t1.calculateGlobeMatrix = function(t1) {
            const { x: e1, y: r } = t1.point, { lng: n, lat: i } = t1._center;
            return Cl(e1, r, t1.worldSize, n, i);
        }, t1.calculateGlobeMercatorMatrix = function(t1) {
            const e1 = t1.pixelsPerMeter, r = e1 / Zl(1, t1.center.lat), n = po(new Float64Array(16));
            return mo(n, n, [
                t1.point.x,
                t1.point.y,
                0
            ]), go(n, n, [
                r,
                r,
                e1
            ]), Float32Array.from(n);
        }, t1.circumferenceAtLatitude = ql, t1.clamp = M, t1.clearTileCache = function(t1) {
            if (!it()) return;
            const r = e1.caches.delete(Q);
            t1 && r.catch(t1).then(()=>t1());
        }, t1.clipLine = Hp, t1.clone = function(t1) {
            var e1 = new uo(16);
            return e1[0] = t1[0], e1[1] = t1[1], e1[2] = t1[2], e1[3] = t1[3], e1[4] = t1[4], e1[5] = t1[5], e1[6] = t1[6], e1[7] = t1[7], e1[8] = t1[8], e1[9] = t1[9], e1[10] = t1[10], e1[11] = t1[11], e1[12] = t1[12], e1[13] = t1[13], e1[14] = t1[14], e1[15] = t1[15], e1;
        }, t1.clone$1 = O, t1.collisionCircleLayout = Fh, t1.config = i, t1.conjugate = function(t1, e1) {
            return t1[0] = -e1[0], t1[1] = -e1[1], t1[2] = -e1[2], t1[3] = e1[3], t1;
        }, t1.create = function() {
            var t1 = new uo(16);
            return uo != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
        }, t1.create$1 = co, t1.createExpression = Hn, t1.createLayout = Rs, t1.createStyleLayer = function(t1) {
            return "custom" === t1.type ? new ff(t1) : new gf[t1.type](t1);
        }, t1.cross = Lo, t1.degToRad = w, t1.distance = function(t1, e1) {
            return Math.hypot(e1[0] - t1[0], e1[1] - t1[1], e1[2] - t1[2]);
        }, t1.div = function(t1, e1, r) {
            return t1[0] = e1[0] / r[0], t1[1] = e1[1] / r[1], t1[2] = e1[2] / r[2], t1;
        }, t1.dot = Vo, t1.earthRadius = Ul, t1.ease = I, t1.easeCubicInOut = S, t1.ecefToLatLng = function([t1, e1, r]) {
            const n = Math.hypot(t1, e1, r), i = Math.atan2(t1, r), s = .5 * Math.PI - Math.acos(-e1 / n);
            return new Ol(_(i), _(s));
        }, t1.emitValidationErrors = qi, t1.endsWith = U, t1.enforceCacheSizeLimit = function(t1) {
            st(), rt && rt.then((e1)=>{
                e1.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e1.delete(r[n]);
                });
            });
        }, t1.evaluateSizeForFeature = jh, t1.evaluateSizeForZoom = Oh, t1.evaluateVariableOffset = xd, t1.evented = gs, t1.exactEquals = function(t1, e1) {
            return t1[0] === e1[0] && t1[1] === e1[1] && t1[2] === e1[2] && t1[3] === e1[3];
        }, t1.exactEquals$1 = function(t1, e1) {
            return t1[0] === e1[0] && t1[1] === e1[1] && t1[2] === e1[2];
        }, t1.exported = Xt, t1.exported$1 = s, t1.extend = C, t1.extend$1 = ee, t1.fillExtrusionHeightLift = oh, t1.filterObject = j, t1.fromMat4 = function(t1, e1) {
            return t1[0] = e1[0], t1[1] = e1[1], t1[2] = e1[2], t1[3] = e1[4], t1[4] = e1[5], t1[5] = e1[6], t1[6] = e1[8], t1[7] = e1[9], t1[8] = e1[10], t1;
        }, t1.fromQuat = function(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = r + r, o = n + n, l = i + i, u = r * a, c = n * a, h = n * o, p = i * a, d = i * o, f = i * l, y = s * a, m = s * o, g = s * l;
            return t1[0] = 1 - h - f, t1[1] = c + g, t1[2] = p - m, t1[3] = 0, t1[4] = c - g, t1[5] = 1 - u - f, t1[6] = d + y, t1[7] = 0, t1[8] = p + m, t1[9] = d - y, t1[10] = 1 - u - h, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, t1.fromRotation = function(t1, e1) {
            var r = Math.sin(e1), n = Math.cos(e1);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, t1.fromScaling = bo, t1.furthestTileCorner = function(t1) {
            const e1 = Math.round((t1 + 45 + 360) % 360 / 90) % 4;
            return A[e1];
        }, t1.getAABBPointSquareDist = function(t1, e1, r) {
            let n = 0;
            for(let i = 0; i < 2; ++i){
                const s = r ? r[i] : 0;
                t1[i] > s && (n += (t1[i] - s) * (t1[i] - s)), e1[i] < s && (n += (s - e1[i]) * (s - e1[i]));
            }
            return n;
        }, t1.getAnchorAlignment = Rp, t1.getAnchorJustification = bd, t1.getBounds = function(t1) {
            let e1 = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const s of t1)e1 = Math.min(e1, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
            return {
                min: new x(e1, r),
                max: new x(n, i)
            };
        }, t1.getColumn = W, t1.getDefaultExportFromCjs = p, t1.getGridMatrix = function(t1, e1, r, n) {
            const i = e1.getNorth(), s = e1.getSouth(), a = e1.getWest(), o = e1.getEast(), l = 1 << t1.z, u = o - a, c = i - s, h = u / ul, p = -c / cl[r], d = [
                0,
                h,
                0,
                p,
                0,
                0,
                i,
                a,
                0
            ];
            if (t1.z > 0) {
                const t1 = 180 / n;
                ho(d, d, [
                    t1 / u + 1,
                    0,
                    0,
                    0,
                    t1 / c + 1,
                    0,
                    -0.5 * t1 / h,
                    .5 * t1 / p,
                    1
                ]);
            }
            return d[2] = l, d[5] = t1.x, d[8] = t1.y, d;
        }, t1.getImage = gt, t1.getJSON = function(t1, e1) {
            return ht(C(t1, {
                type: "json"
            }), e1);
        }, t1.getLatitudinalLod = function(t1) {
            const e1 = Hl - 5;
            t1 = M(t1, -e1, e1) / e1 * 90;
            const r = Math.pow(Math.abs(Math.sin(w(t1))), 3);
            return Math.round(r * (cl.length - 1));
        }, t1.getMapSessionAPI = Ft, t1.getPerformanceMeasurement = qt, t1.getProjection = Yd, t1.getRTLTextPluginStatus = xs, t1.getReferrer = ct, t1.getTilePoint = function(t1, { x: e1, y: r }, n = 0) {
            return new x(((e1 - n) * t1.scale - t1.x) * ao, (r * t1.scale - t1.y) * ao);
        }, t1.getTileVec3 = function(t1, e1, r = 0) {
            return Io(((e1.x - r) * t1.scale - t1.x) * ao, (e1.y * t1.scale - t1.y) * ao, Jl(e1.z, e1.y));
        }, t1.getVideo = function(t1, r) {
            const n = e1.document.createElement("video");
            n.muted = !0, n.onloadstart = function() {
                r(null, n);
            };
            for(let r = 0; r < t1.length; r++){
                const i = e1.document.createElement("source");
                dt(t1[r]) || (n.crossOrigin = "Anonymous"), i.src = t1[r], n.appendChild(i);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.globeCenterToScreenPoint = function(t1) {
            const e1 = [
                0,
                0,
                0
            ], r = po(new Float64Array(16));
            return yo(r, t1.pixelMatrix, t1.globeMatrix), Fo(e1, e1, r), new x(e1[0], e1[1]);
        }, t1.globeDenormalizeECEF = El, t1.globeECEFOrigin = function(t1, e1) {
            const r = [
                0,
                0,
                0
            ];
            return Fo(r, r, Bl(xl(e1.canonical))), Fo(r, r, t1), r;
        }, t1.globeMetersToEcef = fl, t1.globeNormalizeECEF = Bl, t1.globePixelsToTileUnits = function(t1, e1) {
            return ao / (512 * Math.pow(2, t1)) * Tl(xl(e1));
        }, t1.globePoleMatrixForTile = function(t1, e1, r) {
            const n = po(new Float64Array(16)), i = (e1 / (1 << t1) - .5) * Math.PI * 2;
            return vo(n, r.globeMatrix, i), Float32Array.from(n);
        }, t1.globeTileBounds = xl, t1.globeTiltAtLngLat = Dl, t1.globeToMercatorTransition = Pl, t1.globeUseCustomAntiAliasing = function(t1, e1, r) {
            const n = Pl(r.zoom), i = t1.style.map._antialias, s = !!e1.extStandardDerivatives, a = e1.extStandardDerivativesForceOff || t1.terrain && t1.terrain.exaggeration() > 0;
            return 0 === n && !i && !a && s;
        }, t1.identity = po, t1.identity$1 = Ko, t1.invert = fo, t1.isFullscreen = function() {
            return !!e1.document.fullscreenElement || !!e1.document.webkitFullscreenElement;
        }, t1.isLngLatBehindGlobe = Vl, t1.isMapAuthenticated = function(t1) {
            return Rt.has(t1);
        }, t1.isMapboxURL = vt, t1.isSafariWithAntialiasingBug = function(t1) {
            const e1 = t1.navigator ? t1.navigator.userAgent : null;
            return !!H(t1) && e1 && (e1.match("Version/15.4") || e1.match("Version/15.5") || e1.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t1.latFromMercatorY = Xl, t1.latLngToECEF = Il, t1.len = Oo, t1.length = ko, t1.length$1 = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
        }, t1.lngFromMercatorX = Kl, t1.loadVectorTile = yy, t1.makeRequest = ht, t1.mapValue = function(t1, e1, r, n, i) {
            return M((t1 - e1) / (r - e1) * (i - n) + n, n, i);
        }, t1.mercatorScale = Yl, t1.mercatorXfromLng = Nl, t1.mercatorYfromLat = Gl, t1.mercatorZfromAltitude = Zl, t1.mul = _o, t1.mul$1 = jo, t1.multiply = yo, t1.multiply$1 = ho, t1.multiply$2 = zo, t1.nextPowerOfTwo = L, t1.normalize = Do, t1.normalize$1 = Ho, t1.normalize$2 = No, t1.number = Er, t1.ortho = function(t1, e1, r, n, i, s, a) {
            var o = 1 / (e1 - r), l = 1 / (n - i), u = 1 / (s - a);
            return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e1 + r) * o, t1[13] = (i + n) * l, t1[14] = (a + s) * u, t1[15] = 1, t1;
        }, t1.pbf = Xh, t1.perspective = function(t1, e1, r, n, i) {
            var s, a = 1 / Math.tan(e1 / 2);
            return t1[0] = a / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = a, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = (i + n) * (s = 1 / (n - i)), t1[14] = 2 * i * n * s) : (t1[10] = -1, t1[14] = -2 * n), t1;
        }, t1.pick = function(t1, e1) {
            const r = {};
            for(let n = 0; n < e1.length; n++){
                const i = e1[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.plugin = bs, t1.pointGeometry = m, t1.polesInViewport = function(t1) {
            const e1 = po(new Float64Array(16));
            yo(e1, t1.pixelMatrix, t1.globeMatrix);
            const r = [
                0,
                hl,
                0
            ], n = [
                0,
                pl,
                0
            ];
            return Fo(r, r, e1), Fo(n, n, e1), [
                r[0] > 0 && r[0] <= t1.width && r[1] > 0 && r[1] <= t1.height && !Vl(t1, new Ol(t1.center.lat, 90)),
                n[0] > 0 && n[0] <= t1.width && n[1] > 0 && n[1] <= t1.height && !Vl(t1, new Ol(t1.center.lat, -90))
            ];
        }, t1.polygonContainsPoint = bu, t1.polygonIntersectsBox = wu, t1.polygonIntersectsPolygon = hu, t1.polygonizeBounds = function(t1, e1, r = 0, n = !0) {
            const i = new x(r, r), s = t1.sub(i), a = e1.add(i), o = [
                s,
                new x(a.x, s.y),
                a,
                new x(s.x, a.y)
            ];
            return n && o.push(s.clone()), o;
        }, t1.posAttributes = tl, t1.postMapLoadEvent = Pt, t1.postPerformanceEvent = Vt, t1.postTurnstileEvent = Et, t1.potpack = _p, t1.prevPowerOfTwo = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t1) / Math.LN2));
        }, t1.radToDeg = _, t1.refProperties = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.registerForPluginStateChange = function(t1) {
            return t1({
                pluginStatus: ds,
                pluginURL: fs
            }), gs.on("pluginStateChange", t1), t1;
        }, t1.removeAuthState = function(t1) {
            Rt.delete(t1);
        }, t1.renderColorRamp = ju, t1.resample = tu, t1.rotateX = xo, t1.rotateX$1 = Xo, t1.rotateY = vo, t1.rotateY$1 = Jo, t1.rotateZ = function(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e1[0], a = e1[1], o = e1[2], l = e1[3], u = e1[4], c = e1[5], h = e1[6], p = e1[7];
            return e1 !== t1 && (t1[8] = e1[8], t1[9] = e1[9], t1[10] = e1[10], t1[11] = e1[11], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[0] = s * i + u * n, t1[1] = a * i + c * n, t1[2] = o * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - s * n, t1[5] = c * i - a * n, t1[6] = h * i - o * n, t1[7] = p * i - l * n, t1;
        }, t1.rotateZ$1 = function(t1, e1, r) {
            r *= .5;
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + i * o, t1[1] = i * l - n * o, t1[2] = s * l + a * o, t1[3] = a * l - s * o, t1;
        }, t1.scale = go, t1.scale$1 = qo, t1.scale$2 = Co, t1.scaleAndAdd = Po, t1.set = function(t1, e1, r, n) {
            return t1[0] = e1, t1[1] = r, t1[2] = n, t1;
        }, t1.setCacheLimits = function(t1, e1) {
            tt = t1, et = e1;
        }, t1.setColumn = function(t1, e1, r) {
            t1[4 * e1 + 0] = r[0], t1[4 * e1 + 1] = r[1], t1[4 * e1 + 2] = r[2], t1[4 * e1 + 3] = r[3];
        }, t1.setRTLTextPlugin = function(t1, e1, r = !1) {
            if (ds === us || ds === cs || ds === hs) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            fs = Xt.resolveURL(t1), ds = us, ps = e1, ms(), r || vs();
        }, t1.smoothstep = T, t1.spec = te, t1.squaredLength = function(t1) {
            var e1 = t1[0], r = t1[1], n = t1[2];
            return e1 * e1 + r * r + n * n;
        }, t1.storeAuthState = function(t1, e1) {
            e1 ? Rt.add(t1) : Rt.delete(t1);
        }, t1.sub = $o, t1.subtract = To, t1.symbolSize = qh, t1.tileAABB = function(t1, e1, r, n, i, s, a, o, l) {
            if ("globe" === l.name) return _l(t1, e1, new ph(r, n, i));
            const u = Bd({
                z: r,
                x: n,
                y: i
            }, l);
            return new il([
                (s + u.x / u.scale) * e1,
                e1 * (u.y / u.scale),
                a
            ], [
                (s + u.x2 / u.scale) * e1,
                e1 * (u.y2 / u.scale),
                o
            ]);
        }, t1.tileCornersToBounds = Al, t1.tileTransform = Bd, t1.transformMat3 = function(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2];
            return t1[0] = n * r[0] + i * r[3] + s * r[6], t1[1] = n * r[1] + i * r[4] + s * r[7], t1[2] = n * r[2] + i * r[5] + s * r[8], t1;
        }, t1.transformMat4 = Fo, t1.transformMat4$1 = Go, t1.transformQuat = Ro, t1.transitionTileAABBinECEF = bl, t1.translate = mo, t1.transpose = function(t1, e1) {
            if (t1 === e1) {
                var r = e1[1], n = e1[2], i = e1[5];
                t1[1] = e1[3], t1[2] = e1[6], t1[3] = r, t1[5] = e1[7], t1[6] = n, t1[7] = i;
            } else t1[0] = e1[0], t1[1] = e1[3], t1[2] = e1[6], t1[3] = e1[1], t1[4] = e1[4], t1[5] = e1[7], t1[6] = e1[2], t1[7] = e1[5], t1[8] = e1[8];
            return t1;
        }, t1.triggerPluginCompletionEvent = ys, t1.uniqueId = D, t1.updateGlobeVertexNormal = function(t1, e1, r, n, i) {
            const s = 5 * e1 + 2;
            t1.float32[s + 0] = r, t1.float32[s + 1] = n, t1.float32[s + 2] = i;
        }, t1.validateCustomStyleLayer = function(t1) {
            const e1 = [], r = t1.id;
            return void 0 === r && e1.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e1.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e1.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e1;
        }, t1.validateFilter = (t1)=>Oi(Ai(t1)), t1.validateFog = (t1)=>Oi(Vi(t1)), t1.validateLayer = (t1)=>Oi(Ti(t1)), t1.validateLight = (t1)=>Oi(Pi(t1)), t1.validateSource = (t1)=>Oi(Ei(t1)), t1.validateStyle = Ui, t1.validateTerrain = (t1)=>Oi(Di(t1)), t1.values = E, t1.vectorTile = Dc, t1.version = r, t1.warnOnce = N, t1.window = e1, t1.wrap = z;
    });
    define([
        "./shared"
    ], function(e1) {
        "use strict";
        function t1(e1) {
            if ("number" == typeof e1 || "boolean" == typeof e1 || "string" == typeof e1 || null == e1) return JSON.stringify(e1);
            if (Array.isArray(e1)) {
                let r = "[";
                for (const o of e1)r += `${t1(o)},`;
                return `${r}]`;
            }
            let r = "{";
            for (const o of Object.keys(e1).sort())r += `${o}:${t1(e1[o])},`;
            return `${r}}`;
        }
        function r(r) {
            let o = "";
            for (const i of e1.refProperties)o += `/${t1(r[i])}`;
            return o;
        }
        class o {
            constructor(e1){
                this.keyCache = {}, e1 && this.replace(e1);
            }
            replace(e1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e1, []);
            }
            update(t1, o) {
                for (const r of t1)this._layerConfigs[r.id] = r, (this._layers[r.id] = e1.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];
                for (const e1 of o)delete this.keyCache[e1], delete this._layerConfigs[e1], delete this._layers[e1];
                this.familiesBySource = {};
                const i = function(e1, t1) {
                    const o = {};
                    for(let i = 0; i < e1.length; i++){
                        const n = t1 && t1[e1[i].id] || r(e1[i]);
                        t1 && (t1[e1[i].id] = n);
                        let s = o[n];
                        s || (s = o[n] = []), s.push(e1[i]);
                    }
                    const i = [];
                    for(const e1 in o)i.push(o[e1]);
                    return i;
                }(e1.values(this._layerConfigs), this.keyCache);
                for (const e1 of i){
                    const t1 = e1.map((e1)=>this._layers[e1.id]), r = t1[0];
                    if ("none" === r.visibility) continue;
                    const o = r.source || "";
                    let i = this.familiesBySource[o];
                    i || (i = this.familiesBySource[o] = {});
                    const n = r.sourceLayer || "_geojsonTileLayer";
                    let s = i[n];
                    s || (s = i[n] = []), s.push(t1);
                }
            }
        }
        class i {
            loadTile(t1, r) {
                const { uid: o, encoding: i, rawImageData: n, padding: s, buildQuadTree: a } = t1, l = e1.window.ImageBitmap && n instanceof e1.window.ImageBitmap ? this.getImageData(n, s) : n;
                r(null, new e1.DEMData(o, l, i, s < 1, a));
            }
            getImageData(e1, t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e1.width, e1.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e1.width, this.offscreenCanvas.height = e1.height, this.offscreenCanvasContext.drawImage(e1, 0, 0, e1.width, e1.height);
                const r = this.offscreenCanvasContext.getImageData(-t1, -t1, e1.width + 2 * t1, e1.height + 2 * t1);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;
            }
        }
        function n(e1, t1) {
            if (0 !== e1.length) {
                s(e1[0], t1);
                for(var r = 1; r < e1.length; r++)s(e1[r], !t1);
            }
        }
        function s(e1, t1) {
            for(var r = 0, o = 0, i = 0, n = e1.length, s = n - 1; i < n; s = i++){
                var a = (e1[i][0] - e1[s][0]) * (e1[s][1] + e1[i][1]), l = r + a;
                o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;
            }
            r + o >= 0 != !!t1 && e1.reverse();
        }
        var a = e1.getDefaultExportFromCjs(function e1(t1, r) {
            var o, i = t1 && t1.type;
            if ("FeatureCollection" === i) for(o = 0; o < t1.features.length; o++)e1(t1.features[o], r);
            else if ("GeometryCollection" === i) for(o = 0; o < t1.geometries.length; o++)e1(t1.geometries[o], r);
            else if ("Feature" === i) e1(t1.geometry, r);
            else if ("Polygon" === i) n(t1.coordinates, r);
            else if ("MultiPolygon" === i) for(o = 0; o < t1.coordinates.length; o++)n(t1.coordinates[o], r);
            return t1;
        });
        const l = e1.VectorTileFeature.prototype.toGeoJSON;
        var u = {
            exports: {}
        }, h = e1.pointGeometry, c = e1.vectorTile.VectorTileFeature, f = p;
        function p(e1, t1) {
            this.options = t1 || {}, this.features = e1, this.length = e1.length;
        }
        function g(e1, t1) {
            this.id = "number" == typeof e1.id ? e1.id : void 0, this.type = e1.type, this.rawGeometry = 1 === e1.type ? [
                e1.geometry
            ] : e1.geometry, this.properties = e1.tags, this.extent = t1 || 4096;
        }
        p.prototype.feature = function(e1) {
            return new g(this.features[e1], this.options.extent);
        }, g.prototype.loadGeometry = function() {
            var e1 = this.rawGeometry;
            this.geometry = [];
            for(var t1 = 0; t1 < e1.length; t1++){
                for(var r = e1[t1], o = [], i = 0; i < r.length; i++)o.push(new h(r[i][0], r[i][1]));
                this.geometry.push(o);
            }
            return this.geometry;
        }, g.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for(var e1 = this.geometry, t1 = 1 / 0, r = -1 / 0, o = 1 / 0, i = -1 / 0, n = 0; n < e1.length; n++)for(var s = e1[n], a = 0; a < s.length; a++){
                var l = s[a];
                t1 = Math.min(t1, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), i = Math.max(i, l.y);
            }
            return [
                t1,
                o,
                r,
                i
            ];
        }, g.prototype.toGeoJSON = c.prototype.toGeoJSON;
        var d = e1.pbf, m = f;
        function y(e1) {
            var t1 = new d;
            return function(e1, t1) {
                for(var r in e1.layers)t1.writeMessage(3, v, e1.layers[r]);
            }(e1, t1), t1.finish();
        }
        function v(e1, t1) {
            var r;
            t1.writeVarintField(15, e1.version || 1), t1.writeStringField(1, e1.name || ""), t1.writeVarintField(5, e1.extent || 4096);
            var o = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
            };
            for(r = 0; r < e1.length; r++)o.feature = e1.feature(r), t1.writeMessage(2, x, o);
            var i = o.keys;
            for(r = 0; r < i.length; r++)t1.writeStringField(3, i[r]);
            var n = o.values;
            for(r = 0; r < n.length; r++)t1.writeMessage(4, b, n[r]);
        }
        function x(e1, t1) {
            var r = e1.feature;
            void 0 !== r.id && t1.writeVarintField(1, r.id), t1.writeMessage(2, w, e1), t1.writeVarintField(3, r.type), t1.writeMessage(4, P, r);
        }
        function w(e1, t1) {
            var r = e1.feature, o = e1.keys, i = e1.values, n = e1.keycache, s = e1.valuecache;
            for(var a in r.properties){
                var l = r.properties[a], u = n[a];
                if (null !== l) {
                    void 0 === u && (o.push(a), n[a] = u = o.length - 1), t1.writeVarint(u);
                    var h = typeof l;
                    "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
                    var c = h + ":" + l, f = s[c];
                    void 0 === f && (i.push(l), s[c] = f = i.length - 1), t1.writeVarint(f);
                }
            }
        }
        function S(e1, t1) {
            return (t1 << 3) + (7 & e1);
        }
        function M(e1) {
            return e1 << 1 ^ e1 >> 31;
        }
        function P(e1, t1) {
            for(var r = e1.loadGeometry(), o = e1.type, i = 0, n = 0, s = r.length, a = 0; a < s; a++){
                var l = r[a], u = 1;
                1 === o && (u = l.length), t1.writeVarint(S(1, u));
                for(var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++){
                    1 === c && 1 !== o && t1.writeVarint(S(2, h - 1));
                    var f = l[c].x - i, p = l[c].y - n;
                    t1.writeVarint(M(f)), t1.writeVarint(M(p)), i += f, n += p;
                }
                3 === o && t1.writeVarint(S(7, 1));
            }
        }
        function b(e1, t1) {
            var r = typeof e1;
            "string" === r ? t1.writeStringField(1, e1) : "boolean" === r ? t1.writeBooleanField(7, e1) : "number" === r && (e1 % 1 != 0 ? t1.writeDoubleField(3, e1) : e1 < 0 ? t1.writeSVarintField(6, e1) : t1.writeVarintField(5, e1));
        }
        u.exports = y, u.exports.fromVectorTileJs = y, u.exports.fromGeojsonVt = function(e1, t1) {
            t1 = t1 || {};
            var r = {};
            for(var o in e1)r[o] = new m(e1[o].features, t1), r[o].name = o, r[o].version = t1.version, r[o].extent = t1.extent;
            return y({
                layers: r
            });
        }, u.exports.GeoJSONWrapper = m;
        var T = e1.getDefaultExportFromCjs(u.exports);
        const k = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e1)=>e1
        }, I = Math.fround || (_ = new Float32Array(1), (e1)=>(_[0] = +e1, _[0]));
        var _;
        const C = 3, L = 5, O = 6;
        class E {
            constructor(e1){
                this.options = Object.assign(Object.create(k), e1), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e1) {
                const { log: t1, minZoom: r, maxZoom: o } = this.options;
                t1 && console.time("total time");
                const i = `prepare ${e1.length} points`;
                t1 && console.time(i), this.points = e1;
                const n = [];
                for(let t1 = 0; t1 < e1.length; t1++){
                    const r = e1[t1];
                    if (!r.geometry) continue;
                    const [o, i] = r.geometry.coordinates, s = I(N(o)), a = I(Z(i));
                    n.push(s, a, 1 / 0, t1, -1, 1), this.options.reduce && n.push(0);
                }
                let s = this.trees[o + 1] = this._createTree(n);
                t1 && console.timeEnd(i);
                for(let e1 = o; e1 >= r; e1--){
                    const r = +Date.now();
                    s = this.trees[e1] = this._createTree(this._cluster(s, e1)), t1 && console.log("z%d: %d clusters in %dms", e1, s.numItems, +Date.now() - r);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e1, t1) {
                let r = ((e1[0] + 180) % 360 + 360) % 360 - 180;
                const o = Math.max(-90, Math.min(90, e1[1]));
                let i = 180 === e1[2] ? 180 : ((e1[2] + 180) % 360 + 360) % 360 - 180;
                const n = Math.max(-90, Math.min(90, e1[3]));
                if (e1[2] - e1[0] >= 360) r = -180, i = 180;
                else if (r > i) {
                    const e1 = this.getClusters([
                        r,
                        o,
                        180,
                        n
                    ], t1), s = this.getClusters([
                        -180,
                        o,
                        i,
                        n
                    ], t1);
                    return e1.concat(s);
                }
                const s = this.trees[this._limitZoom(t1)], a = s.range(N(r), Z(n), N(i), Z(o)), l = s.data, u = [];
                for (const e1 of a){
                    const t1 = this.stride * e1;
                    u.push(l[t1 + L] > 1 ? j(l, t1, this.clusterProps) : this.points[l[t1 + C]]);
                }
                return u;
            }
            getChildren(e1) {
                const t1 = this._getOriginId(e1), r = this._getOriginZoom(e1), o = "No cluster with the specified id.", i = this.trees[r];
                if (!i) throw new Error(o);
                const n = i.data;
                if (t1 * this.stride >= n.length) throw new Error(o);
                const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = i.within(n[t1 * this.stride], n[t1 * this.stride + 1], s), l = [];
                for (const t1 of a){
                    const r = t1 * this.stride;
                    n[r + 4] === e1 && l.push(n[r + L] > 1 ? j(n, r, this.clusterProps) : this.points[n[r + C]]);
                }
                if (0 === l.length) throw new Error(o);
                return l;
            }
            getLeaves(e1, t1, r) {
                const o = [];
                return this._appendLeaves(o, e1, t1 = t1 || 10, r = r || 0, 0), o;
            }
            getTile(e1, t1, r) {
                const o = this.trees[this._limitZoom(e1)], i = Math.pow(2, e1), { extent: n, radius: s } = this.options, a = s / n, l = (r - a) / i, u = (r + 1 + a) / i, h = {
                    features: []
                };
                return this._addTileFeatures(o.range((t1 - a) / i, l, (t1 + 1 + a) / i, u), o.data, t1, r, i, h), 0 === t1 && this._addTileFeatures(o.range(1 - a / i, l, 1, u), o.data, i, r, i, h), t1 === i - 1 && this._addTileFeatures(o.range(0, l, a / i, u), o.data, -1, r, i, h), h.features.length ? h : null;
            }
            getClusterExpansionZoom(e1) {
                let t1 = this._getOriginZoom(e1) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const r = this.getChildren(e1);
                    if (t1++, 1 !== r.length) break;
                    e1 = r[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e1, t1, r, o, i) {
                const n = this.getChildren(t1);
                for (const t1 of n){
                    const n = t1.properties;
                    if (n && n.cluster ? i + n.point_count <= o ? i += n.point_count : i = this._appendLeaves(e1, n.cluster_id, r, o, i) : i < o ? i++ : e1.push(t1), e1.length === r) break;
                }
                return i;
            }
            _createTree(t1) {
                const r = new e1.KDBush(t1.length / this.stride | 0, this.options.nodeSize, Float32Array);
                for(let e1 = 0; e1 < t1.length; e1 += this.stride)r.add(t1[e1], t1[e1 + 1]);
                return r.finish(), r.data = t1, r;
            }
            _addTileFeatures(e1, t1, r, o, i, n) {
                for (const s of e1){
                    const e1 = s * this.stride, a = t1[e1 + L] > 1;
                    let l, u, h;
                    if (a) l = F(t1, e1, this.clusterProps), u = t1[e1], h = t1[e1 + 1];
                    else {
                        const r = this.points[t1[e1 + C]];
                        l = r.properties;
                        const [o, i] = r.geometry.coordinates;
                        u = N(o), h = Z(i);
                    }
                    const c = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (u * i - r)),
                                Math.round(this.options.extent * (h * i - o))
                            ]
                        ],
                        tags: l
                    };
                    let f;
                    f = a || this.options.generateId ? t1[e1 + C] : this.points[t1[e1 + C]].id, void 0 !== f && (c.id = f), n.features.push(c);
                }
            }
            _limitZoom(e1) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e1), this.options.maxZoom + 1));
            }
            _cluster(e1, t1) {
                const { radius: r, extent: o, reduce: i, minPoints: n } = this.options, s = r / (o * Math.pow(2, t1)), a = e1.data, l = [], u = this.stride;
                for(let r = 0; r < a.length; r += u){
                    if (a[r + 2] <= t1) continue;
                    a[r + 2] = t1;
                    const o = a[r], h = a[r + 1], c = e1.within(a[r], a[r + 1], s), f = a[r + L];
                    let p = f;
                    for (const e1 of c){
                        const r = e1 * u;
                        a[r + 2] > t1 && (p += a[r + L]);
                    }
                    if (p > f && p >= n) {
                        let e1, n = o * f, s = h * f, g = -1;
                        const d = ((r / u | 0) << 5) + (t1 + 1) + this.points.length;
                        for (const o of c){
                            const l = o * u;
                            if (a[l + 2] <= t1) continue;
                            a[l + 2] = t1;
                            const h = a[l + L];
                            n += a[l] * h, s += a[l + 1] * h, a[l + 4] = d, i && (e1 || (e1 = this._map(a, r, !0), g = this.clusterProps.length, this.clusterProps.push(e1)), i(e1, this._map(a, l)));
                        }
                        a[r + 4] = d, l.push(n / p, s / p, 1 / 0, d, -1, p), i && l.push(g);
                    } else {
                        for(let e1 = 0; e1 < u; e1++)l.push(a[r + e1]);
                        if (p > 1) for (const e1 of c){
                            const r = e1 * u;
                            if (!(a[r + 2] <= t1)) {
                                a[r + 2] = t1;
                                for(let e1 = 0; e1 < u; e1++)l.push(a[r + e1]);
                            }
                        }
                    }
                }
                return l;
            }
            _getOriginId(e1) {
                return e1 - this.points.length >> 5;
            }
            _getOriginZoom(e1) {
                return (e1 - this.points.length) % 32;
            }
            _map(e1, t1, r) {
                if (e1[t1 + L] > 1) {
                    const o = this.clusterProps[e1[t1 + O]];
                    return r ? Object.assign({}, o) : o;
                }
                const o = this.points[e1[t1 + C]].properties, i = this.options.map(o);
                return r && i === o ? Object.assign({}, i) : i;
            }
        }
        function j(e1, t1, r) {
            var o;
            return {
                type: "Feature",
                id: e1[t1 + C],
                properties: F(e1, t1, r),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (o = e1[t1], 360 * (o - .5)),
                        J(e1[t1 + 1])
                    ]
                }
            };
        }
        function F(e1, t1, r) {
            const o = e1[t1 + L], i = o >= 1e4 ? `${Math.round(o / 1e3)}k` : o >= 1e3 ? Math.round(o / 100) / 10 + "k" : o, n = e1[t1 + O], s = -1 === n ? {} : Object.assign({}, r[n]);
            return Object.assign(s, {
                cluster: !0,
                cluster_id: e1[t1 + C],
                point_count: o,
                point_count_abbreviated: i
            });
        }
        function N(e1) {
            return e1 / 360 + .5;
        }
        function Z(e1) {
            const t1 = Math.sin(e1 * Math.PI / 180), r = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return r < 0 ? 0 : r > 1 ? 1 : r;
        }
        function J(e1) {
            const t1 = (180 - 360 * e1) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function z(e1, t1, r, o) {
            for(var i, n = o, s = r - t1 >> 1, a = r - t1, l = e1[t1], u = e1[t1 + 1], h = e1[r], c = e1[r + 1], f = t1 + 3; f < r; f += 3){
                var p = G(e1[f], e1[f + 1], l, u, h, c);
                if (p > n) i = f, n = p;
                else if (p === n) {
                    var g = Math.abs(f - s);
                    g < a && (i = f, a = g);
                }
            }
            n > o && (i - t1 > 3 && z(e1, t1, i, o), e1[i + 2] = n, r - i > 3 && z(e1, i, r, o));
        }
        function G(e1, t1, r, o, i, n) {
            var s = i - r, a = n - o;
            if (0 !== s || 0 !== a) {
                var l = ((e1 - r) * s + (t1 - o) * a) / (s * s + a * a);
                l > 1 ? (r = i, o = n) : l > 0 && (r += s * l, o += a * l);
            }
            return (s = e1 - r) * s + (a = t1 - o) * a;
        }
        function W(e1, t1, r, o) {
            var i = {
                id: void 0 === e1 ? null : e1,
                type: t1,
                geometry: r,
                tags: o,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return function(e1) {
                var t1 = e1.geometry, r = e1.type;
                if ("Point" === r || "MultiPoint" === r || "LineString" === r) Y(e1, t1);
                else if ("Polygon" === r || "MultiLineString" === r) for(var o = 0; o < t1.length; o++)Y(e1, t1[o]);
                else if ("MultiPolygon" === r) for(o = 0; o < t1.length; o++)for(var i = 0; i < t1[o].length; i++)Y(e1, t1[o][i]);
            }(i), i;
        }
        function Y(e1, t1) {
            for(var r = 0; r < t1.length; r += 3)e1.minX = Math.min(e1.minX, t1[r]), e1.minY = Math.min(e1.minY, t1[r + 1]), e1.maxX = Math.max(e1.maxX, t1[r]), e1.maxY = Math.max(e1.maxY, t1[r + 1]);
        }
        function X(e1, t1, r, o) {
            if (t1.geometry) {
                var i = t1.geometry.coordinates, n = t1.geometry.type, s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2), a = [], l = t1.id;
                if (r.promoteId ? l = t1.properties[r.promoteId] : r.generateId && (l = o || 0), "Point" === n) V(i, a);
                else if ("MultiPoint" === n) for(var u = 0; u < i.length; u++)V(i[u], a);
                else if ("LineString" === n) D(i, a, s, !1);
                else if ("MultiLineString" === n) {
                    if (r.lineMetrics) {
                        for(u = 0; u < i.length; u++)D(i[u], a = [], s, !1), e1.push(W(l, "LineString", a, t1.properties));
                        return;
                    }
                    $(i, a, s, !1);
                } else if ("Polygon" === n) $(i, a, s, !0);
                else {
                    if ("MultiPolygon" !== n) {
                        if ("GeometryCollection" === n) {
                            for(u = 0; u < t1.geometry.geometries.length; u++)X(e1, {
                                id: l,
                                geometry: t1.geometry.geometries[u],
                                properties: t1.properties
                            }, r, o);
                            return;
                        }
                        throw new Error("Input data is not a valid GeoJSON object.");
                    }
                    for(u = 0; u < i.length; u++){
                        var h = [];
                        $(i[u], h, s, !0), a.push(h);
                    }
                }
                e1.push(W(l, n, a, t1.properties));
            }
        }
        function V(e1, t1) {
            t1.push(A(e1[0])), t1.push(B(e1[1])), t1.push(0);
        }
        function D(e1, t1, r, o) {
            for(var i, n, s = 0, a = 0; a < e1.length; a++){
                var l = A(e1[a][0]), u = B(e1[a][1]);
                t1.push(l), t1.push(u), t1.push(0), a > 0 && (s += o ? (i * u - l * n) / 2 : Math.sqrt(Math.pow(l - i, 2) + Math.pow(u - n, 2))), i = l, n = u;
            }
            var h = t1.length - 3;
            t1[2] = 1, z(t1, 0, h, r), t1[h + 2] = 1, t1.size = Math.abs(s), t1.start = 0, t1.end = t1.size;
        }
        function $(e1, t1, r, o) {
            for(var i = 0; i < e1.length; i++){
                var n = [];
                D(e1[i], n, r, o), t1.push(n);
            }
        }
        function A(e1) {
            return e1 / 360 + .5;
        }
        function B(e1) {
            var t1 = Math.sin(e1 * Math.PI / 180), r = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return r < 0 ? 0 : r > 1 ? 1 : r;
        }
        function R(e1, t1, r, o, i, n, s, a) {
            if (o /= t1, n >= (r /= t1) && s < o) return e1;
            if (s < r || n >= o) return null;
            for(var l = [], u = 0; u < e1.length; u++){
                var h = e1[u], c = h.geometry, f = h.type, p = 0 === i ? h.minX : h.minY, g = 0 === i ? h.maxX : h.maxY;
                if (p >= r && g < o) l.push(h);
                else if (!(g < r || p >= o)) {
                    var d = [];
                    if ("Point" === f || "MultiPoint" === f) q(c, d, r, o, i);
                    else if ("LineString" === f) Q(c, d, r, o, i, !1, a.lineMetrics);
                    else if ("MultiLineString" === f) K(c, d, r, o, i, !1);
                    else if ("Polygon" === f) K(c, d, r, o, i, !0);
                    else if ("MultiPolygon" === f) for(var m = 0; m < c.length; m++){
                        var y = [];
                        K(c[m], y, r, o, i, !0), y.length && d.push(y);
                    }
                    if (d.length) {
                        if (a.lineMetrics && "LineString" === f) {
                            for(m = 0; m < d.length; m++)l.push(W(h.id, f, d[m], h.tags));
                            continue;
                        }
                        "LineString" !== f && "MultiLineString" !== f || (1 === d.length ? (f = "LineString", d = d[0]) : f = "MultiLineString"), "Point" !== f && "MultiPoint" !== f || (f = 3 === d.length ? "Point" : "MultiPoint"), l.push(W(h.id, f, d, h.tags));
                    }
                }
            }
            return l.length ? l : null;
        }
        function q(e1, t1, r, o, i) {
            for(var n = 0; n < e1.length; n += 3){
                var s = e1[n + i];
                s >= r && s <= o && (t1.push(e1[n]), t1.push(e1[n + 1]), t1.push(e1[n + 2]));
            }
        }
        function Q(e1, t1, r, o, i, n, s) {
            for(var a, l, u = U(e1), h = 0 === i ? ee : te, c = e1.start, f = 0; f < e1.length - 3; f += 3){
                var p = e1[f], g = e1[f + 1], d = e1[f + 2], m = e1[f + 3], y = e1[f + 4], v = 0 === i ? p : g, x = 0 === i ? m : y, w = !1;
                s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : H(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !n && w && (s && (u.end = c + a * l), t1.push(u), u = U(e1)), s && (c += a);
            }
            var S = e1.length - 3;
            p = e1[S], g = e1[S + 1], d = e1[S + 2], (v = 0 === i ? p : g) >= r && v <= o && H(u, p, g, d), S = u.length - 3, n && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && H(u, u[0], u[1], u[2]), u.length && t1.push(u);
        }
        function U(e1) {
            var t1 = [];
            return t1.size = e1.size, t1.start = e1.start, t1.end = e1.end, t1;
        }
        function K(e1, t1, r, o, i, n) {
            for(var s = 0; s < e1.length; s++)Q(e1[s], t1, r, o, i, n, !1);
        }
        function H(e1, t1, r, o) {
            e1.push(t1), e1.push(r), e1.push(o);
        }
        function ee(e1, t1, r, o, i, n) {
            var s = (n - t1) / (o - t1);
            return e1.push(n), e1.push(r + (i - r) * s), e1.push(1), s;
        }
        function te(e1, t1, r, o, i, n) {
            var s = (n - r) / (i - r);
            return e1.push(t1 + (o - t1) * s), e1.push(n), e1.push(1), s;
        }
        function re(e1, t1) {
            for(var r = [], o = 0; o < e1.length; o++){
                var i, n = e1[o], s = n.type;
                if ("Point" === s || "MultiPoint" === s || "LineString" === s) i = oe(n.geometry, t1);
                else if ("MultiLineString" === s || "Polygon" === s) {
                    i = [];
                    for(var a = 0; a < n.geometry.length; a++)i.push(oe(n.geometry[a], t1));
                } else if ("MultiPolygon" === s) for(i = [], a = 0; a < n.geometry.length; a++){
                    for(var l = [], u = 0; u < n.geometry[a].length; u++)l.push(oe(n.geometry[a][u], t1));
                    i.push(l);
                }
                r.push(W(n.id, s, i, n.tags));
            }
            return r;
        }
        function oe(e1, t1) {
            var r = [];
            r.size = e1.size, void 0 !== e1.start && (r.start = e1.start, r.end = e1.end);
            for(var o = 0; o < e1.length; o += 3)r.push(e1[o] + t1, e1[o + 1], e1[o + 2]);
            return r;
        }
        function ie(e1, t1) {
            if (e1.transformed) return e1;
            var r, o, i, n = 1 << e1.z, s = e1.x, a = e1.y;
            for(r = 0; r < e1.features.length; r++){
                var l = e1.features[r], u = l.geometry, h = l.type;
                if (l.geometry = [], 1 === h) for(o = 0; o < u.length; o += 2)l.geometry.push(ne(u[o], u[o + 1], t1, n, s, a));
                else for(o = 0; o < u.length; o++){
                    var c = [];
                    for(i = 0; i < u[o].length; i += 2)c.push(ne(u[o][i], u[o][i + 1], t1, n, s, a));
                    l.geometry.push(c);
                }
            }
            return e1.transformed = !0, e1;
        }
        function ne(e1, t1, r, o, i, n) {
            return [
                Math.round(r * (e1 * o - i)),
                Math.round(r * (t1 * o - n))
            ];
        }
        function se(e1, t1, r, o, i) {
            for(var n = t1 === i.maxZoom ? 0 : i.tolerance / ((1 << t1) * i.extent), s = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: 0,
                source: null,
                x: r,
                y: o,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            }, a = 0; a < e1.length; a++){
                s.numFeatures++, ae(s, e1[a], n, i);
                var l = e1[a].minX, u = e1[a].minY, h = e1[a].maxX, c = e1[a].maxY;
                l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);
            }
            return s;
        }
        function ae(e1, t1, r, o) {
            var i = t1.geometry, n = t1.type, s = [];
            if ("Point" === n || "MultiPoint" === n) for(var a = 0; a < i.length; a += 3)s.push(i[a]), s.push(i[a + 1]), e1.numPoints++, e1.numSimplified++;
            else if ("LineString" === n) le(s, i, e1, r, !1, !1);
            else if ("MultiLineString" === n || "Polygon" === n) for(a = 0; a < i.length; a++)le(s, i[a], e1, r, "Polygon" === n, 0 === a);
            else if ("MultiPolygon" === n) for(var l = 0; l < i.length; l++){
                var u = i[l];
                for(a = 0; a < u.length; a++)le(s, u[a], e1, r, !0, 0 === a);
            }
            if (s.length) {
                var h = t1.tags || null;
                if ("LineString" === n && o.lineMetrics) {
                    for(var c in h = {}, t1.tags)h[c] = t1.tags[c];
                    h.mapbox_clip_start = i.start / i.size, h.mapbox_clip_end = i.end / i.size;
                }
                var f = {
                    geometry: s,
                    type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,
                    tags: h
                };
                null !== t1.id && (f.id = t1.id), e1.features.push(f);
            }
        }
        function le(e1, t1, r, o, i, n) {
            var s = o * o;
            if (o > 0 && t1.size < (i ? s : o)) r.numPoints += t1.length / 3;
            else {
                for(var a = [], l = 0; l < t1.length; l += 3)(0 === o || t1[l + 2] > s) && (r.numSimplified++, a.push(t1[l]), a.push(t1[l + 1])), r.numPoints++;
                i && function(e1, t1) {
                    for(var r = 0, o = 0, i = e1.length, n = i - 2; o < i; n = o, o += 2)r += (e1[o] - e1[n]) * (e1[o + 1] + e1[n + 1]);
                    if (r > 0 === t1) for(o = 0, i = e1.length; o < i / 2; o += 2){
                        var s = e1[o], a = e1[o + 1];
                        e1[o] = e1[i - 2 - o], e1[o + 1] = e1[i - 1 - o], e1[i - 2 - o] = s, e1[i - 1 - o] = a;
                    }
                }(a, n), e1.push(a);
            }
        }
        function ue(e1, t1) {
            var r = (t1 = this.options = function(e1, t1) {
                for(var r in t1)e1[r] = t1[r];
                return e1;
            }(Object.create(this.options), t1)).debug;
            if (r && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
            var o = function(e1, t1) {
                var r = [];
                if ("FeatureCollection" === e1.type) for(var o = 0; o < e1.features.length; o++)X(r, e1.features[o], t1, o);
                else X(r, "Feature" === e1.type ? e1 : {
                    geometry: e1
                }, t1);
                return r;
            }(e1, t1);
            this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o = function(e1, t1) {
                var r = t1.buffer / t1.extent, o = e1, i = R(e1, 1, -1 - r, r, 0, -1, 2, t1), n = R(e1, 1, 1 - r, 2 + r, 0, -1, 2, t1);
                return (i || n) && (o = R(e1, 1, -r, 1 + r, 0, -1, 2, t1) || [], i && (o = re(i, 1).concat(o)), n && (o = o.concat(re(n, -1)))), o;
            }(o, t1), o.length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function he(e1, t1, r) {
            return 32 * ((1 << e1) * r + t1) + e1;
        }
        function ce(t1, r) {
            const o = t1.tileID.canonical;
            if (!this._geoJSONIndex) return r(null, null);
            const i = this._geoJSONIndex.getTile(o.z, o.x, o.y);
            if (!i) return r(null, null);
            const n = new class {
                constructor(t1){
                    this.layers = {
                        _geojsonTileLayer: this
                    }, this.name = "_geojsonTileLayer", this.extent = e1.EXTENT, this.length = t1.length, this._features = t1;
                }
                feature(t1) {
                    return new class {
                        constructor(t1){
                            this._feature = t1, this.extent = e1.EXTENT, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
                        }
                        loadGeometry() {
                            if (1 === this._feature.type) {
                                const t1 = [];
                                for (const r of this._feature.geometry)t1.push([
                                    new e1.Point(r[0], r[1])
                                ]);
                                return t1;
                            }
                            {
                                const t1 = [];
                                for (const r of this._feature.geometry){
                                    const o = [];
                                    for (const t1 of r)o.push(new e1.Point(t1[0], t1[1]));
                                    t1.push(o);
                                }
                                return t1;
                            }
                        }
                        toGeoJSON(e1, t1, r) {
                            return l.call(this, e1, t1, r);
                        }
                    }(this._features[t1]);
                }
            }(i.features);
            let s = T(n);
            0 === s.byteOffset && s.byteLength === s.buffer.byteLength || (s = new Uint8Array(s)), r(null, {
                vectorTile: n,
                rawData: s.buffer
            });
        }
        ue.prototype.options = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        }, ue.prototype.splitTile = function(e1, t1, r, o, i, n, s) {
            for(var a = [
                e1,
                t1,
                r,
                o
            ], l = this.options, u = l.debug; a.length;){
                o = a.pop(), r = a.pop(), t1 = a.pop(), e1 = a.pop();
                var h = 1 << t1, c = he(t1, r, o), f = this.tiles[c];
                if (!f && (u > 1 && console.time("creation"), f = this.tiles[c] = se(e1, t1, r, o, l), this.tileCoords.push({
                    z: t1,
                    x: r,
                    y: o
                }), u)) {
                    u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd("creation"));
                    var p = "z" + t1;
                    this.stats[p] = (this.stats[p] || 0) + 1, this.total++;
                }
                if (f.source = e1, i) {
                    if (t1 === l.maxZoom || t1 === i) continue;
                    var g = 1 << i - t1;
                    if (r !== Math.floor(n / g) || o !== Math.floor(s / g)) continue;
                } else if (t1 === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;
                if (f.source = null, 0 !== e1.length) {
                    u > 1 && console.time("clipping");
                    var d, m, y, v, x, w, S = .5 * l.buffer / l.extent, M = .5 - S, P = .5 + S, b = 1 + S;
                    d = m = y = v = null, x = R(e1, h, r - S, r + P, 0, f.minX, f.maxX, l), w = R(e1, h, r + M, r + b, 0, f.minX, f.maxX, l), e1 = null, x && (d = R(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = R(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = R(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = R(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(d || [], t1 + 1, 2 * r, 2 * o), a.push(m || [], t1 + 1, 2 * r, 2 * o + 1), a.push(y || [], t1 + 1, 2 * r + 1, 2 * o), a.push(v || [], t1 + 1, 2 * r + 1, 2 * o + 1);
                }
            }
        }, ue.prototype.getTile = function(e1, t1, r) {
            var o = this.options, i = o.extent, n = o.debug;
            if (e1 < 0 || e1 > 24) return null;
            var s = 1 << e1, a = he(e1, t1 = (t1 % s + s) % s, r);
            if (this.tiles[a]) return ie(this.tiles[a], i);
            n > 1 && console.log("drilling down to z%d-%d-%d", e1, t1, r);
            for(var l, u = e1, h = t1, c = r; !l && u > 0;)u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[he(u, h, c)];
            return l && l.source ? (n > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), n > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e1, t1, r), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? ie(this.tiles[a], i) : null) : null;
        };
        class fe extends e1.VectorTileWorkerSource {
            constructor(e1, t1, r, o, i){
                super(e1, t1, r, o, ce), i && (this.loadGeoJSON = i);
            }
            loadData(t1, r) {
                const o = t1 && t1.request, i = o && o.collectResourceTiming;
                this.loadGeoJSON(t1, (n, s)=>{
                    if (n || !s) return r(n);
                    if ("object" != typeof s) return r(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    {
                        a(s, !0);
                        try {
                            if (t1.filter) {
                                const r = e1.createExpression(t1.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === r.result) throw new Error(r.value.map((e1)=>`${e1.key}: ${e1.message}`).join(", "));
                                const o = s.features.filter((e1)=>r.value.evaluate({
                                        zoom: 0
                                    }, e1));
                                s = {
                                    type: "FeatureCollection",
                                    features: o
                                };
                            }
                            this._geoJSONIndex = t1.cluster ? new E(function({ superclusterOptions: t1, clusterProperties: r }) {
                                if (!r || !t1) return t1;
                                const o = {}, i = {}, n = {
                                    accumulated: null,
                                    zoom: 0
                                }, s = {
                                    properties: null
                                }, a = Object.keys(r);
                                for (const t1 of a){
                                    const [n, s] = r[t1], a = e1.createExpression(s), l = e1.createExpression("string" == typeof n ? [
                                        n,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : n);
                                    o[t1] = a.value, i[t1] = l.value;
                                }
                                return t1.map = (e1)=>{
                                    s.properties = e1;
                                    const t1 = {};
                                    for (const e1 of a)t1[e1] = o[e1].evaluate(n, s);
                                    return t1;
                                }, t1.reduce = (e1, t1)=>{
                                    s.properties = t1;
                                    for (const t1 of a)n.accumulated = e1[t1], e1[t1] = i[t1].evaluate(n, s);
                                }, t1;
                            }(t1)).load(s.features) : function(e1, t1) {
                                return new ue(e1, t1);
                            }(s, t1.geojsonVtOptions);
                        } catch (n) {
                            return r(n);
                        }
                        this.loaded = {};
                        const l = {};
                        if (i) {
                            const r = e1.getPerformanceMeasurement(o);
                            r && (l.resourceTiming = {}, l.resourceTiming[t1.source] = JSON.parse(JSON.stringify(r)));
                        }
                        r(null, l);
                    }
                });
            }
            reloadTile(e1, t1) {
                const r = this.loaded;
                return r && r[e1.uid] ? super.reloadTile(e1, t1) : this.loadTile(e1, t1);
            }
            loadGeoJSON(t1, r) {
                if (t1.request) e1.getJSON(t1.request, r);
                else {
                    if ("string" != typeof t1.data) return r(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    try {
                        return r(null, JSON.parse(t1.data));
                    } catch (e1) {
                        return r(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    }
                }
            }
            getClusterExpansionZoom(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e1.clusterId));
                } catch (e1) {
                    t1(e1);
                }
            }
            getClusterChildren(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e1.clusterId));
                } catch (e1) {
                    t1(e1);
                }
            }
            getClusterLeaves(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e1.clusterId, e1.limit, e1.offset));
                } catch (e1) {
                    t1(e1);
                }
            }
        }
        class pe {
            constructor(t1){
                this.self = t1, this.actor = new e1.Actor(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e1.getProjection({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: e1.VectorTileWorkerSource,
                    geojson: fe
                }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e1, t1)=>{
                    if (this.workerSourceTypes[e1]) throw new Error(`Worker source with name "${e1}" already registered.`);
                    this.workerSourceTypes[e1] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e1.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
                    e1.plugin.applyArabicShaping = t1.applyArabicShaping, e1.plugin.processBidirectionalText = t1.processBidirectionalText, e1.plugin.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                };
            }
            clearCaches(e1, t1, r) {
                delete this.layerIndexes[e1], delete this.availableImages[e1], delete this.workerSources[e1], delete this.demWorkerSources[e1], r();
            }
            checkIfReady(e1, t1, r) {
                r();
            }
            setReferrer(e1, t1) {
                this.referrer = t1;
            }
            spriteLoaded(t1, r) {
                this.isSpriteLoaded[t1] = r;
                for(const o in this.workerSources[t1]){
                    const i = this.workerSources[t1][o];
                    for(const t1 in i)i[t1] instanceof e1.VectorTileWorkerSource && (i[t1].isSpriteLoaded = r, i[t1].fire(new e1.Event("isSpriteLoaded")));
                }
            }
            setImages(e1, t1, r) {
                this.availableImages[e1] = t1;
                for(const r in this.workerSources[e1]){
                    const o = this.workerSources[e1][r];
                    for(const e1 in o)o[e1].availableImages = t1;
                }
                r();
            }
            enableTerrain(e1, t1, r) {
                this.terrain = t1, r();
            }
            setProjection(t1, r) {
                this.projections[t1] = e1.getProjection(r);
            }
            setLayers(e1, t1, r) {
                this.getLayerIndex(e1).replace(t1), r();
            }
            updateLayers(e1, t1, r) {
                this.getLayerIndex(e1).update(t1.layers, t1.removedIds), r();
            }
            loadTile(t1, r, o) {
                const i = this.enableTerrain ? e1.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                i.projection = this.projections[t1] || this.defaultProjection, this.getWorkerSource(t1, r.type, r.source).loadTile(i, o);
            }
            loadDEMTile(t1, r, o) {
                const i = this.enableTerrain ? e1.extend({
                    buildQuadTree: this.terrain
                }, r) : r;
                this.getDEMWorkerSource(t1, r.source).loadTile(i, o);
            }
            reloadTile(t1, r, o) {
                const i = this.enableTerrain ? e1.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                i.projection = this.projections[t1] || this.defaultProjection, this.getWorkerSource(t1, r.type, r.source).reloadTile(i, o);
            }
            abortTile(e1, t1, r) {
                this.getWorkerSource(e1, t1.type, t1.source).abortTile(t1, r);
            }
            removeTile(e1, t1, r) {
                this.getWorkerSource(e1, t1.type, t1.source).removeTile(t1, r);
            }
            removeSource(e1, t1, r) {
                if (!this.workerSources[e1] || !this.workerSources[e1][t1.type] || !this.workerSources[e1][t1.type][t1.source]) return;
                const o = this.workerSources[e1][t1.type][t1.source];
                delete this.workerSources[e1][t1.type][t1.source], void 0 !== o.removeSource ? o.removeSource(t1, r) : r();
            }
            loadWorkerSource(e1, t1, r) {
                try {
                    this.self.importScripts(t1.url), r();
                } catch (e1) {
                    r(e1.toString());
                }
            }
            syncRTLPluginState(t1, r, o) {
                try {
                    e1.plugin.setState(r);
                    const t1 = e1.plugin.getPluginURL();
                    if (e1.plugin.isLoaded() && !e1.plugin.isParsed() && null != t1) {
                        this.self.importScripts(t1);
                        const r = e1.plugin.isParsed();
                        o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t1}`), r);
                    }
                } catch (e1) {
                    o(e1.toString());
                }
            }
            getAvailableImages(e1) {
                let t1 = this.availableImages[e1];
                return t1 || (t1 = []), t1;
            }
            getLayerIndex(e1) {
                let t1 = this.layerIndexes[e1];
                return t1 || (t1 = this.layerIndexes[e1] = new o), t1;
            }
            getWorkerSource(e1, t1, r) {
                if (this.workerSources[e1] || (this.workerSources[e1] = {}), this.workerSources[e1][t1] || (this.workerSources[e1][t1] = {}), !this.workerSources[e1][t1][r]) {
                    const o = {
                        send: (t1, r, o, i, n, s)=>{
                            this.actor.send(t1, r, o, e1, n, s);
                        },
                        scheduler: this.actor.scheduler
                    };
                    this.workerSources[e1][t1][r] = new this.workerSourceTypes[t1](o, this.getLayerIndex(e1), this.getAvailableImages(e1), this.isSpriteLoaded[e1]);
                }
                return this.workerSources[e1][t1][r];
            }
            getDEMWorkerSource(e1, t1) {
                return this.demWorkerSources[e1] || (this.demWorkerSources[e1] = {}), this.demWorkerSources[e1][t1] || (this.demWorkerSources[e1][t1] = new i), this.demWorkerSources[e1][t1];
            }
            enforceCacheSizeLimit(t1, r) {
                e1.enforceCacheSizeLimit(r);
            }
            getWorkerPerformanceMetrics(e1, t1, r) {
                r(void 0, void 0);
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new pe(self)), pe;
    });
    define([
        "./shared"
    ], function(e1) {
        "use strict";
        function t1(e1, i) {
            if (Array.isArray(e1)) {
                if (!Array.isArray(i) || e1.length !== i.length) return !1;
                for(let o = 0; o < e1.length; o++)if (!t1(e1[o], i[o])) return !1;
                return !0;
            }
            if ("object" == typeof e1 && null !== e1 && null !== i) {
                if ("object" != typeof i) return !1;
                if (Object.keys(e1).length !== Object.keys(i).length) return !1;
                for(const o in e1)if (!t1(e1[o], i[o])) return !1;
                return !0;
            }
            return e1 === i;
        }
        var i = o;
        function o(e1) {
            return !function(e1) {
                var t1;
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                    var e1, t1, i = new Blob([
                        ""
                    ], {
                        type: "text/javascript"
                    }), o = URL.createObjectURL(i);
                    try {
                        t1 = new Worker(o), e1 = !0;
                    } catch (t1) {
                        e1 = !1;
                    }
                    return t1 && t1.terminate(), URL.revokeObjectURL(o), e1;
                }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                    var e1 = document.createElement("canvas");
                    e1.width = e1.height = 1;
                    var t1 = e1.getContext("2d");
                    if (!t1) return !1;
                    var i = t1.getImageData(0, 0, 1, 1);
                    return i && i.width === e1.width;
                }() ? (void 0 === r[t1 = e1 && e1.failIfMajorPerformanceCaveat] && (r[t1] = function(e1) {
                    var t1, i = function(e1) {
                        var t1 = document.createElement("canvas"), i = Object.create(o.webGLContextAttributes);
                        return i.failIfMajorPerformanceCaveat = e1, t1.getContext("webgl", i) || t1.getContext("experimental-webgl", i);
                    }(e1);
                    if (!i) return !1;
                    try {
                        t1 = i.createShader(i.VERTEX_SHADER);
                    } catch (e1) {
                        return !1;
                    }
                    return !(!t1 || i.isContextLost()) && (i.shaderSource(t1, "void main() {}"), i.compileShader(t1), !0 === i.getShaderParameter(t1, i.COMPILE_STATUS));
                }(t1)), r[t1] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            }(e1);
        }
        var r = {};
        function n(t1, i, o) {
            const r = e1.window.document.createElement(t1);
            return void 0 !== i && (r.className = i), o && o.appendChild(r), r;
        }
        function s(t1, i, o) {
            const r = e1.window.document.createElementNS("http://www.w3.org/2000/svg", t1);
            for (const e1 of Object.keys(i))r.setAttributeNS(null, e1, i[e1]);
            return o && o.appendChild(r), r;
        }
        o.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        const a = e1.window.document && e1.window.document.documentElement.style, l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
        let c;
        function h() {
            a && l && (c = a[l], a[l] = "none");
        }
        function u() {
            a && l && (a[l] = c);
        }
        function _(t1) {
            t1.preventDefault(), t1.stopPropagation(), e1.window.removeEventListener("click", _, !0);
        }
        function d() {
            e1.window.addEventListener("click", _, !0), e1.window.setTimeout(()=>{
                e1.window.removeEventListener("click", _, !0);
            }, 0);
        }
        function p(e1, t1) {
            const i = e1.getBoundingClientRect();
            return g(e1, i, t1);
        }
        function m(e1, t1) {
            const i = e1.getBoundingClientRect(), o = [];
            for(let r = 0; r < t1.length; r++)o.push(g(e1, i, t1[r]));
            return o;
        }
        function f(t1) {
            return void 0 !== e1.window.InstallTrigger && 2 === t1.button && t1.ctrlKey && e1.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t1.button;
        }
        function g(t1, i, o) {
            const r = t1.offsetWidth === i.width ? 1 : t1.offsetWidth / i.width;
            return new e1.Point((o.clientX - i.left) * r, (o.clientY - i.top) * r);
        }
        function v(e1, t1) {
            var i = t1[0], o = t1[1], r = t1[2], n = t1[3], s = i * n - r * o;
            return s ? (e1[0] = n * (s = 1 / s), e1[1] = -o * s, e1[2] = -r * s, e1[3] = i * s, e1) : null;
        }
        function x(e1) {
            const { userImage: t1 } = e1;
            return !!(t1 && t1.render && t1.render()) && (e1.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class y extends e1.Evented {
            constructor(){
                super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e1.RGBAImage({
                    width: 1,
                    height: 1
                }), this.dirty = !0;
            }
            isLoaded() {
                return this.loaded;
            }
            setLoaded(e1) {
                if (this.loaded !== e1 && (this.loaded = e1, e1)) {
                    for (const { ids: e1, callback: t1 } of this.requestors)this._notify(e1, t1);
                    this.requestors = [];
                }
            }
            hasImage(e1) {
                return !!this.getImage(e1);
            }
            getImage(e1) {
                return this.images[e1];
            }
            addImage(e1, t1) {
                this._validate(e1, t1) && (this.images[e1] = t1);
            }
            _validate(t1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t1}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t1}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t1}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(e1, t1) {
                if (!e1) return !0;
                let i = 0;
                for (const o of e1){
                    if (o[0] < i || o[1] < o[0] || t1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(e1, t1) {
                return !(e1 && (4 !== e1.length || e1[0] < 0 || t1.data.width < e1[0] || e1[1] < 0 || t1.data.height < e1[1] || e1[2] < 0 || t1.data.width < e1[2] || e1[3] < 0 || t1.data.height < e1[3] || e1[2] < e1[0] || e1[3] < e1[1]));
            }
            updateImage(e1, t1) {
                t1.version = this.images[e1].version + 1, this.images[e1] = t1, this.updatedImages[e1] = !0;
            }
            removeImage(e1) {
                const t1 = this.images[e1];
                delete this.images[e1], delete this.patterns[e1], t1.userImage && t1.userImage.onRemove && t1.userImage.onRemove();
            }
            listImages() {
                return Object.keys(this.images);
            }
            getImages(e1, t1) {
                let i = !0;
                if (!this.isLoaded()) for (const t1 of e1)this.images[t1] || (i = !1);
                this.isLoaded() || i ? this._notify(e1, t1) : this.requestors.push({
                    ids: e1,
                    callback: t1
                });
            }
            _notify(t1, i) {
                const o = {};
                for (const i of t1){
                    this.images[i] || this.fire(new e1.Event("styleimagemissing", {
                        id: i
                    }));
                    const t1 = this.images[i];
                    t1 ? o[i] = {
                        data: t1.data.clone(),
                        pixelRatio: t1.pixelRatio,
                        sdf: t1.sdf,
                        version: t1.version,
                        stretchX: t1.stretchX,
                        stretchY: t1.stretchY,
                        content: t1.content,
                        hasRenderCallback: Boolean(t1.userImage && t1.userImage.render)
                    } : e1.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                i(null, o);
            }
            getPixelSize() {
                const { width: e1, height: t1 } = this.atlasImage;
                return {
                    width: e1,
                    height: t1
                };
            }
            getPattern(t1) {
                const i = this.patterns[t1], o = this.getImage(t1);
                if (!o) return null;
                if (i && i.position.version === o.version) return i.position;
                if (i) i.position.version = o.version;
                else {
                    const i = {
                        w: o.data.width + 2,
                        h: o.data.height + 2,
                        x: 0,
                        y: 0
                    }, r = new e1.ImagePosition(i, o);
                    this.patterns[t1] = {
                        bin: i,
                        position: r
                    };
                }
                return this._updatePatternAtlas(), this.patterns[t1].position;
            }
            bind(t1) {
                const i = t1.gl;
                this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e1.Texture(t1, this.atlasImage, i.RGBA), this.atlasTexture && this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
                const t1 = [];
                for(const e1 in this.patterns)t1.push(this.patterns[e1].bin);
                const { w: i, h: o } = e1.potpack(t1), r = this.atlasImage;
                r.resize({
                    width: i || 1,
                    height: o || 1
                });
                for(const t1 in this.patterns){
                    const { bin: i } = this.patterns[t1], o = i.x + 1, n = i.y + 1, s = this.images[t1].data, a = s.width, l = s.height;
                    e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: n
                    }, {
                        width: a,
                        height: l
                    }), e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: l - 1
                    }, {
                        x: o,
                        y: n - 1
                    }, {
                        width: a,
                        height: 1
                    }), e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: n + l
                    }, {
                        width: a,
                        height: 1
                    }), e1.RGBAImage.copy(s, r, {
                        x: a - 1,
                        y: 0
                    }, {
                        x: o - 1,
                        y: n
                    }, {
                        width: 1,
                        height: l
                    }), e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + a,
                        y: n
                    }, {
                        width: 1,
                        height: l
                    });
                }
                this.dirty = !0;
            }
            beginFrame() {
                this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e1) {
                for (const t1 of e1){
                    if (this.callbackDispatchedThisFrame[t1]) continue;
                    this.callbackDispatchedThisFrame[t1] = !0;
                    const e1 = this.images[t1];
                    x(e1) && this.updateImage(t1, e1);
                }
            }
        }
        const b = new e1.Properties({
            anchor: new e1.DataConstantProperty(e1.spec.light.anchor),
            position: new class {
                constructor(){
                    this.specification = e1.spec.light.position;
                }
                possiblyEvaluate(t1, i) {
                    return function([t1, i, o]) {
                        const r = e1.degToRad(i + 90), n = e1.degToRad(o);
                        return {
                            x: t1 * Math.cos(r) * Math.sin(n),
                            y: t1 * Math.sin(r) * Math.sin(n),
                            z: t1 * Math.cos(n),
                            azimuthal: i,
                            polar: o
                        };
                    }(t1.expression.evaluate(i));
                }
                interpolate(t1, i, o) {
                    return {
                        x: e1.number(t1.x, i.x, o),
                        y: e1.number(t1.y, i.y, o),
                        z: e1.number(t1.z, i.z, o),
                        azimuthal: e1.number(t1.azimuthal, i.azimuthal, o),
                        polar: e1.number(t1.polar, i.polar, o)
                    };
                }
            },
            color: new e1.DataConstantProperty(e1.spec.light.color),
            intensity: new e1.DataConstantProperty(e1.spec.light.intensity)
        });
        class w extends e1.Evented {
            constructor(t1){
                super(), this._transitionable = new e1.Transitionable(b), this.setLight(t1), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(t1, i = {}) {
                if (!this._validate(e1.validateLight, t1, i)) for(const i in t1){
                    const o = t1[i];
                    e1.endsWith(i, "-transition") ? this._transitionable.setTransition(i.slice(0, -11), o) : this._transitionable.setValue(i, o);
                }
            }
            updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(e1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && e1.emitValidationErrors(this, t1.call(e1.validateStyle, e1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e1.spec
                })));
            }
        }
        const T = new e1.Properties({
            source: new e1.DataConstantProperty(e1.spec.terrain.source),
            exaggeration: new e1.DataConstantProperty(e1.spec.terrain.exaggeration)
        });
        let E = class extends e1.Evented {
            constructor(t1, i){
                super(), this._transitionable = new e1.Transitionable(T), this.set(t1), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1) {
                for(const i in t1){
                    const o = t1[i];
                    e1.endsWith(i, "-transition") ? this._transitionable.setTransition(i.slice(0, -11), o) : this._transitionable.setValue(i, o);
                }
            }
            updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(e1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
            }
        };
        function C(t1, i, o, r) {
            const n = e1.smoothstep(45, 65, o), [s, a] = M(t1, r), l = e1.length(i);
            let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));
            return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t1.alpha;
        }
        function M(e1, t1) {
            const i = .5 / Math.tan(.5 * t1);
            return [
                e1.range[0] + i,
                e1.range[1] + i
            ];
        }
        const I = new e1.Properties({
            range: new e1.DataConstantProperty(e1.spec.fog.range),
            color: new e1.DataConstantProperty(e1.spec.fog.color),
            "high-color": new e1.DataConstantProperty(e1.spec.fog["high-color"]),
            "space-color": new e1.DataConstantProperty(e1.spec.fog["space-color"]),
            "horizon-blend": new e1.DataConstantProperty(e1.spec.fog["horizon-blend"]),
            "star-intensity": new e1.DataConstantProperty(e1.spec.fog["star-intensity"])
        });
        class P extends e1.Evented {
            constructor(t1, i){
                super(), this._transitionable = new e1.Transitionable(I), this.set(t1), this._transitioning = this._transitionable.untransitioned(), this._transform = i;
            }
            get state() {
                const t1 = this._transform, i = "globe" === t1.projection.name, o = e1.globeToMercatorTransition(t1.zoom), r = this.properties.get("range"), n = [
                    .5,
                    3
                ];
                return {
                    range: i ? [
                        e1.number(n[0], r[0], o),
                        e1.number(n[1], r[1], o)
                    ] : r,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i = {}) {
                if (!this._validate(e1.validateFog, t1, i)) {
                    for (const i of Object.keys(e1.spec.fog))t1 && void 0 === t1[i] && (t1[i] = e1.spec.fog[i].default);
                    for(const i in t1){
                        const o = t1[i];
                        e1.endsWith(i, "-transition") ? this._transitionable.setTransition(i.slice(0, -11), o) : this._transitionable.setValue(i, o);
                    }
                }
            }
            getOpacity(t1) {
                if (!this._transform.projection.supportsFog) return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e1.smoothstep(45, 65, t1)) * i.a;
            }
            getOpacityAtLatLng(t1, i) {
                return this._transform.projection.supportsFog ? function(t1, i, o) {
                    const r = e1.MercatorCoordinate.fromLngLat(i), n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0, s = [
                        r.x,
                        r.y,
                        n
                    ];
                    return e1.transformMat4(s, s, o.mercatorFogMatrix), C(t1, s, o.pitch, o._fov);
                }(this.state, t1, i) : 0;
            }
            getFovAdjustedRange(e1) {
                return this._transform.projection.supportsFog ? M(this.state, e1) : [
                    0,
                    1
                ];
            }
            updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(e1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && e1.emitValidationErrors(this, t1.call(e1.validateStyle, e1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e1.spec
                })));
            }
        }
        class S {
            constructor(t1, i){
                this.workerPool = t1, this.actors = [], this.currentActor = 0, this.id = e1.uniqueId();
                const o = this.workerPool.acquire(this.id);
                for(let e1 = 0; e1 < o.length; e1++){
                    const t1 = new S.Actor(o[e1], i, this.id);
                    t1.name = `Worker ${e1}`, this.actors.push(t1);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t1, i, o) {
                e1.asyncAll(this.actors, (e1, o)=>{
                    e1.send(t1, i, o);
                }, o = o || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((e1)=>{
                    e1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        function D(t1, i, o) {
            return i * (e1.EXTENT / (t1.tileSize * Math.pow(2, o - t1.tileID.overscaledZ)));
        }
        S.Actor = e1.Actor;
        class L {
            constructor(e1, t1, i, o){
                this.screenBounds = e1, this.cameraPoint = t1, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);
            }
            static createFromScreenPoints(t1, i) {
                let o, r;
                if (t1 instanceof e1.Point || "number" == typeof t1[0]) {
                    const n = e1.Point.convert(t1);
                    o = [
                        n
                    ], r = i.isPointAboveHorizon(n);
                } else {
                    const n = e1.Point.convert(t1[0]), s = e1.Point.convert(t1[1]);
                    o = [
                        n,
                        s
                    ], r = e1.polygonizeBounds(n, s).every((e1)=>i.isPointAboveHorizon(e1));
                }
                return new L(o, i.getCameraPoint(), r, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t1) {
                return e1.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t1);
            }
            bufferedCameraGeometry(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e1.Point(1, 1)) : this.screenBounds[1], r = e1.polygonizeBounds(i, o, 0, !1);
                return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e1.bufferConvexPolygon(r, t1);
            }
            bufferedCameraGeometryGlobe(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e1.Point(1, 1)) : this.screenBounds[1], r = e1.polygonizeBounds(i, o, t1), n = this.cameraPoint.clone();
                switch(3 * ((n.y > i.y) + (n.y > o.y)) + ((n.x > i.x) + (n.x > o.x))){
                    case 0:
                        r[0] = n, r[4] = n.clone();
                        break;
                    case 1:
                        r.splice(1, 0, n);
                        break;
                    case 2:
                        r[1] = n;
                        break;
                    case 3:
                        r.splice(4, 0, n);
                        break;
                    case 5:
                        r.splice(2, 0, n);
                        break;
                    case 6:
                        r[3] = n;
                        break;
                    case 7:
                        r.splice(3, 0, n);
                        break;
                    case 8:
                        r[2] = n;
                }
                return r;
            }
            containsTile(t1, i, o, r = 0) {
                const n = t1.queryPadding / i._pixelsPerMercatorPixel + 1, s = o ? this._bufferedCameraMercator(n, i) : this._bufferedScreenMercator(n, i);
                let a = t1.tileID.wrap + (s.unwrapped ? r : 0);
                const l = s.polygon.map((i)=>e1.getTilePoint(t1.tileTransform, i, a));
                if (!e1.polygonIntersectsBox(l, 0, 0, e1.EXTENT, e1.EXTENT)) return;
                a = t1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
                const c = this.screenGeometryMercator.polygon.map((i)=>e1.getTileVec3(t1.tileTransform, i, a)), h = c.map((t1)=>new e1.Point(t1[0], t1[1])), u = i.getFreeCameraOptions().position || new e1.MercatorCoordinate(0, 0, 0), _ = e1.getTileVec3(t1.tileTransform, u, a), d = c.map((t1)=>{
                    const i = e1.sub(t1, t1, _);
                    return e1.normalize(i, i), new e1.Ray(_, i);
                }), p = D(t1, 1, i.zoom) * i._pixelsPerMercatorPixel;
                var m;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: d,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (m = e1.getBounds(l), m.min.x = e1.clamp(m.min.x, 0, e1.EXTENT), m.min.y = e1.clamp(m.min.y, 0, e1.EXTENT), m.max.x = e1.clamp(m.max.x, 0, e1.EXTENT), m.max.y = e1.clamp(m.max.y, 0, e1.EXTENT), m),
                    tile: t1,
                    tileID: t1.tileID,
                    pixelToTileUnitsFactor: p
                };
            }
            _bufferedScreenMercator(e1, t1) {
                const i = R(e1);
                if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e1), t1) : {
                        polygon: this.bufferedScreenGeometry(e1).map((e1)=>t1.pointCoordinate3D(e1)),
                        unwrapped: !0
                    }, this._screenRaycastCache[i] = o, o;
                }
            }
            _bufferedCameraMercator(e1, t1) {
                const i = R(e1);
                if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e1), t1) : {
                        polygon: this.bufferedCameraGeometry(e1).map((e1)=>t1.pointCoordinate3D(e1)),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i] = o, o;
                }
            }
            _projectAndResample(t1, i) {
                const o = function(t1, i) {
                    const o = e1.multiply([], i.pixelMatrix, i.globeMatrix), r = [
                        0,
                        -e1.GLOBE_RADIUS,
                        0,
                        1
                    ], n = [
                        0,
                        e1.GLOBE_RADIUS,
                        0,
                        1
                    ], s = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e1.transformMat4$1(r, r, o), e1.transformMat4$1(n, n, o), e1.transformMat4$1(s, s, o);
                    const a = new e1.Point(r[0] / r[3], r[1] / r[3]), l = new e1.Point(n[0] / n[3], n[1] / n[3]), c = e1.polygonContainsPoint(t1, a) && r[3] < s[3], h = e1.polygonContainsPoint(t1, l) && n[3] < s[3];
                    if (!c && !h) return null;
                    const u = function(e1, t1, i) {
                        for(let o = 1; o < e1.length; o++){
                            const r = z(t1.pointCoordinate3D(e1[o - 1]).x), n = z(t1.pointCoordinate3D(e1[o]).x);
                            if (i < 0) {
                                if (r < n) return {
                                    idx: o,
                                    t: -r / (n - 1 - r)
                                };
                            } else if (n < r) return {
                                idx: o,
                                t: (1 - r) / (n + 1 - r)
                            };
                        }
                        return null;
                    }(t1, i, c ? -1 : 1);
                    if (!u) return null;
                    const { idx: _, t: d } = u;
                    let p = _ > 1 ? A(t1.slice(0, _), i) : [], m = _ < t1.length ? A(t1.slice(_), i) : [];
                    p = p.map((t1)=>new e1.Point(z(t1.x), t1.y)), m = m.map((t1)=>new e1.Point(z(t1.x), t1.y));
                    const f = [
                        ...p
                    ];
                    0 === f.length && f.push(m[m.length - 1]);
                    const g = e1.number(f[f.length - 1].y, (0 === m.length ? p[0] : m[0]).y, d);
                    let v;
                    return v = c ? [
                        new e1.Point(0, g),
                        new e1.Point(0, 0),
                        new e1.Point(1, 0),
                        new e1.Point(1, g)
                    ] : [
                        new e1.Point(1, g),
                        new e1.Point(1, 1),
                        new e1.Point(0, 1),
                        new e1.Point(0, g)
                    ], f.push(...v), 0 === m.length ? f.push(p[0]) : f.push(...m), {
                        polygon: f.map((t1)=>new e1.MercatorCoordinate(t1.x, t1.y)),
                        unwrapped: !1
                    };
                }(t1, i);
                if (o) return o;
                const r = function(t1, i) {
                    let o = !1, r = -1 / 0, n = 0;
                    for(let e1 = 0; e1 < t1.length - 1; e1++)t1[e1].x > r && (r = t1[e1].x, n = e1);
                    for(let e1 = 0; e1 < t1.length - 1; e1++){
                        const i = (n + e1) % (t1.length - 1), r = t1[i], s = t1[i + 1];
                        Math.abs(r.x - s.x) > .5 && (r.x < s.x ? (r.x += 1, 0 === i && (t1[t1.length - 1].x += 1)) : (s.x += 1, i + 1 === t1.length - 1 && (t1[0].x += 1)), o = !0);
                    }
                    const s = e1.mercatorXfromLng(i.center.lng);
                    return o && s < Math.abs(s - 1) && t1.forEach((e1)=>{
                        e1.x -= 1;
                    }), {
                        polygon: t1,
                        unwrapped: o
                    };
                }(A(t1, i).map((t1)=>new e1.Point(z(t1.x), t1.y)), i);
                return {
                    polygon: r.polygon.map((t1)=>new e1.MercatorCoordinate(t1.x, t1.y)),
                    unwrapped: r.unwrapped
                };
            }
        }
        function A(t1, i) {
            return e1.resample(t1, (e1)=>{
                const t1 = i.pointCoordinate3D(e1);
                e1.x = t1.x, e1.y = t1.y;
            }, 1 / 256);
        }
        function z(e1) {
            return e1 < 0 ? 1 + e1 % 1 : e1 % 1;
        }
        function R(e1) {
            return 100 * e1 | 0;
        }
        function O(t1, i, o, r, n) {
            const s = function(o, r) {
                if (o) return n(o);
                if (r) {
                    t1.url && r.tiles && t1.tiles && delete t1.tiles;
                    const o = e1.pick(e1.extend(r, t1), [
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "scheme",
                        "tileSize",
                        "encoding"
                    ]);
                    r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map((e1)=>e1.id)), o.tiles = i.canonicalizeTileset(o, t1.url), n(null, o);
                }
            };
            return t1.url ? e1.getJSON(i.transformRequest(i.normalizeSourceURL(t1.url, null, o, r), e1.ResourceType.Source), s) : e1.exported.frame(()=>s(null, t1));
        }
        class B {
            constructor(t1, i, o){
                this.bounds = e1.LngLatBounds.convert(this.validateBounds(t1)), this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(e1) {
                return Array.isArray(e1) && 4 === e1.length ? [
                    Math.max(-180, e1[0]),
                    Math.max(-90, e1[1]),
                    Math.min(180, e1[2]),
                    Math.min(90, e1[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            contains(t1) {
                const i = Math.pow(2, t1.z), o = Math.floor(e1.mercatorXfromLng(this.bounds.getWest()) * i), r = Math.floor(e1.mercatorYfromLat(this.bounds.getNorth()) * i), n = Math.ceil(e1.mercatorXfromLng(this.bounds.getEast()) * i), s = Math.ceil(e1.mercatorYfromLat(this.bounds.getSouth()) * i);
                return t1.x >= o && t1.x < n && t1.y >= r && t1.y < s;
            }
        }
        class k {
            constructor(e1, t1, i){
                this.context = e1;
                const o = e1.gl;
                this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e1.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t1.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e1) {
                const t1 = this.context.gl;
                this.context.unbindVAO(), this.bind(), t1.bufferSubData(t1.ELEMENT_ARRAY_BUFFER, 0, e1.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        const F = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class U {
            constructor(e1, t1, i, o){
                this.length = t1.length, this.attributes = i, this.itemSize = t1.bytesPerElement, this.dynamicDraw = o, this.context = e1;
                const r = e1.gl;
                this.buffer = r.createBuffer(), e1.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t1.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e1) {
                const t1 = this.context.gl;
                this.bind(), t1.bufferSubData(t1.ARRAY_BUFFER, 0, e1.arrayBuffer);
            }
            enableAttributes(e1, t1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = t1.attributes[this.attributes[i].name];
                    void 0 !== o && e1.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(e1, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const r = this.attributes[o], n = t1.attributes[r.name];
                    void 0 !== n && e1.vertexAttribPointer(n, r.components, e1[F[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class N {
            constructor(e1){
                this.gl = e1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e1) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class j extends N {
            getDefault() {
                return e1.Color.transparent;
            }
            set(e1) {
                const t1 = this.current;
                (e1.r !== t1.r || e1.g !== t1.g || e1.b !== t1.b || e1.a !== t1.a || this.dirty) && (this.gl.clearColor(e1.r, e1.g, e1.b, e1.a), this.current = e1, this.dirty = !1);
            }
        }
        class G extends N {
            getDefault() {
                return 1;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.clearDepth(e1), this.current = e1, this.dirty = !1);
            }
        }
        class Z extends N {
            getDefault() {
                return 0;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.clearStencil(e1), this.current = e1, this.dirty = !1);
            }
        }
        class V extends N {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || e1[2] !== t1[2] || e1[3] !== t1[3] || this.dirty) && (this.gl.colorMask(e1[0], e1[1], e1[2], e1[3]), this.current = e1, this.dirty = !1);
            }
        }
        class W extends N {
            getDefault() {
                return !0;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.depthMask(e1), this.current = e1, this.dirty = !1);
            }
        }
        class X extends N {
            getDefault() {
                return 255;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.stencilMask(e1), this.current = e1, this.dirty = !1);
            }
        }
        class q extends N {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e1) {
                const t1 = this.current;
                (e1.func !== t1.func || e1.ref !== t1.ref || e1.mask !== t1.mask || this.dirty) && (this.gl.stencilFunc(e1.func, e1.ref, e1.mask), this.current = e1, this.dirty = !1);
            }
        }
        class $ extends N {
            getDefault() {
                const e1 = this.gl;
                return [
                    e1.KEEP,
                    e1.KEEP,
                    e1.KEEP
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || e1[2] !== t1[2] || this.dirty) && (this.gl.stencilOp(e1[0], e1[1], e1[2]), this.current = e1, this.dirty = !1);
            }
        }
        class H extends N {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.STENCIL_TEST) : t1.disable(t1.STENCIL_TEST), this.current = e1, this.dirty = !1;
            }
        }
        class Y extends N {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || this.dirty) && (this.gl.depthRange(e1[0], e1[1]), this.current = e1, this.dirty = !1);
            }
        }
        class K extends N {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.DEPTH_TEST) : t1.disable(t1.DEPTH_TEST), this.current = e1, this.dirty = !1;
            }
        }
        class J extends N {
            getDefault() {
                return this.gl.LESS;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.depthFunc(e1), this.current = e1, this.dirty = !1);
            }
        }
        class Q extends N {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.BLEND) : t1.disable(t1.BLEND), this.current = e1, this.dirty = !1;
            }
        }
        class ee extends N {
            getDefault() {
                const e1 = this.gl;
                return [
                    e1.ONE,
                    e1.ZERO
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || this.dirty) && (this.gl.blendFunc(e1[0], e1[1]), this.current = e1, this.dirty = !1);
            }
        }
        class te extends N {
            getDefault() {
                return e1.Color.transparent;
            }
            set(e1) {
                const t1 = this.current;
                (e1.r !== t1.r || e1.g !== t1.g || e1.b !== t1.b || e1.a !== t1.a || this.dirty) && (this.gl.blendColor(e1.r, e1.g, e1.b, e1.a), this.current = e1, this.dirty = !1);
            }
        }
        class ie extends N {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.blendEquation(e1), this.current = e1, this.dirty = !1);
            }
        }
        class oe extends N {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.CULL_FACE) : t1.disable(t1.CULL_FACE), this.current = e1, this.dirty = !1;
            }
        }
        class re extends N {
            getDefault() {
                return this.gl.BACK;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.cullFace(e1), this.current = e1, this.dirty = !1);
            }
        }
        class ne extends N {
            getDefault() {
                return this.gl.CCW;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.frontFace(e1), this.current = e1, this.dirty = !1);
            }
        }
        let se, ae = class extends N {
            getDefault() {
                return null;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.useProgram(e1), this.current = e1, this.dirty = !1);
            }
        };
        class le extends N {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.activeTexture(e1), this.current = e1, this.dirty = !1);
            }
        }
        class ce extends N {
            getDefault() {
                const e1 = this.gl;
                return [
                    0,
                    0,
                    e1.drawingBufferWidth,
                    e1.drawingBufferHeight
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || e1[2] !== t1[2] || e1[3] !== t1[3] || this.dirty) && (this.gl.viewport(e1[0], e1[1], e1[2], e1[3]), this.current = e1, this.dirty = !1);
            }
        }
        class he extends N {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindFramebuffer(t1.FRAMEBUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class ue extends N {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindRenderbuffer(t1.RENDERBUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class _e extends N {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindTexture(t1.TEXTURE_2D, e1), this.current = e1, this.dirty = !1;
            }
        }
        class de extends N {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindBuffer(t1.ARRAY_BUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class pe extends N {
            getDefault() {
                return null;
            }
            set(e1) {
                const t1 = this.gl;
                t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class me extends N {
            constructor(e1){
                super(e1), this.vao = e1.extVertexArrayObject;
            }
            getDefault() {
                return null;
            }
            set(e1) {
                this.vao && (e1 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e1), this.current = e1, this.dirty = !1);
            }
        }
        class fe extends N {
            getDefault() {
                return 4;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_ALIGNMENT, e1), this.current = e1, this.dirty = !1;
            }
        }
        class ge extends N {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e1), this.current = e1, this.dirty = !1;
            }
        }
        class ve extends N {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_FLIP_Y_WEBGL, e1), this.current = e1, this.dirty = !1;
            }
        }
        class xe extends N {
            constructor(e1, t1){
                super(e1), this.context = e1, this.parent = t1;
            }
            getDefault() {
                return null;
            }
        }
        class ye extends xe {
            setDirty() {
                this.dirty = !0;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, e1, 0), this.current = e1, this.dirty = !1;
            }
        }
        class be extends xe {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferRenderbuffer(t1.FRAMEBUFFER, this.attachment(), t1.RENDERBUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class we extends be {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        class Te {
            constructor(e1, t1, i, o){
                this.context = e1, this.width = t1, this.height = i;
                const r = this.framebuffer = e1.gl.createFramebuffer();
                this.colorAttachment = new ye(e1, r), o && (this.depthAttachment = new be(e1, r));
            }
            destroy() {
                const e1 = this.context.gl, t1 = this.colorAttachment.get();
                if (t1 && e1.deleteTexture(t1), this.depthAttachment) {
                    const t1 = this.depthAttachment.get();
                    t1 && e1.deleteRenderbuffer(t1);
                }
                e1.deleteFramebuffer(this.framebuffer);
            }
        }
        class Ee {
            constructor(e1, t1 = !1){
                if (this.gl = e1, this.isWebGL2 = t1, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t1) {
                    const t1 = e1;
                    this.extVertexArrayObject = {
                        createVertexArrayOES: t1.createVertexArray.bind(e1),
                        deleteVertexArrayOES: t1.deleteVertexArray.bind(e1),
                        bindVertexArrayOES: t1.bindVertexArray.bind(e1)
                    };
                }
                this.clearColor = new j(this), this.clearDepth = new G(this), this.clearStencil = new Z(this), this.colorMask = new V(this), this.depthMask = new W(this), this.stencilMask = new X(this), this.stencilFunc = new q(this), this.stencilOp = new $(this), this.stencilTest = new H(this), this.depthRange = new Y(this), this.depthTest = new K(this), this.depthFunc = new J(this), this.blend = new Q(this), this.blendFunc = new ee(this), this.blendColor = new te(this), this.blendEquation = new ie(this), this.cullFace = new oe(this), this.cullFaceSide = new re(this), this.frontFace = new ne(this), this.program = new ae(this), this.activeTexture = new le(this), this.viewport = new ce(this), this.bindFramebuffer = new he(this), this.bindRenderbuffer = new ue(this), this.bindTexture = new _e(this), this.bindVertexBuffer = new de(this), this.bindElementBuffer = new pe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new me(this), this.pixelStoreUnpack = new fe(this), this.pixelStoreUnpackPremultiplyAlpha = new ge(this), this.pixelStoreUnpackFlipY = new ve(this), this.extTextureFilterAnisotropic = e1.getExtension("EXT_texture_filter_anisotropic") || e1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e1.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e1.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e1.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t1 || (this.extTextureHalfFloat = e1.getExtension("OES_texture_half_float")), (t1 || this.extTextureHalfFloat && e1.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e1.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t1 || e1.getExtension("OES_standard_derivatives"), this.extTimerQuery = e1.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e1.getParameter(e1.MAX_TEXTURE_SIZE);
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(e1, t1) {
                return new k(this, e1, t1);
            }
            createVertexBuffer(e1, t1, i) {
                return new U(this, e1, t1, i);
            }
            createRenderbuffer(e1, t1, i) {
                const o = this.gl, r = o.createRenderbuffer();
                return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e1, t1, i), this.bindRenderbuffer.set(null), r;
            }
            createFramebuffer(e1, t1, i) {
                return new Te(this, e1, t1, i);
            }
            clear({ color: e1, depth: t1, stencil: i }) {
                const o = this.gl;
                let r = 0;
                e1 && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e1), this.colorMask.set([
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== t1 && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t1), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);
            }
            setCullFace(e1) {
                !1 === e1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e1.mode), this.frontFace.set(e1.frontFace));
            }
            setDepthMode(e1) {
                e1.func !== this.gl.ALWAYS || e1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e1.func), this.depthMask.set(e1.mask), this.depthRange.set(e1.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e1) {
                e1.test.func !== this.gl.ALWAYS || e1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e1.mask), this.stencilOp.set([
                    e1.fail,
                    e1.depthFail,
                    e1.pass
                ]), this.stencilFunc.set({
                    func: e1.test.func,
                    ref: e1.ref,
                    mask: e1.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(i) {
                t1(i.blendFunction, e1.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor)), this.colorMask.set(i.mask);
            }
            unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
        }
        class Ce extends e1.Evented {
            constructor(t1, i, o, r){
                if (super(), this.id = t1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e1.extend(this, e1.pick(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = e1.extend({
                    type: "vector"
                }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e1.DedupedRequest;
            }
            load(t1) {
                this._loaded = !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                }));
                const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map._worldview;
                this._tileJSONRequest = O(this._options, this.map._requestManager, i, o, (r, n)=>{
                    this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e1.ErrorEvent(r))) : n && (e1.extend(this, n), n.bounds && (this.tileBounds = new B(n.bounds, this.minzoom, this.maxzoom)), e1.postTurnstileEvent(n.tiles, this.map._requestManager._customAccessToken), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(r);
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(e1) {
                return !this.tileBounds || this.tileBounds.contains(e1.canonical);
            }
            onAdd(e1) {
                this.map = e1, this.load();
            }
            reload() {
                this.cancelTileJSONRequest(), this.load(()=>this.map.style._clearSource(this.id));
            }
            setTiles(e1) {
                return this._options.tiles = e1, this.reload(), this;
            }
            setUrl(e1) {
                return this.url = e1, this._options.url = e1, this.reload(), this;
            }
            onRemove() {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e1.extend({}, this._options);
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), r = {
                    request: this.map._requestManager.transformRequest(o, e1.ResourceType.Tile),
                    data: void 0,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    tileZoom: t1.tileZoom,
                    zoom: t1.tileID.overscaledZ,
                    tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    pixelRatio: e1.exported.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: t1.isSymbolTile
                };
                if (r.request.collectResourceTiming = this._collectResourceTiming, t1.actor && "expired" !== t1.state) "loading" === t1.state ? t1.reloadCallback = i : t1.request = t1.actor.send("reloadTile", r, n.bind(this));
                else if (t1.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t1.request = t1.actor.send("loadTile", r, n.bind(this), void 0, !0);
                else {
                    const i = e1.loadVectorTile.call({
                        deduped: this._deduped
                    }, r, (e1, i)=>{
                        e1 || !i ? n.call(this, e1) : (r.data = {
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                            rawData: i.rawData.slice(0)
                        }, t1.actor && t1.actor.send("loadTile", r, n.bind(this), void 0, !0));
                    }, !0);
                    t1.request = {
                        cancel: i
                    };
                }
                function n(o, r) {
                    return delete t1.request, t1.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t1.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t1.setExpiryData(r), t1.loadVectorData(r, this.map.painter), e1.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t1.reloadCallback && (this.loadTile(t1, t1.reloadCallback), t1.reloadCallback = null)));
                }
            }
            abortTile(e1) {
                e1.request && (e1.request.cancel(), delete e1.request), e1.actor && e1.actor.send("abortTile", {
                    uid: e1.uid,
                    type: this.type,
                    source: this.id
                });
            }
            unloadTile(e1) {
                e1.unloadVectorData(), e1.actor && e1.actor.send("removeTile", {
                    uid: e1.uid,
                    type: this.type,
                    source: this.id
                });
            }
            hasTransition() {
                return !1;
            }
            afterUpdate() {
                this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class Me extends e1.Evented {
            constructor(t1, i, o, r){
                super(), this.id = t1, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e1.extend({
                    type: "raster"
                }, i), e1.extend(this, e1.pick(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load(t1) {
                this._loaded = !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = O(this._options, this.map._requestManager, null, null, (i, o)=>{
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e1.ErrorEvent(i)) : o && (e1.extend(this, o), o.bounds && (this.tileBounds = new B(o.bounds, this.minzoom, this.maxzoom)), e1.postTurnstileEvent(o.tiles), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(i);
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e1) {
                this.map = e1, this.load();
            }
            reload() {
                this.cancelTileJSONRequest(), this.load(()=>this.map.style._clearSource(this.id));
            }
            setTiles(e1) {
                return this._options.tiles = e1, this.reload(), this;
            }
            setUrl(e1) {
                return this.url = e1, this._options.url = e1, this.reload(), this;
            }
            onRemove() {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e1.extend({}, this._options);
            }
            hasTile(e1) {
                return !this.tileBounds || this.tileBounds.contains(e1.canonical);
            }
            loadTile(t1, i) {
                const o = e1.exported.devicePixelRatio >= 2, r = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
                t1.request = e1.getImage(this.map._requestManager.transformRequest(r, e1.ResourceType.Tile), (o, r, n, s)=>(delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : o ? (t1.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: n,
                        expires: s
                    }), t1.setTexture(r, this.map.painter), t1.state = "loaded", e1.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));
            }
            static loadTileData(e1, t1, i) {
                e1.setTexture(t1, i);
            }
            static unloadTileData(e1, t1) {
                e1.texture && t1.saveTileTexture(e1.texture);
            }
            abortTile(e1, t1) {
                e1.request && (e1.request.cancel(), delete e1.request), t1();
            }
            unloadTile(e1, t1) {
                e1.texture && this.map.painter.saveTileTexture(e1.texture), t1();
            }
            hasTransition() {
                return !1;
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        function Ie(t1, i, o, r, n, s, a, l) {
            const c = [
                t1,
                o,
                n,
                i,
                r,
                s,
                1,
                1,
                1
            ], h = [
                a,
                l,
                1
            ], u = e1.adjoint([], c), [_, d, p] = e1.transformMat3(h, h, e1.transpose(u, u));
            return e1.multiply$1(c, [
                _,
                0,
                0,
                0,
                d,
                0,
                0,
                0,
                p
            ], c);
        }
        class Pe extends e1.Evented {
            constructor(e1, t1, i, o){
                super(), this.id = e1, this.dispatcher = i, this.coordinates = t1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t1, this._dirty = !1;
            }
            load(t1, i) {
                this._loaded = i || !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, this._imageRequest = e1.getImage(this.map._requestManager.transformRequest(this.url, e1.ResourceType.Image), (i, o)=>{
                    if (this._imageRequest = null, this._loaded = !0, i) this.fire(new e1.ErrorEvent(i));
                    else if (o) {
                        const { HTMLImageElement: i } = e1.window;
                        this.image = o instanceof i ? e1.exported.getImageData(o) : o, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t1 && (this.coordinates = t1), this._finishLoading();
                    }
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(e1) {
                return this.image && e1.url ? (this._imageRequest && e1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e1.url, this.load(e1.coordinates, this._loaded), this) : this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new e1.Event("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(e1) {
                this.map = e1, this.load();
            }
            onRemove() {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
            }
            setCoordinates(t1) {
                this.coordinates = t1, this._boundsArray = void 0;
                const i = t1.map(e1.MercatorCoordinate.fromLngLat);
                return this.tileID = function(t1) {
                    let i = 1 / 0, o = 1 / 0, r = -1 / 0, n = -1 / 0;
                    for (const e1 of t1)i = Math.min(i, e1.x), o = Math.min(o, e1.y), r = Math.max(r, e1.x), n = Math.max(n, e1.y);
                    const s = Math.max(r - i, n - o), a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)), l = Math.pow(2, a);
                    return new e1.CanonicalTileID(a, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));
                }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e1.Event("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                this._boundsArray = void 0;
            }
            _prepareData(t1) {
                for(const e1 in this.tiles){
                    const t1 = this.tiles[e1];
                    "loaded" !== t1.state && (t1.state = "loaded", t1.texture = this.texture);
                }
                if (this._boundsArray) return;
                const i = e1.tileTransform(this.tileID, this.map.transform.projection), [o, r, n, s] = this.coordinates.map((t1)=>{
                    const o = i.projection.project(t1[0], t1[1]);
                    return e1.getTilePoint(i, o)._round();
                });
                this.perspectiveTransform = function(t1, i, o, r, n, s, a, l, c, h) {
                    const u = Ie(0, 0, t1, 0, 0, i, t1, i), _ = Ie(o, r, n, s, a, l, c, h);
                    return e1.multiply$1(_, e1.adjoint(u, u), _), [
                        _[6] / _[8] * t1 / e1.EXTENT,
                        _[7] / _[8] * i / e1.EXTENT
                    ];
                }(this.width, this.height, o.x, o.y, r.x, r.y, s.x, s.y, n.x, n.y);
                const a = this._boundsArray = new e1.StructArrayLayout4i8;
                a.emplaceBack(o.x, o.y, 0, 0), a.emplaceBack(r.x, r.y, e1.EXTENT, 0), a.emplaceBack(s.x, s.y, 0, e1.EXTENT), a.emplaceBack(n.x, n.y, e1.EXTENT, e1.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t1.createVertexBuffer(a, e1.boundsAttributes.members), this.boundsSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const t1 = this.map.painter.context, i = t1.gl;
                this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e1.Texture(t1, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t1);
            }
            loadTile(e1, t1) {
                this.tileID && this.tileID.equals(e1.tileID.canonical) ? (this.tiles[String(e1.tileID.wrap)] = e1, e1.buckets = {}, t1(null)) : (e1.state = "errored", t1(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
        }
        const Se = {
            vector: Ce,
            raster: Me,
            "raster-dem": class extends Me {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e1.extend({
                        type: "raster-dem"
                    }, i), this.encoding = i.encoding || "mapbox";
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function r(e1, o) {
                        e1 && (t1.state = "errored", i(e1)), o && (t1.dem = o, t1.dem.onDeserialize(), t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0, t1.state = "loaded", i(null));
                    }
                    t1.request = e1.getImage(this.map._requestManager.transformRequest(o, e1.ResourceType.Tile), (function(o, n, s, a) {
                        if (delete t1.request, t1.aborted) t1.state = "unloaded", i(null);
                        else if (o) t1.state = "errored", i(o);
                        else if (n) {
                            this.map._refreshExpiredTiles && t1.setExpiryData({
                                cacheControl: s,
                                expires: a
                            });
                            const i = e1.window.ImageBitmap && n instanceof e1.window.ImageBitmap && (null == se && (se = e1.window.OffscreenCanvas && new e1.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e1.window.createImageBitmap), se), o = 1 - (n.width - e1.prevPowerOfTwo(n.width)) / 2;
                            o < 1 || t1.neighboringTiles || (t1.neighboringTiles = this._getNeighboringTiles(t1.tileID));
                            const l = i ? n : e1.exported.getImageData(n, o), c = {
                                uid: t1.uid,
                                coord: t1.tileID,
                                source: this.id,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: o
                            };
                            t1.actor && "expired" !== t1.state || (t1.actor = this.dispatcher.getActor(), t1.actor.send("loadDEMTile", c, r.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t1) {
                    const i = t1.canonical, o = Math.pow(2, i.z), r = (i.x - 1 + o) % o, n = 0 === i.x ? t1.wrap - 1 : t1.wrap, s = (i.x + 1 + o) % o, a = i.x + 1 === o ? t1.wrap + 1 : t1.wrap, l = {};
                    return l[new e1.OverscaledTileID(t1.overscaledZ, n, i.z, r, i.y).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, a, i.z, s, i.y).key] = {
                        backfilled: !1
                    }, i.y > 0 && (l[new e1.OverscaledTileID(t1.overscaledZ, n, i.z, r, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, i.z, i.x, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, a, i.z, s, i.y - 1).key] = {
                        backfilled: !1
                    }), i.y + 1 < o && (l[new e1.OverscaledTileID(t1.overscaledZ, n, i.z, r, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, i.z, i.x, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, a, i.z, s, i.y + 1).key] = {
                        backfilled: !1
                    }), l;
                }
                unloadTile(e1) {
                    e1.demTexture && this.map.painter.saveTileTexture(e1.demTexture), e1.fbo && (e1.fbo.destroy(), delete e1.fbo), e1.dem && delete e1.dem, delete e1.neighboringTiles, e1.state = "unloaded";
                }
            },
            geojson: class extends e1.Evented {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e1.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                    const n = e1.EXTENT / this.tileSize;
                    this.workerOptions = e1.extend({
                        source: this.id,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,
                            extent: e1.EXTENT,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: e1.EXTENT,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter
                    }, i.workerOptions);
                }
                onAdd(e1) {
                    this.map = e1, this.setData(this._data);
                }
                setData(e1) {
                    return this._data = e1, this._updateWorkerData(), this;
                }
                getClusterExpansionZoom(e1, t1) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e1,
                        source: this.id
                    }, t1), this;
                }
                getClusterChildren(e1, t1) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e1,
                        source: this.id
                    }, t1), this;
                }
                getClusterLeaves(e1, t1, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        clusterId: e1,
                        limit: t1,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const t1 = e1.extend({}, this.workerOptions), i = this._data;
                    "string" == typeof i ? (t1.request = this.map._requestManager.transformRequest(e1.exported.resolveURL(i), e1.ResourceType.Source), t1.request.collectResourceTiming = this._collectResourceTiming) : t1.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t1, (t1, i)=>{
                        if (this._loaded = !0, this._pendingLoad = null, t1) this.fire(new e1.ErrorEvent(t1));
                        else {
                            const t1 = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t1.resourceTiming = i.resourceTiming[this.id]), this.fire(new e1.Event("data", t1)), this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = t1.actor ? "reloadTile" : "loadTile";
                    t1.actor = this.actor, t1.request = this.actor.send(o, {
                        type: this.type,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        pixelRatio: e1.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId
                    }, (e1, r)=>(delete t1.request, t1.unloadVectorData(), t1.aborted ? i(null) : e1 ? i(e1) : (t1.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }
                abortTile(e1) {
                    e1.request && (e1.request.cancel(), delete e1.request), e1.aborted = !0;
                }
                unloadTile(e1) {
                    e1.unloadVectorData(), this.actor.send("removeTile", {
                        uid: e1.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return e1.extend({}, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends Pe {
                constructor(e1, t1, i, o){
                    super(e1, t1, i, o), this.roundZoom = !0, this.type = "video", this.options = t1;
                }
                load() {
                    this._loaded = !1;
                    const t1 = this.options;
                    this.urls = [];
                    for (const i of t1.urls)this.urls.push(this.map._requestManager.transformRequest(i, e1.ResourceType.Source).url);
                    e1.getVideo(this.urls, (t1, i)=>{
                        this._loaded = !0, t1 ? this.fire(new e1.ErrorEvent(t1)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t1) {
                    if (this.video) {
                        const i = this.video.seekable;
                        t1 < i.start(0) || t1 > i.end(0) ? this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t1;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e1) {
                    this.map || (this.map = e1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t1 = this.map.painter.context, i = t1.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e1.Texture(t1, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t1);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: Pe,
            canvas: class extends Pe {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e1)=>!Array.isArray(e1) || 2 !== e1.length || e1.some((e1)=>"number" != typeof e1)) || this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof e1.window.HTMLCanvasElement || this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e1.window.HTMLCanvasElement ? this.options.canvas : e1.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e1.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e1) {
                    this.map = e1, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove() {
                    this.pause();
                }
                prepare() {
                    let t1 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t1 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i = this.map.painter.context;
                    this.texture ? (t1 || this._playing) && this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e1.Texture(i, this.canvas, i.gl.RGBA, {
                        premultiply: !0
                    }), this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e1 of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e1) || e1 <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e1.Evented {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e1.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e1.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new B(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e1.extend(this, e1.pick(i, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e1.pick(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t1) {
                    this._map = t1, this._loaded = !1, this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t1), this.load();
                }
                onRemove(e1) {
                    this._implementation.onRemove && this._implementation.onRemove(e1);
                }
                hasTile(e1) {
                    if (this._implementation.hasTile) {
                        const { x: t1, y: i, z: o } = e1.canonical;
                        return this._implementation.hasTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e1.canonical);
                }
                loadTile(t1, i) {
                    const { x: o, y: r, z: n } = t1.tileID.canonical, s = new e1.window.AbortController;
                    t1.request = Promise.resolve(this._implementation.loadTile({
                        x: o,
                        y: r,
                        z: n
                    }, {
                        signal: s.signal
                    })).then((function(o) {
                        return delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : void 0 === o ? (t1.state = "errored", i(null)) : null === o ? (this.loadTileData(t1, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), t1.state = "loaded", i(null)) : function(t1) {
                            return t1 instanceof e1.window.ImageData || t1 instanceof e1.window.HTMLCanvasElement || t1 instanceof e1.window.ImageBitmap || t1 instanceof e1.window.HTMLImageElement;
                        }(o) ? (this.loadTileData(t1, o), t1.state = "loaded", void i(null)) : (t1.state = "errored", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((e1)=>{
                        20 !== e1.code && (t1.state = "errored", i(e1));
                    }), t1.request.cancel = ()=>s.abort();
                }
                loadTileData(e1, t1) {
                    Me.loadTileData(e1, t1, this._map.painter);
                }
                unloadTileData(e1) {
                    Me.unloadTileData(e1, this._map.painter);
                }
                unloadTile(e1, t1) {
                    if (this.unloadTileData(e1), this._implementation.unloadTile) {
                        const { x: t1, y: i, z: o } = e1.tileID.canonical;
                        this._implementation.unloadTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    t1();
                }
                abortTile(e1, t1) {
                    e1.request && e1.request.cancel && (e1.request.cancel(), delete e1.request), t1();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this._map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e1)=>({
                            x: e1.canonical.x,
                            y: e1.canonical.y,
                            z: e1.canonical.z
                        }));
                }
                _clearTiles() {
                    this._map.style._clearSource(this.id);
                }
                _update() {
                    this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, De = function(t1, i, o, r) {
            const n = new Se[i.type](t1, i, o, r);
            if (n.id !== t1) throw new Error(`Expected Source id to be ${t1} instead of ${n.id}`);
            return e1.bindAll([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], n), n;
        };
        function Le(t1, i) {
            const o = e1.identity([]);
            return e1.scale(o, o, [
                .5 * t1.width,
                .5 * -t1.height,
                1
            ]), e1.translate(o, o, [
                1,
                -1,
                0
            ]), e1.multiply(o, o, t1.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
        }
        function Ae(e1, t1, i, o, r, n, s, a = !1) {
            const l = e1.tilesIn(o, s, a);
            l.sort(Re);
            const c = [];
            for (const o of l)c.push({
                wrappedTileID: o.tile.tileID.wrapped().key,
                queryResults: o.tile.queryRenderedFeatures(t1, i, e1._state, o, r, n, Le(e1.transform, o.tile.tileID), a)
            });
            const h = function(e1) {
                const t1 = {}, i = {};
                for (const o of e1){
                    const e1 = o.queryResults, r = o.wrappedTileID, n = i[r] = i[r] || {};
                    for(const i in e1){
                        const o = e1[i], r = n[i] = n[i] || {}, s = t1[i] = t1[i] || [];
                        for (const e1 of o)r[e1.featureIndex] || (r[e1.featureIndex] = !0, s.push(e1));
                    }
                }
                return t1;
            }(c);
            for(const t1 in h)h[t1].forEach((t1)=>{
                const i = t1.feature, o = i.layer;
                o && "background" !== o.type && "sky" !== o.type && (i.source = o.source, o["source-layer"] && (i.sourceLayer = o["source-layer"]), i.state = void 0 !== i.id ? e1.getFeatureState(o["source-layer"], i.id) : {});
            });
            return h;
        }
        function ze(e1, t1) {
            const i = e1.getRenderableIds().map((t1)=>e1.getTileByID(t1)), o = [], r = {};
            for(let e1 = 0; e1 < i.length; e1++){
                const n = i[e1], s = n.tileID.canonical.key;
                r[s] || (r[s] = !0, n.querySourceFeatures(o, t1));
            }
            return o;
        }
        function Re(e1, t1) {
            const i = e1.tileID, o = t1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        function Oe() {
            return null != dn.workerClass ? new dn.workerClass : new e1.window.Worker(dn.workerUrl);
        }
        const Be = "mapboxgl_preloaded_worker_pool";
        class ke {
            constructor(){
                this.active = {};
            }
            acquire(e1) {
                if (!this.workers) for(this.workers = []; this.workers.length < ke.workerCount;)this.workers.push(new Oe);
                return this.active[e1] = !0, this.workers.slice();
            }
            release(e1) {
                delete this.active[e1], 0 === this.numActive() && (this.workers.forEach((e1)=>{
                    e1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[Be];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        let Fe;
        function Ue() {
            return Fe || (Fe = new ke), Fe;
        }
        function Ne(t1, i) {
            const o = {};
            for(const e1 in t1)"ref" !== e1 && (o[e1] = t1[e1]);
            return e1.refProperties.forEach((e1)=>{
                e1 in i && (o[e1] = i[e1]);
            }), o;
        }
        function je(e1) {
            e1 = e1.slice();
            const t1 = Object.create(null);
            for(let i = 0; i < e1.length; i++)t1[e1[i].id] = e1[i];
            for(let i = 0; i < e1.length; i++)"ref" in e1[i] && (e1[i] = Ne(e1[i], t1[e1[i].ref]));
            return e1;
        }
        ke.workerCount = 2;
        const Ge = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setProjection: "setProjection"
        };
        function Ze(e1, t1, i) {
            i.push({
                command: Ge.addSource,
                args: [
                    e1,
                    t1[e1]
                ]
            });
        }
        function Ve(e1, t1, i) {
            t1.push({
                command: Ge.removeSource,
                args: [
                    e1
                ]
            }), i[e1] = !0;
        }
        function We(e1, t1, i, o) {
            Ve(e1, i, o), Ze(e1, t1, i);
        }
        function Xe(e1, i, o) {
            let r;
            for(r in e1[o])if (e1[o].hasOwnProperty(r) && "data" !== r && !t1(e1[o][r], i[o][r])) return !1;
            for(r in i[o])if (i[o].hasOwnProperty(r) && "data" !== r && !t1(e1[o][r], i[o][r])) return !1;
            return !0;
        }
        function qe(e1, i, o, r, n, s) {
            let a;
            for(a in i = i || {}, e1 = e1 || {})e1.hasOwnProperty(a) && (t1(e1[a], i[a]) || o.push({
                command: s,
                args: [
                    r,
                    a,
                    i[a],
                    n
                ]
            }));
            for(a in i)i.hasOwnProperty(a) && !e1.hasOwnProperty(a) && (t1(e1[a], i[a]) || o.push({
                command: s,
                args: [
                    r,
                    a,
                    i[a],
                    n
                ]
            }));
        }
        function $e(e1) {
            return e1.id;
        }
        function He(e1, t1) {
            return e1[t1.id] = t1, e1;
        }
        class Ye {
            constructor(e1, t1){
                this.reset(e1, t1);
            }
            reset(e1, t1) {
                this.points = e1 || [], this._distances = [
                    0
                ];
                for(let e1 = 1; e1 < this.points.length; e1++)this._distances[e1] = this._distances[e1 - 1] + this.points[e1].dist(this.points[e1 - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t1) {
                if (1 === this.points.length) return this.points[0];
                t1 = e1.clamp(t1, 0, 1);
                let i = 1, o = this._distances[i];
                const r = t1 * this.paddedLength + this.padding;
                for(; o < r && i < this._distances.length;)o = this._distances[++i];
                const n = i - 1, s = this._distances[n], a = o - s, l = a > 0 ? (r - s) / a : 0;
                return this.points[n].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        class Ke {
            constructor(e1, t1, i){
                const o = this.boxCells = [], r = this.circleCells = [];
                this.xCellCount = Math.ceil(e1 / i), this.yCellCount = Math.ceil(t1 / i);
                for(let e1 = 0; e1 < this.xCellCount * this.yCellCount; e1++)o.push([]), r.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e1, this.height = t1, this.xScale = this.xCellCount / e1, this.yScale = this.yCellCount / t1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e1, t1, i, o, r) {
                this._forEachCell(t1, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e1), this.bboxes.push(t1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
            }
            insertCircle(e1, t1, i, o) {
                this._forEachCell(t1 - o, i - o, t1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e1), this.circles.push(t1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e1, t1, i, o, r, n) {
                this.boxCells[r].push(n);
            }
            _insertCircleCell(e1, t1, i, o, r, n) {
                this.circleCells[r].push(n);
            }
            _query(e1, t1, i, o, r, n) {
                if (i < 0 || e1 > this.width || o < 0 || t1 > this.height) return !r && [];
                const s = [];
                if (e1 <= 0 && t1 <= 0 && this.width <= i && this.height <= o) {
                    if (r) return !0;
                    for(let e1 = 0; e1 < this.boxKeys.length; e1++)s.push({
                        key: this.boxKeys[e1],
                        x1: this.bboxes[4 * e1],
                        y1: this.bboxes[4 * e1 + 1],
                        x2: this.bboxes[4 * e1 + 2],
                        y2: this.bboxes[4 * e1 + 3]
                    });
                    for(let e1 = 0; e1 < this.circleKeys.length; e1++){
                        const t1 = this.circles[3 * e1], i = this.circles[3 * e1 + 1], o = this.circles[3 * e1 + 2];
                        s.push({
                            key: this.circleKeys[e1],
                            x1: t1 - o,
                            y1: i - o,
                            x2: t1 + o,
                            y2: i + o
                        });
                    }
                    return n ? s.filter(n) : s;
                }
                return this._forEachCell(e1, t1, i, o, this._queryCell, s, {
                    hitTest: r,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, n), r ? s.length > 0 : s;
            }
            _queryCircle(e1, t1, i, o, r) {
                const n = e1 - i, s = e1 + i, a = t1 - i, l = t1 + i;
                if (s < 0 || n > this.width || l < 0 || a > this.height) return !o && [];
                const c = [];
                return this._forEachCell(n, a, s, l, this._queryCellCircle, c, {
                    hitTest: o,
                    circle: {
                        x: e1,
                        y: t1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, r), o ? c.length > 0 : c;
            }
            query(e1, t1, i, o, r) {
                return this._query(e1, t1, i, o, !1, r);
            }
            hitTest(e1, t1, i, o, r) {
                return this._query(e1, t1, i, o, !0, r);
            }
            hitTestCircle(e1, t1, i, o) {
                return this._queryCircle(e1, t1, i, !0, o);
            }
            _queryCell(e1, t1, i, o, r, n, s, a) {
                const l = s.seenUids, c = this.boxCells[r];
                if (null !== c) {
                    const r = this.bboxes;
                    for (const h of c)if (!l.box[h]) {
                        l.box[h] = !0;
                        const c = 4 * h;
                        if (e1 <= r[c + 2] && t1 <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {
                            if (s.hitTest) return n.push(!0), !0;
                            n.push({
                                key: this.boxKeys[h],
                                x1: r[c],
                                y1: r[c + 1],
                                x2: r[c + 2],
                                y2: r[c + 3]
                            });
                        }
                    }
                }
                const h = this.circleCells[r];
                if (null !== h) {
                    const r = this.circles;
                    for (const c of h)if (!l.circle[c]) {
                        l.circle[c] = !0;
                        const h = 3 * c;
                        if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e1, t1, i, o) && (!a || a(this.circleKeys[c]))) {
                            if (s.hitTest) return n.push(!0), !0;
                            {
                                const e1 = r[h], t1 = r[h + 1], i = r[h + 2];
                                n.push({
                                    key: this.circleKeys[c],
                                    x1: e1 - i,
                                    y1: t1 - i,
                                    x2: e1 + i,
                                    y2: t1 + i
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e1, t1, i, o, r, n, s, a) {
                const l = s.circle, c = s.seenUids, h = this.boxCells[r];
                if (null !== h) {
                    const e1 = this.bboxes;
                    for (const t1 of h)if (!c.box[t1]) {
                        c.box[t1] = !0;
                        const i = 4 * t1;
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, e1[i + 0], e1[i + 1], e1[i + 2], e1[i + 3]) && (!a || a(this.boxKeys[t1]))) return n.push(!0), !0;
                    }
                }
                const u = this.circleCells[r];
                if (null !== u) {
                    const e1 = this.circles;
                    for (const t1 of u)if (!c.circle[t1]) {
                        c.circle[t1] = !0;
                        const i = 3 * t1;
                        if (this._circlesCollide(e1[i], e1[i + 1], e1[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t1]))) return n.push(!0), !0;
                    }
                }
            }
            _forEachCell(e1, t1, i, o, r, n, s, a) {
                const l = this._convertToXCellCoord(e1), c = this._convertToYCellCoord(t1), h = this._convertToXCellCoord(i), u = this._convertToYCellCoord(o);
                for(let _ = l; _ <= h; _++)for(let l = c; l <= u; l++)if (r.call(this, e1, t1, i, o, this.xCellCount * l + _, n, s, a)) return;
            }
            _convertToXCellCoord(e1) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e1 * this.xScale)));
            }
            _convertToYCellCoord(e1) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e1 * this.yScale)));
            }
            _circlesCollide(e1, t1, i, o, r, n) {
                const s = o - e1, a = r - t1, l = i + n;
                return l * l > s * s + a * a;
            }
            _circleAndRectCollide(e1, t1, i, o, r, n, s) {
                const a = (n - o) / 2, l = Math.abs(e1 - (o + a));
                if (l > a + i) return !1;
                const c = (s - r) / 2, h = Math.abs(t1 - (r + c));
                if (h > c + i) return !1;
                if (l <= a || h <= c) return !0;
                const u = l - a, _ = h - c;
                return u * u + _ * _ <= i * i;
            }
        }
        const Je = {
            unknown: 0,
            flipRequired: 1,
            flipNotRequired: 2
        }, Qe = Math.tan(85 * Math.PI / 180);
        function et(t1, i, o, r, n, s, a) {
            const l = e1.create();
            if (o) {
                if ("globe" === s.name) {
                    const t1 = e1.calculateGlobeLabelMatrix(n, i);
                    e1.multiply(l, l, t1);
                } else {
                    const t1 = v([], a);
                    l[0] = t1[0], l[1] = t1[1], l[4] = t1[2], l[5] = t1[3], r || e1.rotateZ(l, l, n.angle);
                }
            } else e1.multiply(l, n.labelPlaneMatrix, t1);
            return l;
        }
        function tt(e1, t1, i, o, r, n, s) {
            const a = et(e1, t1, i, o, r, n, s);
            return "globe" === n.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;
        }
        function it(t1, i, o, r, n, s, a) {
            if (o) {
                if ("globe" === s.name) {
                    const l = et(t1, i, o, r, n, s, a);
                    return e1.invert(l, l), e1.multiply(l, t1, l), l;
                }
                {
                    const i = e1.clone(t1), o = e1.identity([]);
                    return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e1.multiply(i, i, o), r || e1.rotateZ(i, i, -n.angle), i;
                }
            }
            return n.glCoordMatrix;
        }
        function ot(t1, i, o, r) {
            const n = [
                t1,
                i,
                o,
                1
            ];
            o ? e1.transformMat4$1(n, n, r) : pt(n, n, r);
            const s = n[3];
            return n[0] /= s, n[1] /= s, n[2] /= s, n;
        }
        function rt(e1, t1) {
            return Math.min(.5 + e1 / t1 * .5, 1.5);
        }
        function nt(e1, t1) {
            const i = e1[0] / e1[3], o = e1[1] / e1[3];
            return i >= -t1[0] && i <= t1[0] && o >= -t1[1] && o <= t1[1];
        }
        function st(t1, i, o, r, n, s, a, l, c, h) {
            const u = o.transform, _ = r ? t1.textSizeData : t1.iconSizeData, d = e1.evaluateSizeForZoom(_, o.transform.zoom), p = "globe" === u.projection.name, m = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], f = r ? t1.text.dynamicLayoutVertexArray : t1.icon.dynamicLayoutVertexArray;
            f.clear();
            let g = null;
            p && (g = r ? t1.text.globeExtVertexArray : t1.icon.globeExtVertexArray);
            const v = t1.lineVertexArray, x = r ? t1.text.placedSymbolArray : t1.icon.placedSymbolArray, y = o.transform.width / o.transform.height;
            let b, w = !1;
            for(let r = 0; r < x.length; r++){
                const p = x.get(r), { numGlyphs: T, writingMode: E } = p;
                if (E !== e1.WritingMode.vertical || w || b === e1.WritingMode.horizontal || (w = !0), b = E, (p.hidden || E === e1.WritingMode.vertical) && !w) {
                    dt(T, f);
                    continue;
                }
                w = !1;
                const C = new e1.Point(p.tileAnchorX, p.tileAnchorY);
                let { x: M, y: I, z: P } = u.projection.projectTilePoint(C.x, C.y, h.canonical);
                if (c) {
                    const [e1, t1, i] = c(C);
                    M += e1, I += t1, P += i;
                }
                const S = [
                    M,
                    I,
                    P,
                    1
                ];
                if (e1.transformMat4$1(S, S, i), !nt(S, m)) {
                    dt(T, f);
                    continue;
                }
                const D = rt(o.transform.cameraToCenterDistance, S[3]), L = e1.evaluateSizeForFeature(_, d, p), A = a ? L / D : L * D, z = ot(M, I, P, n);
                if (z[3] <= 0) {
                    dt(T, f);
                    continue;
                }
                let R = {};
                const O = a ? null : c, B = ct(p, A, !1, l, i, n, s, t1.glyphOffsetArray, v, f, g, z, C, R, y, O, u.projection, h, a);
                w = B.useVertical, O && B.needsFlipping && (R = {}), (B.notEnoughRoom || w || B.needsFlipping && ct(p, A, !0, l, i, n, s, t1.glyphOffsetArray, v, f, g, z, C, R, y, O, u.projection, h, a).notEnoughRoom) && dt(T, f);
            }
            r ? (t1.text.dynamicLayoutVertexBuffer.updateData(f), g && t1.text.globeExtVertexBuffer.updateData(g)) : (t1.icon.dynamicLayoutVertexBuffer.updateData(f), g && t1.icon.globeExtVertexBuffer.updateData(g));
        }
        function at(e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
            const { lineStartIndex: f, glyphStartIndex: g, segment: v } = a, x = g + a.numGlyphs, y = f + a.lineLength, b = t1.getoffsetX(g), w = t1.getoffsetX(x - 1), T = _t(e1 * b, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);
            if (!T) return null;
            const E = _t(e1 * w, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);
            return E ? {
                first: T,
                last: E
            } : null;
        }
        function lt(t1, i, o, r) {
            return t1 === e1.WritingMode.horizontal && Math.abs(r) > Math.abs(o) ? {
                useVertical: !0
            } : t1 === e1.WritingMode.vertical ? r > 0 ? {
                needsFlipping: !0
            } : null : i !== Je.unknown && function(e1, t1) {
                return 0 === e1 || Math.abs(t1 / e1) > Qe;
            }(o, r) ? i === Je.flipRequired ? {
                needsFlipping: !0
            } : null : o < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function ct(t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v, x) {
            const y = i / 24, b = t1.lineOffsetX * y, w = t1.lineOffsetY * y, { lineStartIndex: T, glyphStartIndex: E, numGlyphs: C, segment: M, writingMode: I, flipState: P } = t1, S = T + t1.lineLength, D = (t1)=>{
                if (u) {
                    const [i, o, r] = t1.up, n = h.length;
                    e1.updateGlobeVertexNormal(u, n + 0, i, o, r), e1.updateGlobeVertexNormal(u, n + 1, i, o, r), e1.updateGlobeVertexNormal(u, n + 2, i, o, r), e1.updateGlobeVertexNormal(u, n + 3, i, o, r);
                }
                const [i, o, r] = t1.point;
                e1.addDynamicAttributes(h, i, o, r, t1.angle);
            };
            if (C > 1) {
                const e1 = at(y, l, b, w, o, _, d, t1, c, s, p, f, !1, g, v, x);
                if (!e1) return {
                    notEnoughRoom: !0
                };
                if (r && !o) {
                    let [i, o, r] = e1.first.point, [n, s, l] = e1.last.point;
                    [i, o] = ot(i, o, r, a), [n, s] = ot(n, s, l, a);
                    const c = lt(I, P, (n - i) * m, s - o);
                    if (t1.flipState = c && c.needsFlipping ? Je.flipRequired : Je.flipNotRequired, c) return c;
                }
                D(e1.first);
                for(let e1 = E + 1; e1 < E + C - 1; e1++){
                    const t1 = _t(y * l.getoffsetX(e1), b, w, o, _, d, M, T, S, c, s, p, f, !1, !1, g, v, x);
                    if (!t1) return h.length -= 4 * (e1 - E), {
                        notEnoughRoom: !0
                    };
                    D(t1);
                }
                D(e1.last);
            } else {
                if (r && !o) {
                    const i = ot(d.x, d.y, 0, n), o = T + M + 1, r = new e1.Point(c.getx(o), c.gety(o)), s = ot(r.x, r.y, 0, n), a = s[3] > 0 ? s : ut(d, r, i, 1, n, void 0, g, v.canonical), l = lt(I, P, (a[0] - i[0]) * m, a[1] - i[1]);
                    if (t1.flipState = l && l.needsFlipping ? Je.flipRequired : Je.flipNotRequired, l) return l;
                }
                const i = _t(y * l.getoffsetX(E), b, w, o, _, d, M, T, S, c, s, p, f, !1, !1, g, v, x);
                if (!i) return {
                    notEnoughRoom: !0
                };
                D(i);
            }
            return {};
        }
        function ht(e1, t1, i, o, r) {
            const { x: n, y: s, z: a } = o.projectTilePoint(e1.x, e1.y, t1);
            if (!r) return ot(n, s, a, i);
            const [l, c, h] = r(e1);
            return ot(n + l, s + c, a + h, i);
        }
        function ut(t1, i, o, r, n, s, a, l) {
            const c = ht(t1.sub(i)._unit()._add(t1), l, n, a, s);
            return e1.sub(c, o, c), e1.normalize(c, c), e1.scaleAndAdd(c, o, c, r);
        }
        function _t(t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v) {
            const x = r ? t1 - i : t1 + i;
            let y = x > 0 ? 1 : -1, b = 0;
            r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);
            let w = l + a + (y > 0 ? 0 : 1) | 0, T = n, E = n, C = 0, M = 0;
            const I = Math.abs(x), P = [], S = [];
            let D = s, L = D;
            const A = ()=>ut(L, D, E, I - C + 1, u, d, f, g.canonical);
            for(; C + M <= I;){
                if (w += y, w < l || w >= c) return null;
                if (E = T, L = D, P.push(E), p && S.push(L), D = new e1.Point(h.getx(w), h.gety(w)), T = _[w], !T) {
                    const e1 = ht(D, g.canonical, u, f, d);
                    T = e1[3] > 0 ? _[w] = e1 : A();
                }
                C += M, M = e1.distance(E, T);
            }
            m && d && (_[w] && (T = A(), M = e1.distance(E, T)), _[w] = T);
            const z = (I - C) / M, R = D.sub(L)._mult(z)._add(L), O = e1.sub([], T, E), B = e1.scaleAndAdd([], E, O, z);
            let k = [
                0,
                0,
                1
            ], F = O[0], U = O[1];
            if (v && (k = f.upVector(g.canonical, R.x, R.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
                const t1 = [
                    k[2],
                    0,
                    -k[0]
                ], i = e1.cross([], k, t1);
                e1.normalize(t1, t1), e1.normalize(i, i), F = e1.dot(O, t1), U = e1.dot(O, i);
            }
            if (o) {
                const t1 = e1.cross([], k, O);
                e1.normalize(t1, t1), e1.scaleAndAdd(B, B, t1, o * y);
            }
            const N = b + Math.atan2(U, F);
            return P.push(B), p && S.push(R), {
                point: B,
                angle: N,
                path: P,
                tilePath: S,
                up: k
            };
        }
        function dt(e1, t1) {
            const i = t1.length, o = i + 4 * e1;
            t1.resize(o), t1.float32.fill(-1 / 0, 4 * i, 4 * o);
        }
        function pt(e1, t1, i) {
            const o = t1[0], r = t1[1];
            return e1[0] = i[0] * o + i[4] * r + i[12], e1[1] = i[1] * o + i[5] * r + i[13], e1[3] = i[3] * o + i[7] * r + i[15], e1;
        }
        const mt = 100;
        class ft {
            constructor(e1, t1, i = new Ke(e1.width + 200, e1.height + 200, 25), o = new Ke(e1.width + 200, e1.height + 200, 25)){
                this.transform = e1, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e1._pitch) * e1.cameraToCenterDistance, this.screenRightBoundary = e1.width + mt, this.screenBottomBoundary = e1.height + mt, this.gridRightBoundary = e1.width + 200, this.gridBottomBoundary = e1.height + 200, this.fogState = t1;
            }
            placeCollisionBox(e1, t1, i, o, r, n, s, a) {
                let l = i.projectedAnchorX, c = i.projectedAnchorY, h = i.projectedAnchorZ;
                const u = i.elevation, _ = i.tileID, d = e1.getProjection();
                if (u && _) {
                    const [e1, t1, o] = d.upVector(_.canonical, i.tileAnchorX, i.tileAnchorY), r = d.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l += e1 * u * r, c += t1 * u * r, h += o * u * r;
                }
                const p = this.projectAndGetPerspectiveRatio(s, l, c, h, i.tileID, "globe" === d.name || !!u || this.transform.pitch > 0, d), m = n * p.perspectiveRatio, f = (i.x1 * t1 + o.x - i.padding) * m + p.point.x, g = (i.y1 * t1 + o.y - i.padding) * m + p.point.y, v = (i.x2 * t1 + o.x + i.padding) * m + p.point.x, x = (i.y2 * t1 + o.y + i.padding) * m + p.point.y, y = p.perspectiveRatio <= .55 || p.occluded;
                return !this.isInsideGrid(f, g, v, x) || !r && this.grid.hitTest(f, g, v, x, a) || y ? {
                    box: [],
                    offscreen: !1,
                    occluded: p.occluded
                } : {
                    box: [
                        f,
                        g,
                        v,
                        x
                    ],
                    offscreen: this.isOffscreen(f, g, v, x),
                    occluded: !1
                };
            }
            placeCollisionCircles(t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
                const f = [], g = this.transform.elevation, v = t1.getProjection(), x = g ? g.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, v) : null, y = new e1.Point(o.tileAnchorX, o.tileAnchorY);
                let { x: b, y: w, z: T } = v.projectTilePoint(y.x, y.y, m.canonical);
                if (x) {
                    const [e1, t1, i] = x(y);
                    b += e1, w += t1, T += i;
                }
                const E = "globe" === v.name, C = this.projectAndGetPerspectiveRatio(a, b, w, T, m, E || !!g || this.transform.pitch > 0, v), { perspectiveRatio: M } = C, I = (u ? s / M : s * M) / e1.ONE_EM, P = ot(b, w, T, l), S = C.signedDistanceFromCamera > 0 ? at(I, n, o.lineOffsetX * I, o.lineOffsetY * I, !1, P, y, o, r, l, {}, g && !u ? x : null, u && !!g, v, m, u) : null;
                let D = !1, L = !1, A = !0;
                if (S && !C.occluded) {
                    const t1 = .5 * d * M + p, o = new e1.Point(-100, -100), r = new e1.Point(this.screenRightBoundary, this.screenBottomBoundary), n = new Ye, { first: s, last: a } = S, l = s.path.length;
                    let u = [];
                    for(let e1 = l - 1; e1 >= 1; e1--)u.push(s.path[e1]);
                    for(let e1 = 1; e1 < a.path.length; e1++)u.push(a.path[e1]);
                    const m = 2.5 * t1;
                    c && (u = u.map(([e1, t1, i], o)=>(x && !E && (i = x(o < l - 1 ? s.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), ot(e1, t1, i, c))), u.some((e1)=>e1[3] <= 0) && (u = []));
                    let g = [];
                    if (u.length > 0) {
                        let t1 = 1 / 0, i = -1 / 0, n = 1 / 0, s = -1 / 0;
                        for (const e1 of u)t1 = Math.min(t1, e1[0]), n = Math.min(n, e1[1]), i = Math.max(i, e1[0]), s = Math.max(s, e1[1]);
                        i >= o.x && t1 <= r.x && s >= o.y && n <= r.y && (g = [
                            u.map((t1)=>new e1.Point(t1[0], t1[1]))
                        ], (t1 < o.x || i > r.x || n < o.y || s > r.y) && (g = e1.clipLine(g, o.x, o.y, r.x, r.y)));
                    }
                    for (const e1 of g){
                        n.reset(e1, .25 * t1);
                        let o = 0;
                        o = n.length <= .5 * t1 ? 1 : Math.ceil(n.paddedLength / m) + 1;
                        for(let e1 = 0; e1 < o; e1++){
                            const r = e1 / Math.max(o - 1, 1), s = n.lerp(r), a = s.x + mt, l = s.y + mt;
                            f.push(a, l, t1, 0);
                            const c = a - t1, u = l - t1, d = a + t1, p = l + t1;
                            if (A = A && this.isOffscreen(c, u, d, p), L = L || this.isInsideGrid(c, u, d, p), !i && this.grid.hitTestCircle(a, l, t1, _) && (D = !0, !h)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: D,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !h && D || !L ? [] : f,
                    offscreen: A,
                    collisionDetected: D,
                    occluded: C.occluded
                };
            }
            queryRenderedSymbols(t1) {
                if (0 === t1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, r = 1 / 0, n = -1 / 0, s = -1 / 0;
                for (const a of t1){
                    const t1 = new e1.Point(a.x + mt, a.y + mt);
                    o = Math.min(o, t1.x), r = Math.min(r, t1.y), n = Math.max(n, t1.x), s = Math.max(s, t1.y), i.push(t1);
                }
                const a = this.grid.query(o, r, n, s).concat(this.ignoredGrid.query(o, r, n, s)), l = {}, c = {};
                for (const t1 of a){
                    const o = t1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const r = [
                        new e1.Point(t1.x1, t1.y1),
                        new e1.Point(t1.x2, t1.y1),
                        new e1.Point(t1.x2, t1.y2),
                        new e1.Point(t1.x1, t1.y2)
                    ];
                    e1.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(e1, t1, i, o, r) {
                (t1 ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                }, e1[0], e1[1], e1[2], e1[3]);
            }
            insertCollisionCircles(e1, t1, i, o, r) {
                const n = t1 ? this.ignoredGrid : this.grid, s = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                };
                for(let t1 = 0; t1 < e1.length; t1 += 4)n.insertCircle(s, e1[t1], e1[t1 + 1], e1[t1 + 2]);
            }
            projectAndGetPerspectiveRatio(t1, i, o, r, n, s, a) {
                const l = [
                    i,
                    o,
                    r,
                    1
                ];
                let c = !1;
                if (r || this.transform.pitch > 0) {
                    if (e1.transformMat4$1(l, l, t1), this.fogState && n && "globe" !== a.name) {
                        const t1 = function(t1, i, o, r, n, s) {
                            const a = s.calculateFogTileMatrix(n), l = [
                                i,
                                o,
                                r
                            ];
                            return e1.transformMat4(l, l, a), C(t1, l, s.pitch, s._fov);
                        }(this.fogState, i, o, r, n.toUnwrapped(), this.transform);
                        c = t1 > .9;
                    }
                } else pt(l, l, t1);
                const h = l[3];
                return {
                    point: new e1.Point((l[0] / h + 1) / 2 * this.transform.width + mt, (-l[1] / h + 1) / 2 * this.transform.height + mt),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),
                    signedDistanceFromCamera: h,
                    occluded: s && l[2] > h || c
                };
            }
            isOffscreen(e1, t1, i, o) {
                return i < mt || e1 >= this.screenRightBoundary || o < mt || t1 > this.screenBottomBoundary;
            }
            isInsideGrid(e1, t1, i, o) {
                return i >= 0 && e1 < this.gridRightBoundary && o >= 0 && t1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t1 = e1.identity([]);
                return e1.translate(t1, t1, [
                    -100,
                    -100,
                    0
                ]), t1;
            }
        }
        function gt(t1, i, o) {
            const r = i.createTileMatrix(t1, t1.worldSize, o.toUnwrapped());
            return e1.multiply(new Float32Array(16), t1.projMatrix, r);
        }
        function vt(e1, t1, i) {
            if (t1.projection.name === i.projection.name) return e1.projMatrix;
            const o = i.clone();
            return o.setProjection(t1.projection), gt(o, t1.getProjection(), e1);
        }
        function xt(e1, t1, i) {
            return t1.name === i.projection.name ? e1.projMatrix : gt(i, t1, e1);
        }
        class yt {
            constructor(e1, t1, i, o){
                this.opacity = e1 ? Math.max(0, Math.min(1, e1.opacity + (e1.placed ? t1 : -t1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class bt {
            constructor(e1, t1, i, o, r, n = !1){
                this.text = new yt(e1 ? e1.text : null, t1, i, r), this.icon = new yt(e1 ? e1.icon : null, t1, o, r), this.clipped = n;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class wt {
            constructor(e1, t1, i, o = !1){
                this.text = e1, this.icon = t1, this.skipFade = i, this.clipped = o;
            }
        }
        class Tt {
            constructor(){
                this.invProjMatrix = e1.create(), this.viewportMatrix = e1.create(), this.circles = [];
            }
        }
        class Et {
            constructor(e1, t1, i, o, r){
                this.bucketInstanceId = e1, this.featureIndex = t1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
            }
        }
        class Ct {
            constructor(e1){
                this.crossSourceCollisions = e1, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e1) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e1]) {
                    const t1 = ++this.maxGroupID;
                    this.collisionGroups[e1] = {
                        ID: t1,
                        predicate: (e1)=>e1.collisionGroupID === t1
                    };
                }
                return this.collisionGroups[e1];
            }
        }
        function Mt(t1, i, o, r, n) {
            const { horizontalAlign: s, verticalAlign: a } = e1.getAnchorAlignment(t1), l = -(s - .5) * i, c = -(a - .5) * o, h = e1.evaluateVariableOffset(t1, r);
            return new e1.Point(l + h[0] * n, c + h[1] * n);
        }
        function It(t1, i, o, r, n) {
            const s = new e1.Point(t1, i);
            return o && s._rotate(r ? n : -n), s;
        }
        class Pt {
            constructor(e1, t1, i, o, r){
                this.transform = e1.clone(), this.projection = e1.projection.name, this.collisionIndex = new ft(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t1, this.retainedQueryData = {}, this.collisionGroups = new Ct(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t1, i, o, r) {
                const n = o.getBucket(i), s = o.latestFeatureIndex;
                if (!n || !s || i.id !== n.layerIds[0]) return;
                const a = n.layers[0].layout, l = o.collisionBoxArray, c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), h = o.tileSize / e1.EXTENT, u = o.tileID.toUnwrapped();
                this.transform.setProjection(n.projection);
                const _ = (d = o.tileID, p = n.getProjection(), m = this.transform, p.name === this.projection ? m.calculateProjMatrix(d.toUnwrapped()) : gt(m, p, d));
                var d, p, m;
                const f = "map" === a.get("text-pitch-alignment"), g = "map" === a.get("text-rotation-alignment");
                i.compileFilter();
                const v = i.dynamicFilter(), x = i.dynamicFilterNeedsFeature(), y = this.transform.calculatePixelsToTileUnitsMatrix(o), b = tt(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);
                let w = null;
                if (f) {
                    const t1 = it(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);
                    w = e1.multiply([], this.transform.labelPlaneMatrix, t1);
                }
                let T = null;
                v && o.latestFeatureIndex && (T = {
                    unwrappedTileID: u,
                    dynamicFilter: v,
                    dynamicFilterNeedsFeature: x,
                    featureIndex: o.latestFeatureIndex
                }), this.retainedQueryData[n.bucketInstanceId] = new Et(n.bucketInstanceId, s, n.sourceLayerIndex, n.index, o.tileID);
                const E = {
                    bucket: n,
                    layout: a,
                    posMatrix: _,
                    textLabelPlaneMatrix: b,
                    labelToScreenMatrix: w,
                    clippingData: T,
                    scale: c,
                    textPixelRatio: h,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: l,
                    partiallyEvaluatedTextSize: e1.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),
                    partiallyEvaluatedIconSize: e1.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(n.sourceID)
                };
                if (r) for (const e1 of n.sortKeyRanges){
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: r } = e1;
                    t1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: r,
                        parameters: E
                    });
                }
                else t1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: n.symbolInstances.length,
                    parameters: E
                });
            }
            attemptAnchorPlacement(e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) {
                const { textOffset0: v, textOffset1: x, crossTileID: y } = u, b = [
                    v,
                    x
                ], w = Mt(e1, i, o, b, r), T = this.collisionIndex.placeCollisionBox(d, r, t1, It(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate);
                if (m) {
                    const e1 = d.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(d, e1, m, It(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) return;
                }
                if (T.box.length > 0) {
                    let t1;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t1 = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = {
                        textOffset: b,
                        width: i,
                        height: o,
                        anchor: e1,
                        textScale: r,
                        prevAnchor: t1
                    }, this.markUsedJustification(d, e1, u, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, u), this.placedOrientations[y] = p), {
                        shift: w,
                        placedGlyphBoxes: T
                    };
                }
            }
            placeLayerBucketPart(t1, i, o, r) {
                const { bucket: n, layout: s, posMatrix: a, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: h, textPixelRatio: u, holdingForFade: _, collisionBoxArray: d, partiallyEvaluatedTextSize: p, partiallyEvaluatedIconSize: m, collisionGroup: f } = t1.parameters, g = s.get("text-optional"), v = s.get("icon-optional"), x = s.get("text-allow-overlap"), y = s.get("icon-allow-overlap"), b = "map" === s.get("text-rotation-alignment"), w = "map" === s.get("text-pitch-alignment"), T = "none" !== s.get("icon-text-fit"), E = "viewport-y" === s.get("symbol-z-order");
                this.transform.setProjection(n.projection);
                let C = x && (y || !n.hasIconData() || v), M = y && (x || !n.hasTextData() || g);
                !n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);
                const I = (t1, r, d)=>{
                    const { crossTileID: E, numVerticalGlyphVertices: I } = t1;
                    if (h) {
                        const o = {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        };
                        let r = null;
                        if (h.dynamicFilterNeedsFeature) {
                            const e1 = this.retainedQueryData[n.bucketInstanceId];
                            r = h.featureIndex.loadFeature({
                                featureIndex: t1.featureIndex,
                                bucketIndex: e1.bucketIndex,
                                sourceLayerIndex: e1.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            });
                        }
                        if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e1.Point(t1.tileAnchorX, t1.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[E] = new wt(!1, !1, !1, !0), void i.add(E);
                    }
                    if (i.has(E)) return;
                    if (_) return void (this.placements[E] = new wt(!1, !1, !1));
                    let P = !1, S = !1, D = !0, L = !1, A = !1, z = null, R = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, O = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, B = null, k = null, F = null, U = 0, N = 0, j = 0;
                    d.textFeatureIndex ? U = d.textFeatureIndex : t1.useRuntimeCollisionCircles && (U = t1.featureIndex), d.verticalTextFeatureIndex && (N = d.verticalTextFeatureIndex);
                    const G = (e1)=>{
                        e1.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;
                        const t1 = this.transform.elevation;
                        (t1 || e1.elevation) && (e1.elevation = t1 ? t1.getAtTileOffset(e1.tileID, e1.tileAnchorX, e1.tileAnchorY) : 0);
                    }, Z = d.textBox;
                    if (Z) {
                        G(Z);
                        const i = (i)=>{
                            let o = e1.WritingMode.horizontal;
                            if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e1 = this.prevPlacement.placedOrientations[E];
                                e1 && (this.placedOrientations[E] = e1, o = e1, this.markUsedOrientation(n, o, t1));
                            }
                            return o;
                        }, o = (t1, i)=>{
                            if (n.allowVerticalPlacement && I > 0 && d.verticalTextBox) {
                                for (const o of n.writingModes)if (o === e1.WritingMode.vertical ? (R = i(), O = R) : R = t1(), R && R.box && R.box.length) break;
                            } else R = t1();
                        };
                        if (s.get("text-variable-anchor")) {
                            let l = s.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[E]) {
                                const e1 = this.prevPlacement.variableOffsets[E];
                                l.indexOf(e1.anchor) > 0 && (l = l.filter((t1)=>t1 !== e1.anchor), l.unshift(e1.anchor));
                            }
                            const c = (e1, i, o)=>{
                                const s = n.getSymbolInstanceTextSize(p, t1, this.transform.zoom, r), c = (e1.x2 - e1.x1) * s + 2 * e1.padding, h = (e1.y2 - e1.y1) * s + 2 * e1.padding, _ = T && !y ? i : null;
                                _ && G(_);
                                let d = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const g = x ? 2 * l.length : l.length;
                                for(let i = 0; i < g; ++i){
                                    const g = this.attemptAnchorPlacement(l[i % l.length], e1, c, h, s, b, w, u, a, f, i >= l.length, t1, r, n, o, _, p, m);
                                    if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {
                                        P = !0, z = g.shift;
                                        break;
                                    }
                                }
                                return d;
                            };
                            o(()=>c(Z, d.iconBox, e1.WritingMode.horizontal), ()=>{
                                const t1 = d.verticalTextBox;
                                return t1 && G(t1), n.allowVerticalPlacement && !(R && R.box && R.box.length) && I > 0 && t1 ? c(t1, d.verticalIconBox, e1.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), R && (P = R.box, D = R.offscreen, L = R.occluded);
                            const h = i(!(!R || !R.box));
                            if (!P && this.prevPlacement) {
                                const e1 = this.prevPlacement.variableOffsets[E];
                                e1 && (this.variableOffsets[E] = e1, this.markUsedJustification(n, e1.anchor, t1, h));
                            }
                        } else {
                            const s = (i, o)=>{
                                const s = n.getSymbolInstanceTextSize(p, t1, this.transform.zoom, r), l = this.collisionIndex.placeCollisionBox(n, s, i, new e1.Point(0, 0), x, u, a, f.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t1), this.placedOrientations[E] = o), l;
                            };
                            o(()=>s(Z, e1.WritingMode.horizontal), ()=>{
                                const t1 = d.verticalTextBox;
                                return n.allowVerticalPlacement && I > 0 && t1 ? (G(t1), s(t1, e1.WritingMode.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i(!!(R && R.box && R.box.length));
                        }
                    }
                    if (B = R, P = B && B.box && B.box.length > 0, D = B && B.offscreen, L = B && B.occluded, t1.useRuntimeCollisionCircles) {
                        const i = n.text.placedSymbolArray.get(t1.centerJustifiedTextSymbolIndex >= 0 ? t1.centerJustifiedTextSymbolIndex : t1.verticalPlacedTextSymbolIndex), r = e1.evaluateSizeForFeature(n.textSizeData, p, i), h = s.get("text-padding");
                        k = this.collisionIndex.placeCollisionCircles(n, x, i, n.lineVertexArray, n.glyphOffsetArray, r, a, l, c, o, w, f.predicate, t1.collisionCircleDiameter * r / e1.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), P = x || k.circles.length > 0 && !k.collisionDetected, D = D && k.offscreen, L = k.occluded;
                    }
                    if (d.iconFeatureIndex && (j = d.iconFeatureIndex), d.iconBox) {
                        const i = (i)=>{
                            G(i);
                            const o = T && z ? It(z.x, z.y, b, w, this.transform.angle) : new e1.Point(0, 0), r = n.getSymbolInstanceIconSize(m, this.transform.zoom, t1.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(n, r, i, o, y, u, a, f.predicate);
                        };
                        O && O.box && O.box.length && d.verticalIconBox ? (F = i(d.verticalIconBox), S = F.box.length > 0) : (F = i(d.iconBox), S = F.box.length > 0), D = D && F.offscreen, A = F.occluded;
                    }
                    const V = g || 0 === t1.numHorizontalGlyphVertices && 0 === I, W = v || 0 === t1.numIconVertices;
                    if (V || W ? W ? V || (S = S && P) : P = S && P : S = P = S && P, P && B && B.box && this.collisionIndex.insertCollisionBox(B.box, s.get("text-ignore-placement"), n.bucketInstanceId, O && O.box && N ? N : U, f.ID), S && F && this.collisionIndex.insertCollisionBox(F.box, s.get("icon-ignore-placement"), n.bucketInstanceId, j, f.ID), k && (P && this.collisionIndex.insertCollisionCircles(k.circles, s.get("text-ignore-placement"), n.bucketInstanceId, U, f.ID), o)) {
                        const e1 = n.bucketInstanceId;
                        let t1 = this.collisionCircleArrays[e1];
                        void 0 === t1 && (t1 = this.collisionCircleArrays[e1] = new Tt);
                        for(let e1 = 0; e1 < k.circles.length; e1 += 4)t1.circles.push(k.circles[e1 + 0]), t1.circles.push(k.circles[e1 + 1]), t1.circles.push(k.circles[e1 + 2]), t1.circles.push(k.collisionDetected ? 1 : 0);
                    }
                    const X = "globe" !== n.projection.name;
                    C = C && (X || !L), M = M && (X || !A), this.placements[E] = new wt(P || C, S || M, D || n.justReloaded), i.add(E);
                };
                if (E) {
                    const e1 = n.getSortedSymbolIndexes(this.transform.angle);
                    for(let t1 = e1.length - 1; t1 >= 0; --t1){
                        const i = e1[t1];
                        I(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                } else for(let e1 = t1.symbolInstanceStart; e1 < t1.symbolInstanceEnd; e1++)I(n.symbolInstances.get(e1), e1, n.collisionArrays[e1]);
                if (o && n.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[n.bucketInstanceId];
                    e1.invert(t1.invProjMatrix, a), t1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                n.justReloaded = !1;
            }
            markUsedJustification(t1, i, o, r) {
                const { leftJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c } = o, h = e1.getAnchorJustification(i), u = r === e1.WritingMode.vertical ? l : "left" === h ? n : "center" === h ? s : "right" === h ? a : -1;
                n >= 0 && (t1.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), s >= 0 && (t1.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c), a >= 0 && (t1.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), l >= 0 && (t1.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);
            }
            markUsedOrientation(t1, i, o) {
                const r = i === e1.WritingMode.horizontal || i === e1.WritingMode.horizontalOnly ? i : 0, n = i === e1.WritingMode.vertical ? i : 0, { leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = o, h = t1.text.placedSymbolArray;
                s >= 0 && (h.get(s).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = n);
            }
            commit(e1) {
                this.commitTime = e1, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t1 ? t1.zoomAdjustment(this.transform.zoom) : 0;
                const o = t1 ? t1.symbolFadeChange(e1) : 1, r = t1 ? t1.opacities : {}, n = t1 ? t1.variableOffsets : {}, s = t1 ? t1.placedOrientations : {};
                for(const e1 in this.placements){
                    const t1 = this.placements[e1], n = r[e1];
                    n ? (this.opacities[e1] = new bt(n, o, t1.text, t1.icon, null, t1.clipped), i = i || t1.text !== n.text.placed || t1.icon !== n.icon.placed) : (this.opacities[e1] = new bt(null, o, t1.text, t1.icon, t1.skipFade, t1.clipped), i = i || t1.text || t1.icon);
                }
                for(const e1 in r){
                    const t1 = r[e1];
                    if (!this.opacities[e1]) {
                        const r = new bt(t1, o, !1, !1);
                        r.isHidden() || (this.opacities[e1] = r, i = i || t1.text.placed || t1.icon.placed);
                    }
                }
                for(const e1 in n)this.variableOffsets[e1] || !this.opacities[e1] || this.opacities[e1].isHidden() || (this.variableOffsets[e1] = n[e1]);
                for(const e1 in s)this.placedOrientations[e1] || !this.opacities[e1] || this.opacities[e1].isHidden() || (this.placedOrientations[e1] = s[e1]);
                i ? this.lastPlacementChangeTime = e1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t1 ? t1.lastPlacementChangeTime : e1);
            }
            updateLayerOpacities(e1, t1) {
                const i = new Set;
                for (const o of t1){
                    const t1 = o.getBucket(e1);
                    t1 && o.latestFeatureIndex && e1.id === t1.layerIds[0] && this.updateBucketOpacities(t1, i, o.collisionBoxArray);
                }
            }
            updateBucketOpacities(t1, i, o) {
                t1.hasTextData() && t1.text.opacityVertexArray.clear(), t1.hasIconData() && t1.icon.opacityVertexArray.clear(), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexArray.clear(), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexArray.clear();
                const r = t1.layers[0].layout, n = !!t1.layers[0].dynamicFilter(), s = new bt(null, 0, !1, !1, !0), a = r.get("text-allow-overlap"), l = r.get("icon-allow-overlap"), c = r.get("text-variable-anchor"), h = "map" === r.get("text-rotation-alignment"), u = "map" === r.get("text-pitch-alignment"), _ = "none" !== r.get("icon-text-fit"), d = new bt(null, 0, a && (l || !t1.hasIconData() || r.get("icon-optional")), l && (a || !t1.hasTextData() || r.get("text-optional")), !0);
                !t1.collisionArrays && o && (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) && t1.deserializeCollisionBoxes(o);
                const p = (e1, t1, i)=>{
                    for(let o = 0; o < t1 / 4; o++)e1.opacityVertexArray.emplaceBack(i);
                };
                let m = 0;
                for(let o = 0; o < t1.symbolInstances.length; o++){
                    const r = t1.symbolInstances.get(o), { numHorizontalGlyphVertices: a, numVerticalGlyphVertices: l, crossTileID: f, numIconVertices: g } = r, v = i.has(f);
                    let x = this.opacities[f];
                    v ? x = s : x || (x = d, this.opacities[f] = x), i.add(f);
                    const y = a > 0 || l > 0, b = g > 0, w = this.placedOrientations[f], T = w === e1.WritingMode.vertical, E = w === e1.WritingMode.horizontal || w === e1.WritingMode.horizontalOnly;
                    if (!y && !b || x.isHidden() || m++, y) {
                        const e1 = kt(x.text);
                        p(t1.text, a, T ? Ft : e1), p(t1.text, l, E ? Ft : e1);
                        const i = x.text.isHidden(), { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: n, rightJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: c } = r, h = t1.text.placedSymbolArray, u = i || T ? 1 : 0;
                        o >= 0 && (h.get(o).hidden = u), n >= 0 && (h.get(n).hidden = u), s >= 0 && (h.get(s).hidden = u), c >= 0 && (h.get(c).hidden = i || E ? 1 : 0);
                        const _ = this.variableOffsets[f];
                        _ && this.markUsedJustification(t1, _.anchor, r, w);
                        const d = this.placedOrientations[f];
                        d && (this.markUsedJustification(t1, "left", r, d), this.markUsedOrientation(t1, d, r));
                    }
                    if (b) {
                        const e1 = kt(x.icon), { placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: o } = r, n = t1.icon.placedSymbolArray, s = x.icon.isHidden() ? 1 : 0;
                        i >= 0 && (p(t1.icon, g, T ? Ft : e1), n.get(i).hidden = s), o >= 0 && (p(t1.icon, r.numVerticalIconVertices, E ? Ft : e1), n.get(o).hidden = s);
                    }
                    if (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) {
                        const i = t1.collisionArrays[o];
                        if (i) {
                            let o = new e1.Point(0, 0), r = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (c) {
                                    const e1 = this.variableOffsets[f];
                                    e1 ? (o = Mt(e1.anchor, e1.width, e1.height, e1.textOffset, e1.textScale), h && o._rotate(u ? this.transform.angle : -this.transform.angle)) : r = !1;
                                }
                                n && (r = !x.clipped), i.textBox && St(t1.textCollisionBox.collisionVertexArray, x.text.placed, !r || T, o.x, o.y), i.verticalTextBox && St(t1.textCollisionBox.collisionVertexArray, x.text.placed, !r || E, o.x, o.y);
                            }
                            const s = r && Boolean(!E && i.verticalIconBox);
                            i.iconBox && St(t1.iconCollisionBox.collisionVertexArray, x.icon.placed, s, _ ? o.x : 0, _ ? o.y : 0), i.verticalIconBox && St(t1.iconCollisionBox.collisionVertexArray, x.icon.placed, !s, _ ? o.x : 0, _ ? o.y : 0);
                        }
                    }
                }
                if (t1.fullyClipped = 0 === m, t1.sortFeatures(this.transform.angle), this.retainedQueryData[t1.bucketInstanceId] && (this.retainedQueryData[t1.bucketInstanceId].featureSortOrder = t1.featureSortOrder), t1.hasTextData() && t1.text.opacityVertexBuffer && t1.text.opacityVertexBuffer.updateData(t1.text.opacityVertexArray), t1.hasIconData() && t1.icon.opacityVertexBuffer && t1.icon.opacityVertexBuffer.updateData(t1.icon.opacityVertexArray), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexBuffer && t1.iconCollisionBox.collisionVertexBuffer.updateData(t1.iconCollisionBox.collisionVertexArray), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexBuffer && t1.textCollisionBox.collisionVertexBuffer.updateData(t1.textCollisionBox.collisionVertexArray), t1.bucketInstanceId in this.collisionCircleArrays) {
                    const e1 = this.collisionCircleArrays[t1.bucketInstanceId];
                    t1.placementInvProjMatrix = e1.invProjMatrix, t1.placementViewportMatrix = e1.viewportMatrix, t1.collisionCircleArray = e1.circles, delete this.collisionCircleArrays[t1.bucketInstanceId];
                }
            }
            symbolFadeChange(e1) {
                return 0 === this.fadeDuration ? 1 : (e1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e1) {
                return Math.max(0, (this.transform.zoom - e1) / 1.5);
            }
            hasTransitions(e1) {
                return this.stale || e1 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e1, t1) {
                const i = this.zoomAtLastRecencyCheck === t1 ? 1 - this.zoomAdjustment(t1) : 1;
                return this.zoomAtLastRecencyCheck = t1, this.commitTime + this.fadeDuration * i > e1;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function St(e1, t1, i, o, r) {
            e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0);
        }
        const Dt = Math.pow(2, 25), Lt = Math.pow(2, 24), At = Math.pow(2, 17), zt = Math.pow(2, 16), Rt = Math.pow(2, 9), Ot = Math.pow(2, 8), Bt = Math.pow(2, 1);
        function kt(e1) {
            if (0 === e1.opacity && !e1.placed) return 0;
            if (1 === e1.opacity && e1.placed) return 4294967295;
            const t1 = e1.placed ? 1 : 0, i = Math.floor(127 * e1.opacity);
            return i * Dt + t1 * Lt + i * At + t1 * zt + i * Rt + t1 * Ot + i * Bt + t1;
        }
        const Ft = 0;
        class Ut {
            constructor(e1){
                this._sortAcrossTiles = "viewport-y" !== e1.layout.get("symbol-z-order") && void 0 !== e1.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = [];
            }
            continuePlacement(e1, t1, i, o, r) {
                const n = this._bucketParts;
                for(; this._currentTileIndex < e1.length;)if (t1.getBucketParts(n, o, e1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e1, t1)=>e1.sortKey - t1.sortKey)); this._currentPartIndex < n.length;){
                    const e1 = n[this._currentPartIndex];
                    if (t1.placeLayerBucketPart(e1, this._seenCrossTileIDs, i, 0 === e1.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
                }
                return !1;
            }
        }
        class Nt {
            constructor(e1, t1, i, o, r, n, s, a){
                this.placement = new Pt(e1, r, n, s, a), this._currentPlacementIndex = t1.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t1, i, o) {
                const r = e1.exported.now(), n = ()=>{
                    const t1 = e1.exported.now() - r;
                    return !this._forceFullPlacement && t1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const e1 = i[t1[this._currentPlacementIndex]], r = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === e1.type && (!e1.minzoom || e1.minzoom <= r) && (!e1.maxzoom || e1.maxzoom > r)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new Ut(e1)), this._inProgressLayer.continuePlacement(o[e1.source], this.placement, this._showCollisionBoxes, e1, n)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(e1) {
                return this.placement.commit(e1), this.placement;
            }
        }
        const jt = 512 / e1.EXTENT / 2;
        class Gt {
            constructor(t1, i, o){
                this.tileID = t1, this.bucketInstanceId = o, this.index = new e1.KDBush(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
                const r = t1.canonical.x * e1.EXTENT, n = t1.canonical.y * e1.EXTENT;
                for(let e1 = 0; e1 < i.length; e1++){
                    const { key: t1, crossTileID: o, tileAnchorX: s, tileAnchorY: a } = i.get(e1), l = Math.floor((r + s) * jt), c = Math.floor((n + a) * jt);
                    this.index.add(l, c), this.keys.push(t1), this.crossTileIDs.push(o);
                }
                this.index.finish();
            }
            findMatches(t1, i, o) {
                const r = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z), n = jt / Math.pow(2, i.canonical.z - this.tileID.canonical.z), s = i.canonical.x * e1.EXTENT, a = i.canonical.y * e1.EXTENT;
                for(let e1 = 0; e1 < t1.length; e1++){
                    const i = t1.get(e1);
                    if (i.crossTileID) continue;
                    const { key: l, tileAnchorX: c, tileAnchorY: h } = i, u = Math.floor((s + c) * n), _ = Math.floor((a + h) * n), d = this.index.range(u - r, _ - r, u + r, _ + r);
                    for (const e1 of d){
                        const t1 = this.crossTileIDs[e1];
                        if (this.keys[e1] === l && !o.has(t1)) {
                            o.add(t1), i.crossTileID = t1;
                            break;
                        }
                    }
                }
            }
        }
        class Zt {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class Vt {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e1) {
                const t1 = Math.round((e1 - this.lng) / 360);
                if (0 !== t1) for(const e1 in this.indexes){
                    const i = this.indexes[e1], o = {};
                    for(const e1 in i){
                        const r = i[e1];
                        r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t1), o[r.tileID.key] = r;
                    }
                    this.indexes[e1] = o;
                }
                this.lng = e1;
            }
            addBucket(e1, t1, i) {
                if (this.indexes[e1.overscaledZ] && this.indexes[e1.overscaledZ][e1.key]) {
                    if (this.indexes[e1.overscaledZ][e1.key].bucketInstanceId === t1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e1.overscaledZ, this.indexes[e1.overscaledZ][e1.key]);
                }
                for(let e1 = 0; e1 < t1.symbolInstances.length; e1++)t1.symbolInstances.get(e1).crossTileID = 0;
                this.usedCrossTileIDs[e1.overscaledZ] || (this.usedCrossTileIDs[e1.overscaledZ] = new Set);
                const o = this.usedCrossTileIDs[e1.overscaledZ];
                for(const i in this.indexes){
                    const r = this.indexes[i];
                    if (Number(i) > e1.overscaledZ) for(const i in r){
                        const n = r[i];
                        n.tileID.isChildOf(e1) && n.findMatches(t1.symbolInstances, e1, o);
                    }
                    else {
                        const n = r[e1.scaledTo(Number(i)).key];
                        n && n.findMatches(t1.symbolInstances, e1, o);
                    }
                }
                for(let e1 = 0; e1 < t1.symbolInstances.length; e1++){
                    const r = t1.symbolInstances.get(e1);
                    r.crossTileID || (r.crossTileID = i.generate(), o.add(r.crossTileID));
                }
                return void 0 === this.indexes[e1.overscaledZ] && (this.indexes[e1.overscaledZ] = {}), this.indexes[e1.overscaledZ][e1.key] = new Gt(e1, t1.symbolInstances, t1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e1, t1) {
                for (const i of t1.crossTileIDs)this.usedCrossTileIDs[e1].delete(i);
            }
            removeStaleBuckets(e1) {
                let t1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const r in o)e1[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t1 = !0);
                }
                return t1;
            }
        }
        class Wt {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new Zt, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e1, t1, i, o) {
                let r = this.layerIndexes[e1.id];
                void 0 === r && (r = this.layerIndexes[e1.id] = new Vt);
                let n = !1;
                const s = {};
                "globe" !== o.name && r.handleWrapJump(i);
                for (const i of t1){
                    const t1 = i.getBucket(e1);
                    t1 && e1.id === t1.layerIds[0] && (t1.bucketInstanceId || (t1.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t1, this.crossTileIDs) && (n = !0), s[t1.bucketInstanceId] = !0);
                }
                return r.removeStaleBuckets(s) && (n = !0), n;
            }
            pruneUnusedLayers(e1) {
                const t1 = {};
                e1.forEach((e1)=>{
                    t1[e1] = !0;
                });
                for(const e1 in this.layerIndexes)t1[e1] || delete this.layerIndexes[e1];
            }
        }
        const Xt = (t1, i)=>e1.emitValidationErrors(t1, i && i.filter((e1)=>"source.canvas" !== e1.identifier)), qt = e1.pick(Ge, [
            "addLayer",
            "removeLayer",
            "setPaintProperty",
            "setLayoutProperty",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setProjection"
        ]), $t = e1.pick(Ge, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), Ht = {
            version: 8,
            layers: [],
            sources: {}
        }, Yt = {
            fill: !0,
            line: !0,
            background: !0,
            hillshade: !0,
            raster: !0
        };
        class Kt extends e1.Evented {
            constructor(t1, i = {}){
                super(), this.map = t1, this.dispatcher = new S(Ue(), this), this.imageManager = new y, this.imageManager.setEventedParent(this), this.glyphManager = new e1.GlyphManager(t1._requestManager, i.localFontFamily ? e1.LocalGlyphMode.all : i.localIdeographFontFamily ? e1.LocalGlyphMode.ideographs : e1.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.crossTileSymbolIndex = new Wt, this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e1.getReferrer());
                const o = this;
                this._rtlTextPluginCallback = Kt.registerForPluginStateChange((t1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t1.pluginStatus,
                        pluginURL: t1.pluginURL
                    }, (t1, i)=>{
                        if (e1.triggerPluginCompletionEvent(t1), i && i.every((e1)=>e1)) for(const e1 in o._sourceCaches){
                            const t1 = o._sourceCaches[e1], i = t1.getSource().type;
                            "vector" !== i && "geojson" !== i || t1.reload();
                        }
                    });
                }), this.on("data", (e1)=>{
                    if ("source" !== e1.dataType || "metadata" !== e1.sourceDataType) return;
                    const t1 = this.getSource(e1.sourceId);
                    if (t1 && t1.vectorLayerIds) for(const e1 in this._layers){
                        const i = this._layers[e1];
                        i.source === t1.id && this._validateLayer(i);
                    }
                });
            }
            loadURL(t1, i = {}) {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" == typeof i.validate ? i.validate : !e1.isMapboxURL(t1);
                t1 = this.map._requestManager.normalizeStyleURL(t1, i.accessToken);
                const r = this.map._requestManager.transformRequest(t1, e1.ResourceType.Style);
                this._request = e1.getJSON(r, (t1, i)=>{
                    this._request = null, t1 ? this.fire(new e1.ErrorEvent(t1)) : i && this._load(i, o);
                });
            }
            loadJSON(t1, i = {}) {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                })), this._request = e1.exported.frame(()=>{
                    this._request = null, this._load(t1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                })), this._load(Ht, !1);
            }
            _updateLayerCount(e1, t1) {
                const i = t1 ? 1 : -1;
                e1.is3D() && (this._num3DLayers += i), "circle" === e1.type && (this._numCircleLayers += i), "symbol" === e1.type && (this._numSymbolLayers += i);
            }
            _load(t1, i) {
                if (i && Xt(this, e1.validateStyle(t1))) return;
                this._loaded = !0, this.stylesheet = e1.clone$1(t1), this._updateMapProjection();
                for(const e1 in t1.sources)this.addSource(e1, t1.sources[e1], {
                    validate: !1
                });
                this._changed = !1, t1.sprite ? this._loadSprite(t1.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t1.glyphs);
                const o = je(this.stylesheet.layers);
                this._order = o.map((e1)=>e1.id), this._layers = {}, this._serializedLayers = {};
                for (const t1 of o){
                    const i = e1.createStyleLayer(t1);
                    i.setEventedParent(this, {
                        layer: {
                            id: i.id
                        }
                    }), this._layers[i.id] = i, this._serializedLayers[i.id] = i.serialize(), this._updateLayerCount(i, !0);
                }
                this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e1.Event("data", {
                    dataType: "style"
                })), this.fire(new e1.Event("style.load"));
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            setProjection(e1) {
                e1 ? this.stylesheet.projection = e1 : delete this.stylesheet.projection, this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
            }
            _updateMapProjection() {
                this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
            }
            _loadSprite(t1) {
                this._spriteRequest = function(t1, i, o) {
                    let r, n, s;
                    const a = e1.exported.devicePixelRatio > 1 ? "@2x" : "";
                    let l = e1.getJSON(i.transformRequest(i.normalizeSpriteURL(t1, a, ".json"), e1.ResourceType.SpriteJSON), (e1, t1)=>{
                        l = null, s || (s = e1, r = t1, h());
                    }), c = e1.getImage(i.transformRequest(i.normalizeSpriteURL(t1, a, ".png"), e1.ResourceType.SpriteImage), (e1, t1)=>{
                        c = null, s || (s = e1, n = t1, h());
                    });
                    function h() {
                        if (s) o(s);
                        else if (r && n) {
                            const t1 = e1.exported.getImageData(n), i = {};
                            for(const o in r){
                                const { width: n, height: s, x: a, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: _, content: d } = r[o], p = new e1.RGBAImage({
                                    width: n,
                                    height: s
                                });
                                e1.RGBAImage.copy(t1, p, {
                                    x: a,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: n,
                                    height: s
                                }), i[o] = {
                                    data: p,
                                    pixelRatio: h,
                                    sdf: c,
                                    stretchX: u,
                                    stretchY: _,
                                    content: d
                                };
                            }
                            o(null, i);
                        }
                    }
                    return {
                        cancel () {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        }
                    };
                }(t1, this.map._requestManager, (t1, i)=>{
                    if (this._spriteRequest = null, t1) this.fire(new e1.ErrorEvent(t1));
                    else if (i) for(const e1 in i)this.imageManager.addImage(e1, i[e1]);
                    this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e1.Event("data", {
                        dataType: "style"
                    }));
                });
            }
            _validateLayer(t1) {
                const i = this.getSource(t1.source);
                if (!i) return;
                const o = t1.sourceLayer;
                o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e1.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t1.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._updatedSources).length) return !1;
                for(const e1 in this._sourceCaches)if (!this._sourceCaches[e1].loaded()) return !1;
                return !!this.imageManager.isLoaded();
            }
            _serializeLayers(e1) {
                const t1 = [];
                for (const i of e1){
                    const e1 = this._layers[i];
                    "custom" !== e1.type && t1.push(e1.serialize());
                }
                return t1;
            }
            hasTransitions() {
                if (this.light && this.light.hasTransition()) return !0;
                if (this.fog && this.fog.hasTransition()) return !0;
                for(const e1 in this._sourceCaches)if (this._sourceCaches[e1].hasTransition()) return !0;
                for(const e1 in this._layers)if (this._layers[e1].hasTransition()) return !0;
                return !1;
            }
            get order() {
                return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
            }
            isLayerDraped(e1) {
                return !!this.terrain && ("function" == typeof e1.isLayerDraped ? e1.isLayerDraped() : Yt[e1.type]);
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            update(t1) {
                if (!this._loaded) return;
                const i = this._changed;
                if (this._changed) {
                    const e1 = Object.keys(this._updatedLayers), i = Object.keys(this._removedLayers);
                    (e1.length || i.length) && this._updateWorkerLayers(e1, i);
                    for(const e1 in this._updatedSources){
                        const t1 = this._updatedSources[e1];
                        "reload" === t1 ? this._reloadSource(e1) : "clear" === t1 && this._clearSource(e1);
                    }
                    this._updateTilesForChangedImages();
                    for(const e1 in this._updatedPaintProps)this._layers[e1].updateTransitions(t1);
                    this.light.updateTransitions(t1), this.fog && this.fog.updateTransitions(t1), this._resetUpdates();
                }
                const o = {};
                for(const e1 in this._sourceCaches){
                    const t1 = this._sourceCaches[e1];
                    o[e1] = t1.used, t1.used = !1;
                }
                for (const e1 of this._order){
                    const i = this._layers[e1];
                    if (i.recalculate(t1, this._availableImages), !i.isHidden(t1.zoom)) {
                        const e1 = this._getLayerSourceCache(i);
                        e1 && (e1.used = !0);
                    }
                    const o = this.map.painter;
                    if (o) {
                        const e1 = i.getProgramIds();
                        if (!e1) continue;
                        const r = i.getProgramConfiguration(t1.zoom);
                        for (const t1 of e1)o.useProgram(t1, r);
                    }
                }
                for(const t1 in o){
                    const i = this._sourceCaches[t1];
                    o[t1] !== i.used && i.getSource().fire(new e1.Event("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light.recalculate(t1), this.terrain && this.terrain.recalculate(t1), this.fog && this.fog.recalculate(t1), this.z = t1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e1.Event("data", {
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const e1 = Object.keys(this._changedImages);
                if (e1.length) {
                    for(const t1 in this._sourceCaches)this._sourceCaches[t1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e1);
                    this._changedImages = {};
                }
            }
            _updateWorkerLayers(e1, t1) {
                this.dispatcher.broadcast("updateLayers", {
                    layers: this._serializeLayers(e1),
                    removedIds: t1
                });
            }
            _resetUpdates() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setState(i) {
                if (this._checkLoaded(), Xt(this, e1.validateStyle(i))) return !1;
                (i = e1.clone$1(i)).layers = je(i.layers);
                const o = (function(e1, i) {
                    if (!e1) return [
                        {
                            command: Ge.setStyle,
                            args: [
                                i
                            ]
                        }
                    ];
                    let o = [];
                    try {
                        if (!t1(e1.version, i.version)) return [
                            {
                                command: Ge.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        t1(e1.center, i.center) || o.push({
                            command: Ge.setCenter,
                            args: [
                                i.center
                            ]
                        }), t1(e1.zoom, i.zoom) || o.push({
                            command: Ge.setZoom,
                            args: [
                                i.zoom
                            ]
                        }), t1(e1.bearing, i.bearing) || o.push({
                            command: Ge.setBearing,
                            args: [
                                i.bearing
                            ]
                        }), t1(e1.pitch, i.pitch) || o.push({
                            command: Ge.setPitch,
                            args: [
                                i.pitch
                            ]
                        }), t1(e1.sprite, i.sprite) || o.push({
                            command: Ge.setSprite,
                            args: [
                                i.sprite
                            ]
                        }), t1(e1.glyphs, i.glyphs) || o.push({
                            command: Ge.setGlyphs,
                            args: [
                                i.glyphs
                            ]
                        }), t1(e1.transition, i.transition) || o.push({
                            command: Ge.setTransition,
                            args: [
                                i.transition
                            ]
                        }), t1(e1.light, i.light) || o.push({
                            command: Ge.setLight,
                            args: [
                                i.light
                            ]
                        }), t1(e1.fog, i.fog) || o.push({
                            command: Ge.setFog,
                            args: [
                                i.fog
                            ]
                        }), t1(e1.projection, i.projection) || o.push({
                            command: Ge.setProjection,
                            args: [
                                i.projection
                            ]
                        });
                        const r = {}, n = [];
                        !function(e1, i, o, r) {
                            let n;
                            for(n in i = i || {}, e1 = e1 || {})e1.hasOwnProperty(n) && (i.hasOwnProperty(n) || Ve(n, o, r));
                            for(n in i){
                                if (!i.hasOwnProperty(n)) continue;
                                const s = i[n];
                                e1.hasOwnProperty(n) ? t1(e1[n], s) || ("geojson" === e1[n].type && "geojson" === s.type && Xe(e1, i, n) ? o.push({
                                    command: Ge.setGeoJSONSourceData,
                                    args: [
                                        n,
                                        s.data
                                    ]
                                }) : We(n, i, o, r)) : Ze(n, i, o);
                            }
                        }(e1.sources, i.sources, n, r);
                        const s = [];
                        e1.layers && e1.layers.forEach((e1)=>{
                            e1.source && r[e1.source] ? o.push({
                                command: Ge.removeLayer,
                                args: [
                                    e1.id
                                ]
                            }) : s.push(e1);
                        });
                        let a = e1.terrain;
                        a && r[a.source] && (o.push({
                            command: Ge.setTerrain,
                            args: [
                                void 0
                            ]
                        }), a = void 0), o = o.concat(n), t1(a, i.terrain) || o.push({
                            command: Ge.setTerrain,
                            args: [
                                i.terrain
                            ]
                        }), function(e1, i, o) {
                            i = i || [];
                            const r = (e1 = e1 || []).map($e), n = i.map($e), s = e1.reduce(He, {}), a = i.reduce(He, {}), l = r.slice(), c = Object.create(null);
                            let h, u, _, d, p, m, f;
                            for(h = 0, u = 0; h < r.length; h++)_ = r[h], a.hasOwnProperty(_) ? u++ : (o.push({
                                command: Ge.removeLayer,
                                args: [
                                    _
                                ]
                            }), l.splice(l.indexOf(_, u), 1));
                            for(h = 0, u = 0; h < n.length; h++)_ = n[n.length - 1 - h], l[l.length - 1 - h] !== _ && (s.hasOwnProperty(_) ? (o.push({
                                command: Ge.removeLayer,
                                args: [
                                    _
                                ]
                            }), l.splice(l.lastIndexOf(_, l.length - u), 1)) : u++, m = l[l.length - h], o.push({
                                command: Ge.addLayer,
                                args: [
                                    a[_],
                                    m
                                ]
                            }), l.splice(l.length - h, 0, _), c[_] = !0);
                            for(h = 0; h < n.length; h++)if (_ = n[h], d = s[_], p = a[_], !c[_] && !t1(d, p)) {
                                if (t1(d.source, p.source) && t1(d["source-layer"], p["source-layer"]) && t1(d.type, p.type)) {
                                    for(f in qe(d.layout, p.layout, o, _, null, Ge.setLayoutProperty), qe(d.paint, p.paint, o, _, null, Ge.setPaintProperty), t1(d.filter, p.filter) || o.push({
                                        command: Ge.setFilter,
                                        args: [
                                            _,
                                            p.filter
                                        ]
                                    }), t1(d.minzoom, p.minzoom) && t1(d.maxzoom, p.maxzoom) || o.push({
                                        command: Ge.setLayerZoomRange,
                                        args: [
                                            _,
                                            p.minzoom,
                                            p.maxzoom
                                        ]
                                    }), d)d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? qe(d[f], p[f], o, _, f.slice(6), Ge.setPaintProperty) : t1(d[f], p[f]) || o.push({
                                        command: Ge.setLayerProperty,
                                        args: [
                                            _,
                                            f,
                                            p[f]
                                        ]
                                    }));
                                    for(f in p)p.hasOwnProperty(f) && !d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? qe(d[f], p[f], o, _, f.slice(6), Ge.setPaintProperty) : t1(d[f], p[f]) || o.push({
                                        command: Ge.setLayerProperty,
                                        args: [
                                            _,
                                            f,
                                            p[f]
                                        ]
                                    }));
                                } else o.push({
                                    command: Ge.removeLayer,
                                    args: [
                                        _
                                    ]
                                }), m = l[l.lastIndexOf(_) + 1], o.push({
                                    command: Ge.addLayer,
                                    args: [
                                        p,
                                        m
                                    ]
                                });
                            }
                        }(s, i.layers, o);
                    } catch (e1) {
                        console.warn("Unable to compute style diff:", e1), o = [
                            {
                                command: Ge.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                    }
                    return o;
                })(this.serialize(), i).filter((e1)=>!(e1.command in $t));
                if (0 === o.length) return !1;
                const r = o.filter((e1)=>!(e1.command in qt));
                if (r.length > 0) throw new Error(`Unimplemented: ${r.map((e1)=>e1.command).join(", ")}.`);
                return o.forEach((e1)=>{
                    "setTransition" !== e1.command && "setProjection" !== e1.command && this[e1.command].apply(this, e1.args);
                }), this.stylesheet = i, this._updateMapProjection(), !0;
            }
            addImage(t1, i) {
                return this.getImage(t1) ? this.fire(new e1.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t1, i), this._afterImageUpdated(t1), this);
            }
            updateImage(e1, t1) {
                this.imageManager.updateImage(e1, t1);
            }
            getImage(e1) {
                return this.imageManager.getImage(e1);
            }
            removeImage(t1) {
                return this.getImage(t1) ? (this.imageManager.removeImage(t1), this._afterImageUpdated(t1), this) : this.fire(new e1.ErrorEvent(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t1) {
                this._availableImages = this.imageManager.listImages(), this._changedImages[t1] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e1.Event("data", {
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            addSource(t1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getSource(t1)) throw new Error("There is already a source with this ID");
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(e1.validateSource, `sources.${t1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const r = De(t1, i, this.dispatcher, this);
                r.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(t1),
                        source: r.serialize(),
                        sourceId: t1
                    }));
                const n = (i)=>{
                    const o = (i ? "symbol:" : "other:") + t1, n = this._sourceCaches[o] = new e1.SourceCache(o, r, i);
                    (i ? this._symbolSourceCaches : this._otherSourceCaches)[t1] = n, n.style = this, n.onAdd(this.map);
                };
                n(!1), "vector" !== i.type && "geojson" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;
            }
            removeSource(t1) {
                this._checkLoaded();
                const i = this.getSource(t1);
                if (!i) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === t1) return this.fire(new e1.ErrorEvent(new Error(`Source "${t1}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.get().source === t1) return this.fire(new e1.ErrorEvent(new Error(`Source "${t1}" cannot be removed while terrain is using it.`)));
                const o = this._getSourceCaches(t1);
                for (const t1 of o)delete this._sourceCaches[t1.id], delete this._updatedSources[t1.id], t1.fire(new e1.Event("data", {
                    sourceDataType: "metadata",
                    dataType: "source",
                    sourceId: t1.getSource().id
                })), t1.setEventedParent(null), t1.clearTiles();
                return delete this._otherSourceCaches[t1], delete this._symbolSourceCaches[t1], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;
            }
            setGeoJSONSourceData(e1, t1) {
                this._checkLoaded(), this.getSource(e1).setData(t1), this._changed = !0;
            }
            getSource(e1) {
                const t1 = this._getSourceCache(e1);
                return t1 && t1.getSource();
            }
            _getSources() {
                const e1 = [];
                for(const t1 in this._otherSourceCaches){
                    const i = this._getSourceCache(t1);
                    i && e1.push(i.getSource());
                }
                return e1;
            }
            addLayer(t1, i, o = {}) {
                this._checkLoaded();
                const r = t1.id;
                if (this.getLayer(r)) return void this.fire(new e1.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
                let n;
                if ("custom" === t1.type) {
                    if (Xt(this, e1.validateCustomStyleLayer(t1))) return;
                    n = e1.createStyleLayer(t1);
                } else {
                    if ("object" == typeof t1.source && (this.addSource(r, t1.source), t1 = e1.clone$1(t1), t1 = e1.extend(t1, {
                        source: r
                    })), this._validate(e1.validateLayer, `layers.${r}`, t1, {
                        arrayIndex: -1
                    }, o)) return;
                    n = e1.createStyleLayer(t1), this._validateLayer(n), n.setEventedParent(this, {
                        layer: {
                            id: r
                        }
                    }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);
                }
                const s = i ? this._order.indexOf(i) : this._order.length;
                if (i && -1 === s) return void this.fire(new e1.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                this._order.splice(s, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;
                const a = this._getLayerSourceCache(n);
                if (this._removedLayers[r] && n.source && a && "custom" !== n.type) {
                    const e1 = this._removedLayers[r];
                    delete this._removedLayers[r], e1.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload", a.pause());
                }
                this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();
            }
            moveLayer(t1, i) {
                if (this._checkLoaded(), this._changed = !0, !this._layers[t1]) return void this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot be moved.`)));
                if (t1 === i) return;
                const o = this._order.indexOf(t1);
                this._order.splice(o, 1);
                const r = i ? this._order.indexOf(i) : this._order.length;
                i && -1 === r ? this.fire(new e1.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r, 0, t1), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
            }
            removeLayer(t1) {
                this._checkLoaded();
                const i = this._layers[t1];
                if (!i) return void this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot be removed.`)));
                i.setEventedParent(null), this._updateLayerCount(i, !1);
                const o = this._order.indexOf(t1);
                this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t1] = i, delete this._layers[t1], delete this._serializedLayers[t1], delete this._updatedLayers[t1], delete this._updatedPaintProps[t1], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();
            }
            getLayer(e1) {
                return this._layers[e1];
            }
            hasLayer(e1) {
                return e1 in this._layers;
            }
            hasLayerType(e1) {
                for(const t1 in this._layers)if (this._layers[t1].type === e1) return !0;
                return !1;
            }
            setLayerZoomRange(t1, i, o) {
                this._checkLoaded();
                const r = this.getLayer(t1);
                r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot have zoom extent.`)));
            }
            setFilter(i, o, r = {}) {
                this._checkLoaded();
                const n = this.getLayer(i);
                if (n) {
                    if (!t1(n.filter, o)) return null == o ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e1.validateFilter, `layers.${n.id}.filter`, o, {
                        layerType: n.type
                    }, r) || (n.filter = e1.clone$1(o), this._updateLayer(n)));
                } else this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));
            }
            getFilter(t1) {
                const i = this.getLayer(t1);
                return i && e1.clone$1(i.filter);
            }
            setLayoutProperty(i, o, r, n = {}) {
                this._checkLoaded();
                const s = this.getLayer(i);
                s ? t1(s.getLayoutProperty(o), r) || (s.setLayoutProperty(o, r, n), this._updateLayer(s)) : this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }
            getLayoutProperty(t1, i) {
                const o = this.getLayer(t1);
                if (o) return o.getLayoutProperty(i);
                this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style.`)));
            }
            setPaintProperty(i, o, r, n = {}) {
                this._checkLoaded();
                const s = this.getLayer(i);
                s ? t1(s.getPaintProperty(o), r) || (s.setPaintProperty(o, r, n) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[i] = !0) : this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }
            getPaintProperty(e1, t1) {
                const i = this.getLayer(e1);
                return i && i.getPaintProperty(t1);
            }
            setFeatureState(t1, i) {
                this._checkLoaded();
                const o = t1.source, r = t1.sourceLayer, n = this.getSource(o);
                if (!n) return void this.fire(new e1.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
                const s = n.type;
                if ("geojson" === s && r) return void this.fire(new e1.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === s && !r) return void this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === t1.id && this.fire(new e1.ErrorEvent(new Error("The feature id parameter must be provided.")));
                const a = this._getSourceCaches(o);
                for (const e1 of a)e1.setFeatureState(r, t1.id, i);
            }
            removeFeatureState(t1, i) {
                this._checkLoaded();
                const o = t1.source, r = this.getSource(o);
                if (!r) return void this.fire(new e1.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
                const n = r.type, s = "vector" === n ? t1.sourceLayer : void 0;
                if ("vector" === n && !s) return void this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t1.id && "number" != typeof t1.id) return void this.fire(new e1.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                const a = this._getSourceCaches(o);
                for (const e1 of a)e1.removeFeatureState(s, t1.id, i);
            }
            getFeatureState(t1) {
                this._checkLoaded();
                const i = t1.source, o = t1.sourceLayer, r = this.getSource(i);
                if (r) {
                    if ("vector" !== r.type || o) return void 0 === t1.id && this.fire(new e1.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i)[0].getFeatureState(o, t1.id);
                    this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                } else this.fire(new e1.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
            }
            getTransition() {
                return e1.extend({
                    duration: 300,
                    delay: 0
                }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
                const t1 = {};
                for(const e1 in this._sourceCaches){
                    const i = this._sourceCaches[e1].getSource();
                    t1[i.id] || (t1[i.id] = i.serialize());
                }
                return e1.filterObject({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: t1,
                    layers: this._serializeLayers(this._order)
                }, (e1)=>void 0 !== e1);
            }
            _updateLayer(e1) {
                this._updatedLayers[e1.id] = !0;
                const t1 = this._getLayerSourceCache(e1);
                e1.source && !this._updatedSources[e1.source] && t1 && "raster" !== t1.getSource().type && (this._updatedSources[e1.source] = "reload", t1.pause()), this._changed = !0, e1.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e1) {
                const t1 = (e1)=>"fill-extrusion" === this._layers[e1].type, i = {}, o = [];
                for(let r = this._order.length - 1; r >= 0; r--){
                    const n = this._order[r];
                    if (t1(n)) {
                        i[n] = r;
                        for (const t1 of e1){
                            const e1 = t1[n];
                            if (e1) for (const t1 of e1)o.push(t1);
                        }
                    }
                }
                o.sort((e1, t1)=>t1.intersectionZ - e1.intersectionZ);
                const r = [];
                for(let n = this._order.length - 1; n >= 0; n--){
                    const s = this._order[n];
                    if (t1(s)) for(let e1 = o.length - 1; e1 >= 0; e1--){
                        const t1 = o[e1].feature;
                        if (i[t1.layer.id] < n) break;
                        r.push(t1), o.pop();
                    }
                    else for (const t1 of e1){
                        const e1 = t1[s];
                        if (e1) for (const t1 of e1)r.push(t1.feature);
                    }
                }
                return r;
            }
            queryRenderedFeatures(t1, i, o) {
                i && i.filter && this._validate(e1.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
                const r = {};
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e1.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                    for (const t1 of i.layers){
                        const i = this._layers[t1];
                        if (!i) return this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        r[i.source] = !0;
                    }
                }
                const n = [];
                i.availableImages = this._availableImages;
                const s = i && i.layers ? i.layers.some((e1)=>{
                    const t1 = this.getLayer(e1);
                    return t1 && t1.is3D();
                }) : this.has3DLayers(), a = L.createFromScreenPoints(t1, o);
                for(const e1 in this._sourceCaches){
                    const t1 = this._sourceCaches[e1].getSource().id;
                    i.layers && !r[t1] || n.push(Ae(this._sourceCaches[e1], this._layers, this._serializedLayers, a, i, o, s, !!this.map._showQueryGeometry));
                }
                return this.placement && n.push(function(e1, t1, i, o, r, n, s) {
                    const a = {}, l = n.queryRenderedSymbols(o), c = [];
                    for (const e1 of Object.keys(l).map(Number))c.push(s[e1]);
                    c.sort(Re);
                    for (const i of c){
                        const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t1, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e1);
                        for(const e1 in o){
                            const t1 = a[e1] = a[e1] || [], r = o[e1];
                            r.sort((e1, t1)=>{
                                const o = i.featureSortOrder;
                                if (o) {
                                    const i = o.indexOf(e1.featureIndex);
                                    return o.indexOf(t1.featureIndex) - i;
                                }
                                return t1.featureIndex - e1.featureIndex;
                            });
                            for (const e1 of r)t1.push(e1);
                        }
                    }
                    for(const t1 in a)a[t1].forEach((o)=>{
                        const r = o.feature, n = i(e1[t1]);
                        if (!n) return;
                        const s = n.getFeatureState(r.layer["source-layer"], r.id);
                        r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = s;
                    });
                    return a;
                }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);
            }
            querySourceFeatures(t1, i) {
                i && i.filter && this._validate(e1.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
                const o = this._getSourceCaches(t1);
                let r = [];
                for (const e1 of o)r = r.concat(ze(e1, i));
                return r;
            }
            addSourceType(e1, t1, i) {
                return Kt.getSourceType(e1) ? i(new Error(`A source type called "${e1}" already exists.`)) : (Kt.setSourceType(e1, t1), t1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e1,
                    url: t1.workerSourceURL
                }, i) : i(null, null));
            }
            getLight() {
                return this.light.getLight();
            }
            setLight(e1, i = {}) {
                this._checkLoaded();
                const o = this.light.getLight();
                let r = !1;
                for(const i in e1)if (!t1(e1[i], o[i])) {
                    r = !0;
                    break;
                }
                if (!r) return;
                const n = this._setTransitionParameters({
                    duration: 300,
                    delay: 0
                });
                this.light.setLight(e1, i), this.light.updateTransitions(n);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            setTerrain(i, o = 1) {
                if (this._checkLoaded(), !i) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                let r = i;
                if (1 === o) {
                    if ("object" == typeof r.source) {
                        const t1 = "terrain-dem-src";
                        this.addSource(t1, r.source), r = e1.clone$1(r), r = e1.extend(r, {
                            source: t1
                        });
                    }
                    if (this._validate(e1.validateTerrain, "terrain", r)) return;
                }
                if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) {
                    if (!r) return;
                    this._createTerrain(r, o);
                } else {
                    const i = this.terrain, o = i.get();
                    for (const t1 of Object.keys(e1.spec.terrain))!r.hasOwnProperty(t1) && e1.spec.terrain[t1].default && (r[t1] = e1.spec.terrain[t1].default);
                    for(const e1 in r)if (!t1(r[e1], o[e1])) {
                        i.set(r), this.stylesheet.terrain = r;
                        const e1 = this._setTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e1);
                        break;
                    }
                }
                this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e1) {
                const t1 = this.fog = new P(e1, this.map.transform);
                this.stylesheet.fog = e1;
                const i = this._setTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e1 of this.map._markers)e1._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(e1) {
                if (this._checkLoaded(), !e1) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog, o = i.get();
                    0 === Object.keys(e1).length && i.set(e1);
                    for(const r in e1)if (!t1(e1[r], o[r])) {
                        i.set(e1), this.stylesheet.fog = e1;
                        const t1 = this._setTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(t1);
                        break;
                    }
                } else this._createFog(e1);
                this._markersNeedUpdate = !0;
            }
            _setTransitionParameters(t1) {
                return {
                    now: e1.exported.now(),
                    transition: e1.extend(t1, this.stylesheet.transition)
                };
            }
            _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;
                const e1 = this._order.filter((e1)=>this.isLayerDraped(this._layers[e1])), t1 = this._order.filter((e1)=>!this.isLayerDraped(this._layers[e1]));
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e1), this._drapedFirstOrder.push(...t1);
            }
            _createTerrain(e1, t1) {
                const i = this.terrain = new E(e1, t1);
                this.stylesheet.terrain = e1, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
                const o = this._setTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(o);
            }
            _force3DLayerUpdate() {
                for(const e1 in this._layers){
                    const t1 = this._layers[e1];
                    "fill-extrusion" === t1.type && this._updateLayer(t1);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e1 in this._layers){
                    const t1 = this._layers[e1];
                    "symbol" === t1.type && this._updateLayer(t1);
                }
            }
            _validate(t1, i, o, r, n = {}) {
                return (!n || !1 !== n.validate) && Xt(this, t1.call(e1.validateStyle, e1.extend({
                    key: i,
                    style: this.serialize(),
                    value: o,
                    styleSpec: e1.spec
                }, r)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e1.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e1 in this._layers)this._layers[e1].setEventedParent(null);
                for(const e1 in this._sourceCaches)this._sourceCaches[e1].clearTiles(), this._sourceCaches[e1].setEventedParent(null);
                this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(e1) {
                const t1 = this._getSourceCaches(e1);
                for (const e1 of t1)e1.clearTiles();
            }
            _reloadSource(e1) {
                const t1 = this._getSourceCaches(e1);
                for (const e1 of t1)e1.resume(), e1.reload();
            }
            _reloadSources() {
                for (const e1 of this._getSources())e1.reload && e1.reload();
            }
            _updateSources(e1) {
                for(const t1 in this._sourceCaches)this._sourceCaches[t1].update(e1);
            }
            _generateCollisionBoxes() {
                for(const e1 in this._sourceCaches){
                    const t1 = this._sourceCaches[e1];
                    t1.resume(), t1.reload();
                }
            }
            _updatePlacement(t1, i, o, r, n = !1) {
                let s = !1, a = !1;
                const l = {};
                for (const e1 of this._order){
                    const i = this._layers[e1];
                    if ("symbol" !== i.type) continue;
                    if (!l[i.source]) {
                        const e1 = this._getLayerSourceCache(i);
                        if (!e1) continue;
                        l[i.source] = e1.getRenderableIds(!0).map((t1)=>e1.getTileByID(t1)).sort((e1, t1)=>t1.tileID.overscaledZ - e1.tileID.overscaledZ || (e1.tileID.isLessThan(t1.tileID) ? -1 : 1));
                    }
                    const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t1.center.lng, t1.projection);
                    s = s || o;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e1.Event("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e1.exported.now(), t1.zoom)) && (this.pauseablePlacement = new Nt(t1, this._order, n, i, o, r, this.placement, this.fog && t1.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e1.exported.now()), a = !0), s && this.pauseablePlacement.placement.setStale()), a || s) for (const e1 of this._order){
                    const t1 = this._layers[e1];
                    "symbol" === t1.type && this.placement.updateLayerOpacities(t1, l[t1.source]);
                }
                return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e1.exported.now());
            }
            _releaseSymbolFadeTiles() {
                for(const e1 in this._sourceCaches)this._sourceCaches[e1].releaseSymbolFadeTiles();
            }
            getImages(e1, t1, i) {
                this.imageManager.getImages(t1.icons, i), this._updateTilesForChangedImages();
                const o = (e1)=>{
                    e1 && e1.setDependencies(t1.tileID.key, t1.type, t1.icons);
                };
                o(this._otherSourceCaches[t1.source]), o(this._symbolSourceCaches[t1.source]);
            }
            getGlyphs(e1, t1, i) {
                this.glyphManager.getGlyphs(t1.stacks, i);
            }
            getResource(t1, i, o) {
                return e1.makeRequest(i, o);
            }
            _getSourceCache(e1) {
                return this._otherSourceCaches[e1];
            }
            _getLayerSourceCache(e1) {
                return "symbol" === e1.type ? this._symbolSourceCaches[e1.source] : this._otherSourceCaches[e1.source];
            }
            _getSourceCaches(e1) {
                const t1 = [];
                return this._otherSourceCaches[e1] && t1.push(this._otherSourceCaches[e1]), this._symbolSourceCaches[e1] && t1.push(this._symbolSourceCaches[e1]), t1;
            }
            _isSourceCacheLoaded(t1) {
                const i = this._getSourceCaches(t1);
                return 0 === i.length ? (this.fire(new e1.ErrorEvent(new Error(`There is no source with ID '${t1}'`))), !1) : i.every((e1)=>e1.loaded());
            }
            has3DLayers() {
                return this._num3DLayers > 0;
            }
            hasSymbolLayers() {
                return this._numSymbolLayers > 0;
            }
            hasCircleLayers() {
                return this._numCircleLayers > 0;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        Kt.getSourceType = function(e1) {
            return Se[e1];
        }, Kt.setSourceType = function(e1, t1) {
            Se[e1] = t1;
        }, Kt.registerForPluginStateChange = e1.registerForPluginStateChange;
        var Jt = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", Qt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ei = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", ti = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ii = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let oi = {}, ri = {};
        const ni = [];
        hi(Jt, ni), hi(ei, ni), hi(ti, ni), hi(ii, ni), oi = ui("", ei), ri = ui(ii, ti);
        const si = ui("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ai = Jt, li = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var ci = {
            background: ui("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            backgroundPattern: ui("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            circle: ui("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
            clippingMask: ui("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: ui("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            heatmapTexture: ui("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: ui("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
            collisionCircle: ui("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: ui("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
            fill: ui("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutline: ui("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutlinePattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillPattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillExtrusion: ui("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            fillExtrusionPattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
            hillshadePrepare: ui("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: ui("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            line: ui("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            linePattern: ui("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            raster: ui("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            symbolIcon: ui("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
            symbolSDF: ui("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
            symbolTextAndIcon: ui("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
            terrainRaster: ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
            terrainDepth: ui("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            skybox: ui("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Qt),
            skyboxGradient: ui("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Qt),
            skyboxCapture: ui("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
            globeAtmosphere: ui("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")
        };
        function hi(e1, t1) {
            const i = e1.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e1 of i)if (e1 = e1.trim(), "#" === e1[0] && e1.includes("if") && !e1.includes("endif")) {
                e1 = e1.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i = e1.split(" ");
                for (const e1 of i)t1.includes(e1) || t1.push(e1);
            }
        }
        function ui(e1, t1) {
            const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = t1.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r = {}, n = [
                ...ni
            ];
            return hi(e1, n), hi(t1, n), {
                fragmentSource: e1 = e1.replace(i, (e1, t1, i, o, n)=>(r[n] = !0, "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${n}\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = u_${n};\n#endif\n`)),
                vertexSource: t1 = t1.replace(i, (e1, t1, i, o, n)=>{
                    const s = "float" === o ? "vec2" : "vec4", a = n.match(/color/) ? "color" : s;
                    return r[n] ? "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`;
                }),
                staticAttributes: o,
                usedDefines: n
            };
        }
        class _i {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e1, t1, i, o, r, n, s) {
                this.context = e1;
                let a = this.boundPaintVertexBuffers.length !== o.length;
                for(let e1 = 0; !a && e1 < o.length; e1++)this.boundPaintVertexBuffers[e1] !== o[e1] && (a = !0);
                let l = this.boundDynamicVertexBuffers.length !== s.length;
                for(let e1 = 0; !l && e1 < s.length; e1++)this.boundDynamicVertexBuffers[e1] !== s[e1] && (l = !0);
                if (!e1.extVertexArrayObject || !this.vao || this.boundProgram !== t1 || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== n) this.freshBind(t1, i, o, r, n, s);
                else {
                    e1.bindVertexArrayOES.set(this.vao);
                    for (const e1 of s)e1 && e1.bind();
                    r && r.dynamicDraw && r.bind();
                }
            }
            freshBind(e1, t1, i, o, r, n) {
                let s;
                const a = e1.numAttributes, l = this.context, c = l.gl;
                if (l.extVertexArrayObject) this.vao && this.destroy(), this.vao = l.extVertexArrayObject.createVertexArrayOES(), l.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e1, this.boundLayoutVertexBuffer = t1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n;
                else {
                    s = l.currentNumAttributes || 0;
                    for(let e1 = a; e1 < s; e1++)c.disableVertexAttribArray(e1);
                }
                t1.enableAttributes(c, e1), t1.bind(), t1.setVertexAttribPointers(c, e1, r);
                for (const t1 of i)t1.enableAttributes(c, e1), t1.bind(), t1.setVertexAttribPointers(c, e1, r);
                for (const t1 of n)t1 && (t1.enableAttributes(c, e1), t1.bind(), t1.setVertexAttribPointers(c, e1, r));
                o && o.bind(), l.currentNumAttributes = a;
            }
            destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
        }
        function di(t1, i) {
            const o = Math.pow(2, i.canonical.z), r = i.canonical.y;
            return [
                new e1.MercatorCoordinate(0, r / o).toLngLat().lat,
                new e1.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat
            ];
        }
        function pi(t1, i, o, r, n, s, a) {
            const l = t1.context, c = l.gl, h = o.fbo;
            if (!h) return;
            t1.prepareDrawTile();
            const u = t1.useProgram("hillshade");
            l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
            const _ = ((e1, t1, i, o)=>{
                const r = i.paint.get("hillshade-shadow-color"), n = i.paint.get("hillshade-highlight-color"), s = i.paint.get("hillshade-accent-color");
                let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= e1.transform.angle);
                const l = !e1.options.moving;
                return {
                    u_matrix: o || e1.transform.calculateProjMatrix(t1.tileID.toUnwrapped(), l),
                    u_image: 0,
                    u_latrange: di(0, t1.tileID),
                    u_light: [
                        i.paint.get("hillshade-exaggeration"),
                        a
                    ],
                    u_shadow: r,
                    u_highlight: n,
                    u_accent: s
                };
            })(t1, o, r, t1.terrain ? i.projMatrix : null);
            t1.prepareDrawProgram(l, u, i.toUnwrapped());
            const { tileBoundsBuffer: d, tileBoundsIndexBuffer: p, tileBoundsSegments: m } = t1.getTileBoundsBuffers(o);
            u.draw(l, c.TRIANGLES, n, s, a, e1.CullFaceMode.disabled, _, r.id, d, p, m);
        }
        function mi(t1, i, o) {
            if (!i.needsDEMTextureUpload) return;
            const r = t1.context, n = r.gl;
            r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t1.getTileTexture(o.stride);
            const s = o.getPixels();
            i.demTexture ? i.demTexture.update(s, {
                premultiply: !1
            }) : i.demTexture = new e1.Texture(r, s, n.RGBA, {
                premultiply: !1
            }), i.needsDEMTextureUpload = !1;
        }
        function fi(t1, i, o, r, n, s) {
            const a = t1.context, l = a.gl;
            if (!i.dem) return;
            const c = i.dem;
            if (a.activeTexture.set(l.TEXTURE1), mi(t1, i, c), !i.demTexture) return;
            i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
            const h = c.dim;
            a.activeTexture.set(l.TEXTURE0);
            let u = i.fbo;
            if (!u) {
                const t1 = new e1.Texture(a, {
                    width: h,
                    height: h,
                    data: null
                }, l.RGBA);
                t1.bind(l.LINEAR, l.CLAMP_TO_EDGE), u = i.fbo = a.createFramebuffer(h, h, !0), u.colorAttachment.set(t1.texture);
            }
            a.bindFramebuffer.set(u.framebuffer), a.viewport.set([
                0,
                0,
                h,
                h
            ]);
            const { tileBoundsBuffer: _, tileBoundsIndexBuffer: d, tileBoundsSegments: p } = t1.getMercatorTileBoundsBuffers();
            t1.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, r, n, s, e1.CullFaceMode.disabled, ((t1, i)=>{
                const o = i.stride, r = e1.create();
                return e1.ortho(r, 0, e1.EXTENT, -e1.EXTENT, 0, 0, 1), e1.translate(r, r, [
                    0,
                    -e1.EXTENT,
                    0
                ]), {
                    u_matrix: r,
                    u_image: 1,
                    u_dimension: [
                        o,
                        o
                    ],
                    u_zoom: t1.overscaledZ,
                    u_unpack: i.unpackVector
                };
            })(i.tileID, c), o.id, _, d, p), i.needsHillshadePrepare = !1;
        }
        const gi = (t1)=>({
                u_matrix: new e1.UniformMatrix4f(t1),
                u_image0: new e1.Uniform1i(t1),
                u_skirt_height: new e1.Uniform1f(t1)
            }), vi = (e1, t1)=>({
                u_matrix: e1,
                u_image0: 0,
                u_skirt_height: t1
            }), xi = (e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p)=>({
                u_proj_matrix: Float32Array.from(e1),
                u_globe_matrix: t1,
                u_normalize_matrix: Float32Array.from(o),
                u_merc_matrix: i,
                u_zoom_transition: r,
                u_merc_center: n,
                u_image0: 0,
                u_frustum_tl: s,
                u_frustum_tr: a,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: u,
                u_viewport: _,
                u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9),
                u_skirt_height: d
            });
        function yi(e1, t1) {
            return null != e1 && null != t1 && !(!e1.hasData() || !t1.hasData()) && null != e1.demTexture && null != t1.demTexture && e1.tileID.key !== t1.tileID.key;
        }
        const bi = new class {
            constructor(){
                this.operations = {};
            }
            newMorphing(e1, t1, i, o, r) {
                if (e1 in this.operations) {
                    const t1 = this.operations[e1];
                    t1.to.tileID.key !== i.tileID.key && (t1.queued = i);
                } else this.operations[e1] = {
                    startTime: o,
                    phase: 0,
                    duration: r,
                    from: t1,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e1) {
                if (!(e1 in this.operations)) return null;
                const t1 = this.operations[e1];
                return {
                    from: t1.from,
                    to: t1.to,
                    phase: t1.phase
                };
            }
            update(e1) {
                for(const t1 in this.operations){
                    const i = this.operations[t1];
                    for(i.phase = (e1 - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);)if (!this._nextOp(i, e1)) {
                        delete this.operations[t1];
                        break;
                    }
                }
            }
            _nextOp(e1, t1) {
                return !!e1.queued && (e1.from = e1.to, e1.to = e1.queued, e1.queued = null, e1.phase = 0, e1.startTime = t1, !0);
            }
            _validOp(e1) {
                return e1.from.hasData() && e1.to.hasData();
            }
        }, wi = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING",
            2: "TERRAIN_WIREFRAME"
        };
        function Ti(e1) {
            return 6 * Math.pow(1.5, 22 - e1);
        }
        function Ei(e1, t1) {
            const i = 1 << e1.z;
            return !t1 && (0 === e1.x || e1.x === i - 1) || 0 === e1.y || e1.y === i - 1;
        }
        const Ci = (e1)=>({
                u_matrix: e1
            });
        function Mi(t1, i, o, r, n) {
            if (n > 0) {
                const s = e1.exported.now(), a = (s - t1.timeAdded) / n, l = i ? (s - i.timeAdded) / n : -1, c = o.getSource(), h = r.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t1.tileID.overscaledZ - h), _ = u && t1.refreshedUponExpiration ? 1 : e1.clamp(u ? a : 1 - l, 0, 1);
                return t1.refreshedUponExpiration && a >= 1 && (t1.refreshedUponExpiration = !1), i ? {
                    opacity: 1,
                    mix: 1 - _
                } : {
                    opacity: _,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        class Ii extends e1.SourceCache {
            constructor(e1){
                const t1 = {
                    type: "raster-dem",
                    maxzoom: e1.transform.maxZoom
                }, i = new S(Ue(), null), o = De("mock-dem", t1, i, e1.style);
                super("mock-dem", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e1, t1) {
                e1.state = "loaded", t1(null);
            }
        }
        class Pi extends e1.SourceCache {
            constructor(e1){
                const t1 = De("proxy", {
                    type: "geojson",
                    maxzoom: e1.transform.maxZoom
                }, new S(Ue(), null), e1.style);
                super("proxy", t1, !1), t1.setEventedParent(this), this.map = this.getSource().map = e1, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(t1, i, o) {
                if (t1.freezeTileCoverage) return;
                this.transform = t1;
                const r = t1.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((i, o)=>{
                    if (i[o.key] = "", !this._tiles[o.key]) {
                        const i = new e1.Tile(o, this._source.tileSize * o.overscaleFactor(), t1.tileZoom);
                        i.state = "loaded", this._tiles[o.key] = i;
                    }
                    return i;
                }, {});
                for(const e1 in this._tiles)e1 in r || (this.freeFBO(e1), this._tiles[e1].unloadVectorData(), delete this._tiles[e1]);
            }
            freeFBO(e1) {
                const t1 = this.proxyCachedFBO[e1];
                if (void 0 !== t1) {
                    const i = Object.values(t1);
                    this.renderCachePool.push(...i), delete this.proxyCachedFBO[e1];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e1)=>e1.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }
        class Si extends e1.OverscaledTileID {
            constructor(e1, t1, i){
                super(e1.overscaledZ, e1.wrap, e1.canonical.z, e1.canonical.x, e1.canonical.y), this.proxyTileKey = t1, this.projMatrix = i;
            }
        }
        class Di extends e1.Elevation {
            constructor(t1, i){
                super(), this.painter = t1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                const [o, r, n] = function(t1) {
                    const i = new e1.StructArrayLayout2i4, o = new e1.StructArrayLayout3ui6, r = 131;
                    i.reserve(17161), o.reserve(33800);
                    const n = e1.EXTENT / 128, s = e1.EXTENT + n / 2, a = s + n;
                    for(let t1 = -n; t1 < a; t1 += n)for(let o = -n; o < a; o += n){
                        const r = o < 0 || o > s || t1 < 0 || t1 > s ? 24575 : 0, n = e1.clamp(Math.round(o), 0, e1.EXTENT), a = e1.clamp(Math.round(t1), 0, e1.EXTENT);
                        i.emplaceBack(n + r, a);
                    }
                    const l = (e1, t1)=>{
                        const i = t1 * r + e1;
                        o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
                    };
                    for(let e1 = 1; e1 < 129; e1++)for(let t1 = 1; t1 < 129; t1++)l(t1, e1);
                    return [
                        0,
                        129
                    ].forEach((e1)=>{
                        for(let t1 = 0; t1 < 130; t1++)l(t1, e1), l(e1, t1);
                    }), [
                        i,
                        o,
                        32768
                    ];
                }(), s = t1.context;
                this.gridBuffer = s.createVertexBuffer(o, e1.posAttributes.members), this.gridIndexBuffer = s.createIndexBuffer(r), this.gridSegments = e1.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e1.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Pi(i.map), this.orthoMatrix = e1.create(), e1.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e1.EXTENT, 0, e1.EXTENT, 0, 1);
                const a = s.gl;
                this._overlapStencilMode = new e1.StencilMode({
                    func: a.GEQUAL,
                    mask: 255
                }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Ii(i.map);
            }
            set style(e1) {
                e1.on("data", this._onStyleDataEvent.bind(this)), e1.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e1, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", ()=>{
                    this._clearLineLayersFromRenderCache();
                });
            }
            update(t1, i, o) {
                if (t1 && t1.terrain) {
                    this._style !== t1 && (this.style = t1), this.enabled = !0;
                    const r = t1.terrain.properties;
                    this.sourceCache = 0 === t1.terrain.drapeRenderMode ? this._mockSourceCache : t1._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");
                    const n = ()=>{
                        this.sourceCache.used && e1.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t1 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t1, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;
                } else this._disable();
            }
            resetTileLookupCache(e1) {
                this._findCoveringTileCache[e1] = {};
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _checkRenderCacheEfficiency() {
                const t1 = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain || 100 !== t1.efficiency && e1.warnOnce(`Terrain render cache efficiency is not optimal (${t1.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t1.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }
            _onStyleDataEvent(e1) {
                e1.coord && "source" === e1.dataType ? this._clearRenderCacheForTile(e1.sourceCacheId, e1.coord) : "style" === e1.dataType && (this._invalidateRenderCache = !0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e1 in this._style._sourceCaches)this._style._sourceCaches[e1].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e1)=>e1.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this._exaggeration;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e1 = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e1,
                    e1
                ];
            }
            set useVertexMorphing(e1) {
                this._useVertexMorphing = e1;
            }
            updateTileBinding(t1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache, o = this.painter.transform;
                this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e1.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const r = this.proxyCoords = i.getIds().map((e1)=>{
                    const t1 = i.getTileByID(e1).tileID;
                    return t1.projMatrix = o.calculateProjMatrix(t1.toUnwrapped()), t1;
                });
                !function(t1, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()), r = new e1.Point(o.x, o.y);
                    t1.sort((t1, i)=>{
                        if (i.overscaledZ - t1.overscaledZ) return i.overscaledZ - t1.overscaledZ;
                        const o = new e1.Point(t1.canonical.x + (1 << t1.canonical.z) * t1.wrap, t1.canonical.y), n = new e1.Point(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y), s = r.mult(1 << t1.canonical.z);
                        return s.x -= .5, s.y -= .5, s.distSqr(o) - s.distSqr(n);
                    });
                }(r, this.painter), this._previousZoom = o.zoom;
                const n = this.proxyToSource || {};
                this.proxyToSource = {}, r.forEach((e1)=>{
                    this.proxyToSource[e1.key] = {};
                }), this.terrainTileForTile = {};
                const s = this._style._sourceCaches;
                for(const e1 in s){
                    const i = s[e1];
                    if (!i.used) continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t1[e1], n), i.usedForTerrain) continue;
                    const o = t1[e1];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }
                this.proxiedCoords[i.id] = r.map((e1)=>new Si(e1, e1.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e1.exported.now();
                const a = {};
                this._visibleDemTiles = [];
                for (const e1 of this.proxyCoords){
                    const t1 = this.terrainTileForTile[e1.key];
                    if (!t1) continue;
                    const i = t1.tileID.key;
                    i in a || (this._visibleDemTiles.push(t1), a[i] = i);
                }
            }
            _assignTerrainTiles(e1) {
                this._initializing || e1.forEach((e1)=>{
                    if (this.terrainTileForTile[e1.key]) return;
                    const t1 = this._findTileCoveringTileID(e1, this.sourceCache);
                    t1 && (this.terrainTileForTile[e1.key] = t1);
                });
            }
            _prepareDEMTextures() {
                const e1 = this.painter.context, t1 = e1.gl;
                for(const i in this.terrainTileForTile){
                    const o = this.terrainTileForTile[i], r = o.dem;
                    !r || o.demTexture && !o.needsDEMTextureUpload || (e1.activeTexture.set(t1.TEXTURE1), mi(this.painter, o, r));
                }
            }
            _prepareDemTileUniforms(e1, t1, i, o) {
                if (!t1 || null == t1.demTexture) return !1;
                const r = e1.tileID.canonical, n = Math.pow(2, t1.tileID.canonical.z - r.z), s = o || "";
                return i[`u_dem_tl${s}`] = [
                    r.x * n % 1,
                    r.y * n % 1
                ], i[`u_dem_scale${s}`] = n, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            get emptyDepthBufferTexture() {
                const t1 = this.painter.context, i = t1.gl;
                if (!this._emptyDepthBufferTexture) {
                    const o = new e1.RGBAImage({
                        width: 1,
                        height: 1
                    }, Uint8Array.of(255, 255, 255, 255));
                    this._emptyDepthBufferTexture = new e1.Texture(t1, o, i.RGBA, {
                        premultiply: !1
                    });
                }
                return this._emptyDepthBufferTexture;
            }
            _getLoadedAreaMinimum() {
                let e1 = 0;
                const t1 = this._visibleDemTiles.reduce((t1, i)=>{
                    if (!i.dem) return t1;
                    const o = i.dem.tree.minimums[0];
                    return o > 0 && e1++, t1 + o;
                }, 0);
                return e1 ? t1 / e1 : 0;
            }
            _updateEmptyDEMTexture() {
                const t1 = this.painter.context, i = t1.gl;
                t1.activeTexture.set(i.TEXTURE2);
                const o = this._getLoadedAreaMinimum(), r = new e1.RGBAImage({
                    width: 1,
                    height: 1
                }, new Uint8Array(e1.DEMData.pack(o, this.sourceCache.getSource().encoding)));
                this._emptyDEMTextureDirty = !1;
                let n = this._emptyDEMTexture;
                return n ? n.update(r, {
                    premultiply: !1
                }) : n = this._emptyDEMTexture = new e1.Texture(t1, r, i.RGBA, {
                    premultiply: !1
                }), n;
            }
            setupElevationDraw(t1, i, o) {
                const r = this.painter.context, n = r.gl, s = (a = this.sourceCache.getSource().encoding, {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_unpack: e1.DEMData.getUnpackVector(a),
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_exaggeration: 0
                });
                var a;
                s.u_dem_size = this.sourceCache.getSource().tileSize, s.u_exaggeration = this.exaggeration();
                let l = null, c = null, h = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e1 = o.morphing.srcDemTile, i = o.morphing.dstDemTile;
                    h = o.morphing.phase, e1 && i && (this._prepareDemTileUniforms(t1, e1, s, "_prev") && (c = e1), this._prepareDemTileUniforms(t1, i, s) && (l = i));
                }
                if (c && l ? (r.activeTexture.set(n.TEXTURE2), l.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), c.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), s.u_dem_lerp = h) : (l = this.terrainTileForTile[t1.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t1, l, s) ? l.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [
                    1 / this._depthFBO.width,
                    1 / this._depthFBO.height
                ])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), s.u_depth_size_inv = [
                    1,
                    1
                ]), o && o.useMeterToDem && l) {
                    const t1 = (1 << l.tileID.canonical.z) * e1.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    s.u_meter_to_dem = t1;
                }
                if (o && o.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, s), "globe" === this.painter.transform.projection.name) {
                    const e1 = this.globeUniformValues(this.painter.transform, t1.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(r, e1);
                }
            }
            globeUniformValues(t1, i, o) {
                const r = t1.projection;
                return {
                    u_tile_tl_up: r.upVector(i, 0, 0),
                    u_tile_tr_up: r.upVector(i, e1.EXTENT, 0),
                    u_tile_br_up: r.upVector(i, e1.EXTENT, e1.EXTENT),
                    u_tile_bl_up: r.upVector(i, 0, e1.EXTENT),
                    u_tile_up_scale: o ? e1.globeMetersToEcef(1) : r.upVectorScale(i, t1.center.lat, t1.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t1) {
                const i = this.painter, o = this.painter.context;
                0 !== t1.length && (o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t1, i, o, r, n) {
                    if ("globe" === t1.transform.projection.name) !function(t1, i, o, r, n) {
                        const s = t1.context, a = s.gl;
                        let l, c;
                        const h = t1.options.showTerrainWireframe ? 2 : 0, u = t1.transform, _ = e1.globeUseCustomAntiAliasing(t1, s, u), d = (e1, i)=>{
                            if (c === e1) return;
                            const o = [
                                wi[e1],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _ && o.push("CUSTOM_ANTIALIASING"), i && o.push(wi[h]), l = t1.useProgram("globeRaster", null, o), c = e1;
                        }, p = t1.colorModeForRenderPass(), m = new e1.DepthMode(a.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                        bi.update(n);
                        const f = e1.calculateGlobeMercatorMatrix(u), g = [
                            e1.mercatorXfromLng(u.center.lng),
                            e1.mercatorYfromLat(u.center.lat)
                        ], v = h ? [
                            !1,
                            !0
                        ] : [
                            !1
                        ], x = t1.globeSharedBuffers, y = [
                            u.width * e1.exported.devicePixelRatio,
                            u.height * e1.exported.devicePixelRatio
                        ], b = Float32Array.from(u.globeMatrix), w = {
                            useDenormalizedUpVectorScale: !0
                        };
                        if (v.forEach((h)=>{
                            const u = t1.transform, _ = Ti(u.zoom) * i.exaggeration();
                            c = -1;
                            const v = h ? a.LINES : a.TRIANGLES;
                            for (const c of r){
                                const r = o.getTile(c), T = e1.StencilMode.disabled, E = i.prevTerrainTileForTile[c.key], C = i.terrainTileForTile[c.key];
                                yi(E, C) && bi.newMorphing(c.key, E, C, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                const M = bi.getMorphValuesForProxy(c.key), I = M ? 1 : 0;
                                M && e1.extend$1(w, {
                                    morphing: {
                                        srcDemTile: M.from,
                                        dstDemTile: M.to,
                                        phase: e1.easeCubicInOut(M.phase)
                                    }
                                });
                                const P = e1.tileCornersToBounds(c.canonical), S = e1.getLatitudinalLod(P.getCenter().lat), D = e1.getGridMatrix(c.canonical, P, S, u.worldSize / u._pixelsPerMercatorPixel), L = e1.globeNormalizeECEF(e1.globeTileBounds(c.canonical)), A = xi(u.projMatrix, b, f, L, e1.globeToMercatorTransition(u.zoom), g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, _, D);
                                if (d(I, h), i.setupElevationDraw(r, l, w), t1.prepareDrawProgram(s, l, c.toUnwrapped()), x) {
                                    const [i, o, r] = h ? x.getWirefameBuffers(t1.context, S) : x.getGridBuffers(S, 0 !== _);
                                    l.draw(s, v, m, T, p, e1.CullFaceMode.backCCW, A, "globe_raster", i, o, r);
                                }
                            }
                        }), x) {
                            const n = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _ && n.push("CUSTOM_ANTIALIASING"), l = t1.useProgram("globeRaster", null, n);
                            for (const n of r){
                                const { x: r, y: c, z: h } = n.canonical, _ = 0 === c, d = c === (1 << h) - 1, [f, v, b, T] = x.getPoleBuffers(h);
                                if (T && (_ || d)) {
                                    const c = o.getTile(n);
                                    s.activeTexture.set(a.TEXTURE0), c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                    let x = e1.globePoleMatrixForTile(h, r, u);
                                    const E = e1.globeNormalizeECEF(e1.globeTileBounds(n.canonical)), C = (t1, i)=>t1.draw(s, a.TRIANGLES, m, e1.StencilMode.disabled, p, e1.CullFaceMode.disabled, xi(u.projMatrix, x, x, E, 0, g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, 0), "globe_pole_raster", i, b, T);
                                    i.setupElevationDraw(c, l, w), t1.prepareDrawProgram(s, l, n.toUnwrapped()), _ && C(l, f), d && (x = e1.scale(e1.create(), x, [
                                        1,
                                        -1,
                                        1
                                    ]), C(l, v));
                                }
                            }
                        }
                    }(t1, i, o, r, n);
                    else {
                        const s = t1.context, a = s.gl;
                        let l, c;
                        const h = t1.options.showTerrainWireframe ? 2 : 0, u = (e1, i)=>{
                            if (c === e1) return;
                            const o = [
                                wi[e1]
                            ];
                            i && o.push(wi[h]), l = t1.useProgram("terrainRaster", null, o), c = e1;
                        }, _ = t1.colorModeForRenderPass(), d = new e1.DepthMode(a.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                        bi.update(n);
                        const p = t1.transform, m = Ti(p.zoom) * i.exaggeration();
                        (h ? [
                            !1,
                            !0
                        ] : [
                            !1
                        ]).forEach((h)=>{
                            c = -1;
                            const f = h ? a.LINES : a.TRIANGLES, [g, v] = h ? i.getWirefameBuffer() : [
                                i.gridIndexBuffer,
                                i.gridSegments
                            ];
                            for (const c of r){
                                const r = o.getTile(c), x = e1.StencilMode.disabled, y = i.prevTerrainTileForTile[c.key], b = i.terrainTileForTile[c.key];
                                yi(y, b) && bi.newMorphing(c.key, y, b, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);
                                const w = bi.getMorphValuesForProxy(c.key), T = w ? 1 : 0;
                                let E;
                                w && (E = {
                                    morphing: {
                                        srcDemTile: w.from,
                                        dstDemTile: w.to,
                                        phase: e1.easeCubicInOut(w.phase)
                                    }
                                });
                                const C = vi(c.projMatrix, Ei(c.canonical, p.renderWorldCopies) ? m / 10 : m);
                                u(T, h), i.setupElevationDraw(r, l, E), t1.prepareDrawProgram(s, l, c.toUnwrapped()), l.draw(s, f, d, x, _, e1.CullFaceMode.backCCW, C, "terrain_raster", i.gridBuffer, g, v);
                            }
                        });
                    }
                }(i, this, this.proxySourceCache, t1, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t1.splice(0, t1.length));
            }
            renderBatch(t1) {
                if (0 === this._drapedRenderBatches.length) return t1 + 1;
                this.renderingToTexture = !0;
                const i = this.painter, o = this.painter.context, r = this.proxySourceCache, n = this.proxiedCoords[r.id], s = this._drapedRenderBatches.shift(), a = [], l = i.style.order;
                let c = 0;
                for (const h of n){
                    const n = r.getTileByID(h.proxyTileKey), u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t1] : void 0, _ = void 0 !== u ? r.renderCache[u] : this.pool[c++], d = void 0 !== u;
                    if (n.texture = _.tex, d && !_.dirty) {
                        a.push(n.tileID);
                        continue;
                    }
                    let p;
                    o.bindFramebuffer.set(_.fb.framebuffer), this.renderedToTile = !1, _.dirty && (o.clear({
                        color: e1.Color.transparent,
                        stencil: 0
                    }), _.dirty = !1);
                    for(let e1 = s.start; e1 <= s.end; ++e1){
                        const t1 = i.style._layers[l[e1]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const r = i.style._getLayerSourceCache(t1), n = r ? this.proxyToSource[h.key][r.id] : [
                            h
                        ];
                        if (!n) continue;
                        const s = n;
                        o.viewport.set([
                            0,
                            0,
                            _.fb.width,
                            _.fb.height
                        ]), p !== (r ? r.id : null) && (this._setupStencil(_, n, t1, r), p = r ? r.id : null), i.renderLayer(i, r, t1, s);
                    }
                    this.renderedToTile ? (_.dirty = !0, a.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(a));
                }
                return this.renderToBackBuffer(a), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), s.end + 1;
            }
            postRender() {}
            renderCacheEfficiency(e1) {
                const t1 = e1.order.length;
                if (0 === t1) return {
                    efficiency: 100
                };
                let i, o = 0, r = 0, n = !1;
                for(let s = 0; s < t1; ++s){
                    const t1 = e1._layers[e1.order[s]];
                    this._style.isLayerDraped(t1) ? (n && ++o, ++r) : n || (n = !0, i = t1.id);
                }
                return 0 === r ? {
                    efficiency: 100
                } : {
                    efficiency: 100 * (1 - o / r),
                    firstUndrapedLayer: i
                };
            }
            getMinElevationBelowMSL() {
                let e1 = 0;
                return this._visibleDemTiles.filter((e1)=>e1.dem).forEach((t1)=>{
                    e1 = Math.min(e1, t1.dem.tree.minimums[0]);
                }), 0 === e1 ? e1 : (e1 - 30) * this._exaggeration;
            }
            raycast(e1, t1, i) {
                if (!this._visibleDemTiles) return null;
                const o = this._visibleDemTiles.filter((e1)=>e1.dem).map((o)=>{
                    const r = o.tileID, n = 1 << r.overscaledZ, { x: s, y: a } = r.canonical, l = s / n, c = (s + 1) / n, h = a / n, u = (a + 1) / n;
                    return {
                        minx: l,
                        miny: h,
                        maxx: c,
                        maxy: u,
                        t: o.dem.tree.raycastRoot(l, h, c, u, e1, t1, i),
                        tile: o
                    };
                });
                o.sort((e1, t1)=>(null !== e1.t ? e1.t : Number.MAX_VALUE) - (null !== t1.t ? t1.t : Number.MAX_VALUE));
                for (const r of o){
                    if (null == r.t) return null;
                    const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e1, t1, i);
                    if (null != o) return o;
                }
                return null;
            }
            _createFBO() {
                const t1 = this.painter.context, i = t1.gl, o = this.drapeBufferSize;
                t1.activeTexture.set(i.TEXTURE0);
                const r = new e1.Texture(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.RGBA);
                r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const n = t1.createFramebuffer(o[0], o[1], !1);
                return n.colorAttachment.set(r.texture), n.depthAttachment = new we(t1, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t1.createRenderbuffer(t1.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t1.clear({
                    stencil: 0
                })) : n.depthAttachment.set(this._sharedDepthStencil), t1.extTextureFilterAnisotropic && !t1.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t1.extTextureFilterAnisotropicMax), {
                    fb: n,
                    tex: r,
                    dirty: !1
                };
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition()) return !0;
                for(const e1 in this._style._sourceCaches)if (this._style._sourceCaches[e1].hasTransition()) return !0;
                return this._style.order.some((e1)=>{
                    const t1 = this._style._layers[e1], i = t1.isHidden(this.painter.transform.zoom);
                    return "custom" === t1.type ? !i && t1.shouldRedrape() : !i && t1.hasTransition();
                });
            }
            _clearLineLayersFromRenderCache() {
                let t1 = !1;
                for (const e1 of this._style._getSources())if (e1 instanceof Ce) {
                    t1 = !0;
                    break;
                }
                if (!t1) return;
                const i = {};
                for(let t1 = 0; t1 < this._style.order.length; ++t1){
                    const o = this._style._layers[this._style.order[t1]], r = this._style._getLayerSourceCache(o);
                    if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e1.ZoomDependentExpression) {
                        i[r.id] = !0;
                        for (const e1 of this.proxyCoords){
                            const t1 = this.proxyToSource[e1.key][r.id];
                            if (t1) for (const e1 of t1)this._clearRenderCacheForTile(r.id, e1);
                        }
                    }
                }
            }
            _clearRasterLayersFromRenderCache() {
                let e1 = !1;
                for(const t1 in this._style._sourceCaches)if (this._style._sourceCaches[t1]._source instanceof Me) {
                    e1 = !0;
                    break;
                }
                if (!e1) return;
                const t1 = {};
                for(let e1 = 0; e1 < this._style.order.length; ++e1){
                    const i = this._style._layers[this._style.order[e1]], o = this._style._getLayerSourceCache(i);
                    if (!o || t1[o.id]) continue;
                    if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
                    const r = i.paint.get("raster-fade-duration");
                    for (const e1 of this.proxyCoords){
                        const t1 = this.proxyToSource[e1.key][o.id];
                        if (t1) for (const e1 of t1){
                            const t1 = Mi(o.getTile(e1), o.findLoadedParent(e1, 0), o, this.painter.transform, r);
                            (1 !== t1.opacity || 0 !== t1.mix) && this._clearRenderCacheForTile(o.id, e1);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                const e1 = this._style.order, t1 = e1.length;
                if (0 === t1) return;
                const i = [];
                let o, r = 0, n = this._style._layers[e1[r]];
                for(; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t1;)n = this._style._layers[e1[r]];
                for(; r < t1; ++r){
                    const t1 = this._style._layers[e1[r]];
                    t1.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t1) ? void 0 === o && (o = r) : void 0 !== o && (i.push({
                        start: o,
                        end: r - 1
                    }), o = void 0));
                }
                void 0 !== o && i.push({
                    start: o,
                    end: r - 1
                }), this._drapedRenderBatches = i;
            }
            _setupRenderCache(e1) {
                const t1 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                    if (this._invalidateRenderCache = !1, t1.renderCache.length > t1.renderCachePool.length) {
                        const e1 = Object.values(t1.proxyCachedFBO);
                        t1.proxyCachedFBO = {};
                        for(let i = 0; i < e1.length; ++i){
                            const o = Object.values(e1[i]);
                            t1.renderCachePool.push(...o);
                        }
                    }
                    return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords, o = this._tilesDirty;
                for(let r = i.length - 1; r >= 0; r--){
                    const n = i[r];
                    if (t1.getTileByID(n.key), void 0 !== t1.proxyCachedFBO[n.key]) {
                        const i = e1[n.key], r = this.proxyToSource[n.key];
                        let s = 0;
                        for(const e1 in r){
                            const t1 = r[e1], n = i[e1];
                            if (!n || n.length !== t1.length || t1.some((t1, i)=>t1 !== n[i] || o[e1] && o[e1].hasOwnProperty(t1.key))) {
                                s = -1;
                                break;
                            }
                            ++s;
                        }
                        for(const e1 in t1.proxyCachedFBO[n.key])t1.renderCache[t1.proxyCachedFBO[n.key][e1]].dirty = s < 0 || s !== Object.values(i).length;
                    }
                }
                const r = [
                    ...this._drapedRenderBatches
                ];
                r.sort((e1, t1)=>t1.end - t1.start - (e1.end - e1.start));
                for (const e1 of r)for (const o of i){
                    if (t1.proxyCachedFBO[o.key]) continue;
                    let i = t1.renderCachePool.pop();
                    void 0 === i && t1.renderCache.length < 50 && (i = t1.renderCache.length, t1.renderCache.push(this._createFBO())), void 0 !== i && (t1.proxyCachedFBO[o.key] = {}, t1.proxyCachedFBO[o.key][e1.start] = i, t1.renderCache[i].dirty = !0);
                }
                this._tilesDirty = {};
            }
            _setupStencil(e1, t1, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const r = this.painter.context, n = r.gl;
                if (t1.length <= 1) return void (this._overlapStencilType = !1);
                let s;
                if (i.isTileClipped()) s = t1.length, this._overlapStencilMode.test = {
                    func: n.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t1[0].overscaledZ > t1[t1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    s = 1, this._overlapStencilMode.test = {
                        func: n.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + s > 255 && (r.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += s, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t1, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(t1) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t1.key]), this._overlapStencilMode) : e1.StencilMode.disabled;
            }
            _renderTileClippingMasks(t1, i) {
                const o = this.painter, r = this.painter.context, n = r.gl;
                o._tileClippingMaskIDs = {}, r.setColorMode(e1.ColorMode.disabled), r.setDepthMode(e1.DepthMode.disabled);
                const s = o.useProgram("clippingMask");
                for (const a of t1){
                    const t1 = o._tileClippingMaskIDs[a.key] = --i;
                    s.draw(r, n.TRIANGLES, e1.DepthMode.disabled, new e1.StencilMode({
                        func: n.ALWAYS,
                        mask: 0
                    }, t1, 255, n.KEEP, n.KEEP, n.REPLACE), e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ci(a.projMatrix), "$clipping", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);
                }
            }
            pointCoordinate(t1) {
                const i = this.painter.transform;
                if (t1.x < 0 || t1.x > i.width || t1.y < 0 || t1.y > i.height) return null;
                const o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e1.transformMat4$1(o, o, i.pixelMatrixInverse), e1.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
                const r = i._camera.position, n = e1.mercatorZfromAltitude(1, i.center.lat), s = [
                    r[0],
                    r[1],
                    r[2] / n,
                    0
                ], a = e1.subtract([], o.slice(0, 3), s);
                e1.normalize(a, a);
                const l = this.raycast(s, a, this._exaggeration);
                return null !== l && l ? (e1.scaleAndAdd(s, s, a, l), s[3] = s[2], s[2] *= n, s) : null;
            }
            drawDepth() {
                const t1 = this.painter, i = t1.context, o = this.proxySourceCache, r = Math.ceil(t1.width), n = Math.ceil(t1.height);
                if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
                    const t1 = i.gl, o = i.createFramebuffer(r, n, !0);
                    i.activeTexture.set(t1.TEXTURE0);
                    const s = new e1.Texture(i, {
                        width: r,
                        height: n,
                        data: null
                    }, t1.RGBA);
                    s.bind(t1.NEAREST, t1.CLAMP_TO_EDGE), o.colorAttachment.set(s.texture);
                    const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);
                    o.depthAttachment.set(a), this._depthFBO = o, this._depthTexture = s;
                }
                i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([
                    0,
                    0,
                    r,
                    n
                ]), function(t1, i, o, r) {
                    if ("globe" === t1.transform.projection.name) return;
                    const n = t1.context, s = n.gl;
                    n.clear({
                        depth: 1
                    });
                    const a = t1.useProgram("terrainDepth"), l = new e1.DepthMode(s.LESS, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                    for (const t1 of r){
                        const r = o.getTile(t1), c = vi(t1.projMatrix, 0);
                        i.setupElevationDraw(r, a), a.draw(n, s.TRIANGLES, l, e1.StencilMode.disabled, e1.ColorMode.unblended, e1.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);
                    }
                }(t1, this, o, this.proxyCoords);
            }
            _setupProxiedCoordsForOrtho(e1, t1, i) {
                if (e1.getSource() instanceof Pe) return this._setupProxiedCoordsForImageSource(e1, t1, i);
                this._findCoveringTileCache[e1.id] = this._findCoveringTileCache[e1.id] || {};
                const o = this.proxiedCoords[e1.id] = [], r = this.proxyCoords;
                for(let t1 = 0; t1 < r.length; t1++){
                    const n = r[t1], s = this._findTileCoveringTileID(n, e1);
                    if (s) {
                        const t1 = this._createProxiedId(n, s, i[n.key] && i[n.key][e1.id]);
                        o.push(t1), this.proxyToSource[n.key][e1.id] = [
                            t1
                        ];
                    }
                }
                let n = !1;
                for(let r = 0; r < t1.length; r++){
                    const s = e1.getTile(t1[r]);
                    if (!s || !s.hasData()) continue;
                    const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);
                    if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
                        const t1 = this.proxyToSource[a.tileID.key][e1.id], r = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][e1.id]);
                        t1 ? t1.splice(t1.length - 1, 0, r) : this.proxyToSource[a.tileID.key][e1.id] = [
                            r
                        ], o.push(r), n = !0;
                    }
                }
                this._sourceTilesOverlap[e1.id] = n;
            }
            _setupProxiedCoordsForImageSource(t1, i, o) {
                if (!t1.getSource().loaded()) return;
                const r = this.proxiedCoords[t1.id] = [], n = this.proxyCoords, s = t1.getSource(), a = new e1.Point(s.tileID.x, s.tileID.y)._div(1 << s.tileID.z), l = s.coordinates.map(e1.MercatorCoordinate.fromLngLat).reduce((e1, t1)=>(e1.min.x = Math.min(e1.min.x, t1.x - a.x), e1.min.y = Math.min(e1.min.y, t1.y - a.y), e1.max.x = Math.max(e1.max.x, t1.x - a.x), e1.max.y = Math.max(e1.max.y, t1.y - a.y), e1), {
                    min: new e1.Point(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e1.Point(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), c = (t1, i)=>{
                    const o = t1.wrap + t1.canonical.x / (1 << t1.canonical.z), r = t1.canonical.y / (1 << t1.canonical.z), n = e1.EXTENT / (1 << t1.canonical.z), s = i.wrap + i.canonical.x / (1 << i.canonical.z), a = i.canonical.y / (1 << i.canonical.z);
                    return o + n < s + l.min.x || o > s + l.max.x || r + n < a + l.min.y || r > a + l.max.y;
                };
                for(let e1 = 0; e1 < n.length; e1++){
                    const s = n[e1];
                    for(let e1 = 0; e1 < i.length; e1++){
                        const n = t1.getTile(i[e1]);
                        if (!n || !n.hasData()) continue;
                        if (c(s, n.tileID)) continue;
                        const a = this._createProxiedId(s, n, o[s.key] && o[s.key][t1.id]), l = this.proxyToSource[s.key][t1.id];
                        l ? l.push(a) : this.proxyToSource[s.key][t1.id] = [
                            a
                        ], r.push(a);
                    }
                }
            }
            _createProxiedId(t1, i, o) {
                let r = this.orthoMatrix;
                if (o) {
                    const e1 = o.find((e1)=>e1.key === i.tileID.key);
                    if (e1) return e1;
                }
                if (i.tileID.key !== t1.key) {
                    const o = t1.canonical.z - i.tileID.canonical.z;
                    let n, s, a;
                    r = e1.create();
                    const l = i.tileID.wrap - t1.wrap << t1.overscaledZ;
                    o > 0 ? (n = e1.EXTENT >> o, s = n * ((i.tileID.canonical.x << o) - t1.canonical.x + l), a = n * ((i.tileID.canonical.y << o) - t1.canonical.y)) : (n = e1.EXTENT << -o, s = e1.EXTENT * (i.tileID.canonical.x - (t1.canonical.x + l << -o)), a = e1.EXTENT * (i.tileID.canonical.y - (t1.canonical.y << -o))), e1.ortho(r, 0, n, 0, n, 0, 1), e1.translate(r, r, [
                        s,
                        a,
                        0
                    ]);
                }
                return new Si(i.tileID, t1.key, r);
            }
            _findTileCoveringTileID(t1, i) {
                let o = i.getTile(t1);
                if (o && o.hasData()) return o;
                const r = this._findCoveringTileCache[i.id], n = r[t1.key];
                if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;
                let s = o ? o.tileID : t1, a = s.overscaledZ;
                const l = i.getSource().minzoom, c = [];
                if (!n) {
                    const r = i.getSource().maxzoom;
                    if (t1.canonical.z >= r) {
                        const o = t1.canonical.z - r;
                        i.getSource().reparseOverscaled ? (a = Math.max(t1.canonical.z + 2, i.transform.tileZoom), s = new e1.OverscaledTileID(a, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o)) : 0 !== o && (a = r, s = new e1.OverscaledTileID(a, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o));
                    }
                    s.key !== t1.key && (c.push(s.key), o = i.getTile(s));
                }
                const h = (e1)=>{
                    c.forEach((t1)=>{
                        r[t1] = e1;
                    }), c.length = 0;
                };
                for(a -= 1; a >= l && (!o || !o.hasData()); a--){
                    o && h(o.tileID.key);
                    const e1 = s.calculateScaledKey(a);
                    if (o = i.getTileByID(e1), o && o.hasData()) break;
                    const t1 = r[e1];
                    if (null === t1) break;
                    void 0 === t1 ? c.push(e1) : o = i.getTileByID(t1);
                }
                return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }
            findDEMTileFor(e1) {
                return this.enabled ? this._findTileCoveringTileID(e1, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e1, t1) {
                let i = this._tilesDirty[e1];
                i || (i = this._tilesDirty[e1] = {}), i[t1.key] = !0;
            }
            getWirefameBuffer() {
                if (!this.wireframeSegments) {
                    const t1 = function(t1) {
                        let i = 0;
                        const o = new e1.StructArrayLayout2ui4, r = 131;
                        for(let e1 = 1; e1 < 129; e1++){
                            for(let t1 = 1; t1 < 129; t1++)i = e1 * r + t1, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e1 && o.emplaceBack(i + r, i + r + 1);
                            o.emplaceBack(i + 1, i + 1 + r);
                        }
                        return o;
                    }();
                    this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t1), this.wireframeSegments = e1.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t1.length);
                }
                return [
                    this.wireframeIndexBuffer,
                    this.wireframeSegments
                ];
            }
        }
        class Li {
            static cacheKey(e1, t1, i, o) {
                let r = `${t1}${o ? o.cacheKey : ""}`;
                for (const t1 of i)e1.usedDefines.includes(t1) && (r += `/${t1}`);
                return r;
            }
            constructor(t1, i, o, r, n, s){
                const a = t1.gl;
                this.program = a.createProgram();
                const l = function(e1) {
                    const t1 = [];
                    for(let i = 0; i < e1.length; i++){
                        if (null === e1[i]) continue;
                        const o = e1[i].split(" ");
                        t1.push(o.pop());
                    }
                    return t1;
                }(o.staticAttributes), c = r ? r.getBinderAttributes() : [], h = l.concat(c);
                let u = r ? r.defines() : [];
                u = u.concat(s.map((e1)=>`#define ${e1}`));
                const _ = t1.isWebGL2 ? "#version 300 es\n" : "", d = _ + u.concat(t1.extStandardDerivatives && 0 === _.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(li) : li, li, ai, si.fragmentSource, ri.fragmentSource, o.fragmentSource).join("\n"), p = _ + u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ai, si.vertexSource, ri.vertexSource, oi.vertexSource, o.vertexSource).join("\n"), m = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost()) return void (this.failedToCreate = !0);
                a.shaderSource(m, d), a.compileShader(m), a.attachShader(this.program, m);
                const f = a.createShader(a.VERTEX_SHADER);
                if (a.isContextLost()) this.failedToCreate = !0;
                else {
                    a.shaderSource(f, p), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = h.length;
                    for(let e1 = 0; e1 < this.numAttributes; e1++)h[e1] && (a.bindAttribLocation(this.program, e1, h[e1]), this.attributes[h[e1]] = e1);
                    a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(m), this.fixedUniforms = n(t1), this.binderUniforms = r ? r.getUniforms(t1) : [], s.includes("TERRAIN") && (this.terrainUniforms = ((t1)=>({
                            u_dem: new e1.Uniform1i(t1),
                            u_dem_prev: new e1.Uniform1i(t1),
                            u_dem_unpack: new e1.Uniform4f(t1),
                            u_dem_tl: new e1.Uniform2f(t1),
                            u_dem_scale: new e1.Uniform1f(t1),
                            u_dem_tl_prev: new e1.Uniform2f(t1),
                            u_dem_scale_prev: new e1.Uniform1f(t1),
                            u_dem_size: new e1.Uniform1f(t1),
                            u_dem_lerp: new e1.Uniform1f(t1),
                            u_exaggeration: new e1.Uniform1f(t1),
                            u_depth: new e1.Uniform1i(t1),
                            u_depth_size_inv: new e1.Uniform2f(t1),
                            u_meter_to_dem: new e1.Uniform1f(t1),
                            u_label_plane_matrix_inv: new e1.UniformMatrix4f(t1)
                        }))(t1)), s.includes("GLOBE") && (this.globeUniforms = ((t1)=>({
                            u_tile_tl_up: new e1.Uniform3f(t1),
                            u_tile_tr_up: new e1.Uniform3f(t1),
                            u_tile_br_up: new e1.Uniform3f(t1),
                            u_tile_bl_up: new e1.Uniform3f(t1),
                            u_tile_up_scale: new e1.Uniform1f(t1)
                        }))(t1)), s.includes("FOG") && (this.fogUniforms = ((t1)=>({
                            u_fog_matrix: new e1.UniformMatrix4f(t1),
                            u_fog_range: new e1.Uniform2f(t1),
                            u_fog_color: new e1.Uniform4f(t1),
                            u_fog_horizon_blend: new e1.Uniform1f(t1),
                            u_fog_temporal_offset: new e1.Uniform1f(t1),
                            u_frustum_tl: new e1.Uniform3f(t1),
                            u_frustum_tr: new e1.Uniform3f(t1),
                            u_frustum_br: new e1.Uniform3f(t1),
                            u_frustum_bl: new e1.Uniform3f(t1),
                            u_globe_pos: new e1.Uniform3f(t1),
                            u_globe_radius: new e1.Uniform1f(t1),
                            u_globe_transition: new e1.Uniform1f(t1),
                            u_is_globe: new e1.Uniform1i(t1),
                            u_viewport: new e1.Uniform2f(t1)
                        }))(t1));
                }
            }
            setTerrainUniformValues(e1, t1) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e1.program.set(this.program);
                    for(const e1 in t1)i[e1] && i[e1].set(this.program, e1, t1[e1]);
                }
            }
            setGlobeUniformValues(e1, t1) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    e1.program.set(this.program);
                    for(const e1 in t1)i[e1] && i[e1].set(this.program, e1, t1[e1]);
                }
            }
            setFogUniformValues(e1, t1) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    e1.program.set(this.program);
                    for(const e1 in t1)i[e1].set(this.program, e1, t1[e1]);
                }
            }
            draw(e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p) {
                const m = e1.gl;
                if (this.failedToCreate) return;
                e1.program.set(this.program), e1.setDepthMode(i), e1.setStencilMode(o), e1.setColorMode(r), e1.setCullFace(n);
                for (const e1 of Object.keys(this.fixedUniforms))this.fixedUniforms[e1].set(this.program, e1, s[e1]);
                d && d.setUniforms(this.program, e1, this.binderUniforms, u, {
                    zoom: _
                });
                const f = {
                    [m.LINES]: 2,
                    [m.TRIANGLES]: 3,
                    [m.LINE_STRIP]: 1
                }[t1];
                for (const i of h.get()){
                    const o = i.vaos || (i.vaos = {});
                    (o[a] || (o[a] = new _i)).bind(e1, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p || []), m.drawElements(t1, i.primitiveLength * f, m.UNSIGNED_SHORT, i.primitiveOffset * f * 2);
                }
            }
        }
        function Ai(e1, t1) {
            const i = Math.pow(2, t1.tileID.overscaledZ), o = t1.tileSize * Math.pow(2, e1.transform.tileZoom) / i, r = o * (t1.tileID.canonical.x + t1.tileID.wrap * i), n = o * t1.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: t1.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / D(t1, 1, e1.transform.tileZoom),
                u_pixel_coord_upper: [
                    r >> 16,
                    n >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & r,
                    65535 & n
                ]
            };
        }
        const zi = e1.create(), Ri = (t1, i, o, r, n, s, a, l, c, h, u)=>{
            const _ = i.style.light, d = _.properties.get("position"), p = [
                d.x,
                d.y,
                d.z
            ], m = e1.create$1();
            "viewport" === _.properties.get("anchor") && (e1.fromRotation(m, -i.transform.angle), e1.transformMat3(p, p, m));
            const f = _.properties.get("color"), g = i.transform, v = {
                u_matrix: t1,
                u_lightpos: p,
                u_lightintensity: _.properties.get("intensity"),
                u_lightcolor: [
                    f.r,
                    f.g,
                    f.b
                ],
                u_vertical_gradient: +o,
                u_opacity: r,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: zi,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_ao: n,
                u_edge_radius: s
            };
            return "globe" === g.projection.name && (v.u_tile_id = [
                a.canonical.x,
                a.canonical.y,
                1 << a.canonical.z
            ], v.u_zoom_transition = c, v.u_inv_rot_matrix = u, v.u_merc_center = h, v.u_up_dir = g.projection.upVector(new e1.CanonicalTileID(0, 0, 0), h[0] * e1.EXTENT, h[1] * e1.EXTENT), v.u_height_lift = l), v;
        }, Oi = (t1, i, o, r, n, s, a, l, c, h, u, _)=>{
            const d = Ri(t1, i, o, r, n, s, a, c, h, u, _), p = {
                u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8
            };
            return e1.extend(d, Ai(i, l), p);
        }, Bi = (e1)=>({
                u_matrix: e1
            }), ki = (t1, i, o)=>e1.extend(Bi(t1), Ai(i, o)), Fi = (e1, t1)=>({
                u_matrix: e1,
                u_world: t1
            }), Ui = (t1, i, o, r)=>e1.extend(ki(t1, i, o), {
                u_world: r
            }), Ni = e1.create(), ji = (t1, i, o, r, n, s)=>{
            const a = t1.transform, l = "globe" === a.projection.name;
            let c;
            if ("map" === s.paint.get("circle-pitch-alignment")) {
                if (l) {
                    const t1 = e1.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;
                    c = Float32Array.from([
                        t1,
                        0,
                        0,
                        t1
                    ]);
                } else c = a.calculatePixelsToTileUnitsMatrix(o);
            } else c = new Float32Array([
                a.pixelsToGLUnits[0],
                0,
                0,
                a.pixelsToGLUnits[1]
            ]);
            const h = {
                u_camera_to_center_distance: a.cameraToCenterDistance,
                u_matrix: t1.translatePosMatrix(i.projMatrix, o, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: e1.exported.devicePixelRatio,
                u_extrude_scale: c,
                u_inv_rot_matrix: Ni,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (l) {
                h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], h.u_zoom_transition = e1.globeToMercatorTransition(a.zoom);
                const t1 = n[0] * e1.EXTENT, o = n[1] * e1.EXTENT;
                h.u_up_dir = a.projection.upVector(new e1.CanonicalTileID(0, 0, 0), t1, o);
            }
            return h;
        }, Gi = (e1)=>{
            const t1 = [];
            return "map" === e1.paint.get("circle-pitch-alignment") && t1.push("PITCH_WITH_MAP"), "map" === e1.paint.get("circle-pitch-scale") && t1.push("SCALE_WITH_MAP"), t1;
        }, Zi = (t1, i, o, r)=>{
            const n = e1.EXTENT / o.tileSize;
            return {
                u_matrix: t1,
                u_camera_to_center_distance: i.getCameraToCenterDistance(r),
                u_extrude_scale: [
                    i.pixelsToGLUnits[0] / n,
                    i.pixelsToGLUnits[1] / n
                ]
            };
        }, Vi = (e1, t1, i = 1)=>({
                u_matrix: e1,
                u_color: t1,
                u_overlay: 0,
                u_overlay_scale: i
            }), Wi = e1.create(), Xi = (t1, i, o, r, n, s, a)=>{
            const l = t1.transform, c = "globe" === l.projection.name, h = c ? e1.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : D(o, 1, s), u = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: a,
                u_inv_rot_matrix: Wi,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c) {
                u.u_inv_rot_matrix = r, u.u_merc_center = n, u.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], u.u_zoom_transition = e1.globeToMercatorTransition(l.zoom);
                const t1 = n[0] * e1.EXTENT, o = n[1] * e1.EXTENT;
                u.u_up_dir = l.projection.upVector(new e1.CanonicalTileID(0, 0, 0), t1, o);
            }
            return u;
        }, qi = (e1, t1, i, o, r, n, s)=>{
            const a = e1.transform, l = a.calculatePixelsToTileUnitsMatrix(t1);
            return {
                u_matrix: Yi(e1, t1, i, o),
                u_pixels_to_tile_units: l,
                u_device_pixel_ratio: n,
                u_units_to_pixels: [
                    1 / a.pixelsToGLUnits[0],
                    1 / a.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: r,
                u_texsize: Ki(i) ? t1.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: Hi(t1, e1.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: s
            };
        }, $i = (e1, t1, i, o, r)=>{
            const n = e1.transform;
            return {
                u_matrix: Yi(e1, t1, i, o),
                u_texsize: t1.imageAtlasTexture.size,
                u_pixels_to_tile_units: n.calculatePixelsToTileUnitsMatrix(t1),
                u_device_pixel_ratio: r,
                u_image: 0,
                u_tile_units_to_pixels: Hi(t1, n),
                u_units_to_pixels: [
                    1 / n.pixelsToGLUnits[0],
                    1 / n.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0
            };
        };
        function Hi(e1, t1) {
            return 1 / D(e1, 1, t1.tileZoom);
        }
        function Yi(e1, t1, i, o) {
            return e1.translatePosMatrix(o || t1.tileID.projMatrix, t1, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
        }
        function Ki(e1) {
            const t1 = e1.paint.get("line-dasharray").value;
            return t1.value || "constant" !== t1.kind;
        }
        const Ji = (e1, t1, i, o, r, n)=>{
            var s, a;
            return {
                u_matrix: e1,
                u_tl_parent: t1,
                u_scale_parent: i,
                u_fade_t: o.mix,
                u_opacity: o.opacity * r.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: r.paint.get("raster-brightness-min"),
                u_brightness_high: r.paint.get("raster-brightness-max"),
                u_saturation_factor: (a = r.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a),
                u_contrast_factor: (s = r.paint.get("raster-contrast"), s > 0 ? 1 / (1 - s) : 1 + s),
                u_spin_weights: Qi(r.paint.get("raster-hue-rotate")),
                u_perspective_transform: n
            };
        };
        function Qi(e1) {
            e1 *= Math.PI / 180;
            const t1 = Math.sin(e1), i = Math.cos(e1);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t1 - i + 1) / 3,
                (Math.sqrt(3) * t1 - i + 1) / 3
            ];
        }
        const eo = e1.create(), to = (t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f)=>{
            const g = n.transform, v = {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: g.cameraToCenterDistance,
                u_rotate_symbol: +o,
                u_aspect_ratio: g.width / g.height,
                u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,
                u_matrix: s,
                u_label_plane_matrix: a,
                u_coord_matrix: l,
                u_is_text: +c,
                u_pitch_with_map: +r,
                u_texsize: h,
                u_texture: 0,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: eo,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: eo,
                u_up_vector: [
                    0,
                    -1,
                    0
                ]
            };
            return "globe" === f.name && (v.u_tile_id = [
                u.canonical.x,
                u.canonical.y,
                1 << u.canonical.z
            ], v.u_zoom_transition = _, v.u_inv_rot_matrix = p, v.u_merc_center = d, v.u_camera_forward = g._camera.forward(), v.u_ecef_origin = e1.globeECEFOrigin(g.globeMatrix, u.toUnwrapped()), v.u_tile_matrix = Float32Array.from(g.globeMatrix), v.u_up_vector = m), v;
        }, io = (t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g)=>e1.extend(to(t1, i, o, r, n, s, a, l, c, h, _, d, p, m, f, g), {
                u_gamma_scale: r ? n.transform.cameraToCenterDistance * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1,
                u_device_pixel_ratio: e1.exported.devicePixelRatio,
                u_is_halo: +u
            }), oo = (t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f)=>e1.extend(io(t1, i, o, r, n, s, a, l, !0, c, !0, u, _, d, p, m, f), {
                u_texsize_icon: h,
                u_texture_icon: 1
            }), ro = (e1, t1, i)=>({
                u_matrix: e1,
                u_opacity: t1,
                u_color: i
            }), no = (t1, i, o, r, n)=>e1.extend(function(e1, t1, i) {
                const o = t1.imageManager.getPattern(e1.toString()), { width: r, height: n } = t1.imageManager.getPixelSize(), s = Math.pow(2, i.tileID.overscaledZ), a = i.tileSize * Math.pow(2, t1.transform.tileZoom) / s, l = a * (i.tileID.canonical.x + i.tileID.wrap * s), c = a * i.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o.tl,
                    u_pattern_br: o.br,
                    u_texsize: [
                        r,
                        n
                    ],
                    u_pattern_size: o.displaySize,
                    u_tile_units_to_pixels: 1 / D(i, 1, t1.transform.tileZoom),
                    u_pixel_coord_upper: [
                        l >> 16,
                        c >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & l,
                        65535 & c
                    ]
                };
            }(r, o, n), {
                u_matrix: t1,
                u_opacity: i
            }), so = {
            fillExtrusion: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_lightpos: new e1.Uniform3f(t1),
                    u_lightintensity: new e1.Uniform1f(t1),
                    u_lightcolor: new e1.Uniform3f(t1),
                    u_vertical_gradient: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_edge_radius: new e1.Uniform1f(t1),
                    u_ao: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_up_dir: new e1.Uniform3f(t1),
                    u_height_lift: new e1.Uniform1f(t1)
                }),
            fillExtrusionPattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_lightpos: new e1.Uniform3f(t1),
                    u_lightintensity: new e1.Uniform1f(t1),
                    u_lightcolor: new e1.Uniform3f(t1),
                    u_vertical_gradient: new e1.Uniform1f(t1),
                    u_height_factor: new e1.Uniform1f(t1),
                    u_edge_radius: new e1.Uniform1f(t1),
                    u_ao: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_up_dir: new e1.Uniform3f(t1),
                    u_height_lift: new e1.Uniform1f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1)
                }),
            fill: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1)
                }),
            fillPattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1)
                }),
            fillOutline: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_world: new e1.Uniform2f(t1)
                }),
            fillOutlinePattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_world: new e1.Uniform2f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1)
                }),
            circle: (t1)=>({
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_extrude_scale: new e1.UniformMatrix2f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_up_dir: new e1.Uniform3f(t1)
                }),
            collisionBox: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_extrude_scale: new e1.Uniform2f(t1)
                }),
            collisionCircle: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_inv_matrix: new e1.UniformMatrix4f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_viewport_size: new e1.Uniform2f(t1)
                }),
            debug: (t1)=>({
                    u_color: new e1.UniformColor(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_overlay: new e1.Uniform1i(t1),
                    u_overlay_scale: new e1.Uniform1f(t1)
                }),
            clippingMask: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1)
                }),
            heatmap: (t1)=>({
                    u_extrude_scale: new e1.Uniform1f(t1),
                    u_intensity: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_up_dir: new e1.Uniform3f(t1)
                }),
            heatmapTexture: (t1)=>({
                    u_image: new e1.Uniform1i(t1),
                    u_color_ramp: new e1.Uniform1i(t1),
                    u_opacity: new e1.Uniform1f(t1)
                }),
            hillshade: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_latrange: new e1.Uniform2f(t1),
                    u_light: new e1.Uniform2f(t1),
                    u_shadow: new e1.UniformColor(t1),
                    u_highlight: new e1.UniformColor(t1),
                    u_accent: new e1.UniformColor(t1)
                }),
            hillshadePrepare: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_dimension: new e1.Uniform2f(t1),
                    u_zoom: new e1.Uniform1f(t1),
                    u_unpack: new e1.Uniform4f(t1)
                }),
            line: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_pixels_to_tile_units: new e1.UniformMatrix2f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_units_to_pixels: new e1.Uniform2f(t1),
                    u_dash_image: new e1.Uniform1i(t1),
                    u_gradient_image: new e1.Uniform1i(t1),
                    u_image_height: new e1.Uniform1f(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1),
                    u_alpha_discard_threshold: new e1.Uniform1f(t1),
                    u_trim_offset: new e1.Uniform2f(t1)
                }),
            linePattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixels_to_tile_units: new e1.UniformMatrix2f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_units_to_pixels: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1),
                    u_alpha_discard_threshold: new e1.Uniform1f(t1)
                }),
            raster: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_tl_parent: new e1.Uniform2f(t1),
                    u_scale_parent: new e1.Uniform1f(t1),
                    u_fade_t: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_image0: new e1.Uniform1i(t1),
                    u_image1: new e1.Uniform1i(t1),
                    u_brightness_low: new e1.Uniform1f(t1),
                    u_brightness_high: new e1.Uniform1f(t1),
                    u_saturation_factor: new e1.Uniform1f(t1),
                    u_contrast_factor: new e1.Uniform1f(t1),
                    u_spin_weights: new e1.Uniform3f(t1),
                    u_perspective_transform: new e1.Uniform2f(t1)
                }),
            symbolIcon: (t1)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t1),
                    u_is_size_feature_constant: new e1.Uniform1i(t1),
                    u_size_t: new e1.Uniform1f(t1),
                    u_size: new e1.Uniform1f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_rotate_symbol: new e1.Uniform1i(t1),
                    u_aspect_ratio: new e1.Uniform1f(t1),
                    u_fade_change: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t1),
                    u_coord_matrix: new e1.UniformMatrix4f(t1),
                    u_is_text: new e1.Uniform1i(t1),
                    u_pitch_with_map: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_camera_forward: new e1.Uniform3f(t1),
                    u_tile_matrix: new e1.UniformMatrix4f(t1),
                    u_up_vector: new e1.Uniform3f(t1),
                    u_ecef_origin: new e1.Uniform3f(t1),
                    u_texture: new e1.Uniform1i(t1)
                }),
            symbolSDF: (t1)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t1),
                    u_is_size_feature_constant: new e1.Uniform1i(t1),
                    u_size_t: new e1.Uniform1f(t1),
                    u_size: new e1.Uniform1f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_rotate_symbol: new e1.Uniform1i(t1),
                    u_aspect_ratio: new e1.Uniform1f(t1),
                    u_fade_change: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t1),
                    u_coord_matrix: new e1.UniformMatrix4f(t1),
                    u_is_text: new e1.Uniform1i(t1),
                    u_pitch_with_map: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_texture: new e1.Uniform1i(t1),
                    u_gamma_scale: new e1.Uniform1f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_camera_forward: new e1.Uniform3f(t1),
                    u_tile_matrix: new e1.UniformMatrix4f(t1),
                    u_up_vector: new e1.Uniform3f(t1),
                    u_ecef_origin: new e1.Uniform3f(t1),
                    u_is_halo: new e1.Uniform1i(t1)
                }),
            symbolTextAndIcon: (t1)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t1),
                    u_is_size_feature_constant: new e1.Uniform1i(t1),
                    u_size_t: new e1.Uniform1f(t1),
                    u_size: new e1.Uniform1f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_rotate_symbol: new e1.Uniform1i(t1),
                    u_aspect_ratio: new e1.Uniform1f(t1),
                    u_fade_change: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t1),
                    u_coord_matrix: new e1.UniformMatrix4f(t1),
                    u_is_text: new e1.Uniform1i(t1),
                    u_pitch_with_map: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_texsize_icon: new e1.Uniform2f(t1),
                    u_texture: new e1.Uniform1i(t1),
                    u_texture_icon: new e1.Uniform1i(t1),
                    u_gamma_scale: new e1.Uniform1f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_is_halo: new e1.Uniform1i(t1)
                }),
            background: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_color: new e1.UniformColor(t1)
                }),
            backgroundPattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_pattern_tl: new e1.Uniform2f(t1),
                    u_pattern_br: new e1.Uniform2f(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pattern_size: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1)
                }),
            terrainRaster: gi,
            terrainDepth: gi,
            skybox: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_sun_direction: new e1.Uniform3f(t1),
                    u_cubemap: new e1.Uniform1i(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_temporal_offset: new e1.Uniform1f(t1)
                }),
            skyboxGradient: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_color_ramp: new e1.Uniform1i(t1),
                    u_center_direction: new e1.Uniform3f(t1),
                    u_radius: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_temporal_offset: new e1.Uniform1f(t1)
                }),
            skyboxCapture: (t1)=>({
                    u_matrix_3f: new e1.UniformMatrix3f(t1),
                    u_sun_direction: new e1.Uniform3f(t1),
                    u_sun_intensity: new e1.Uniform1f(t1),
                    u_color_tint_r: new e1.Uniform4f(t1),
                    u_color_tint_m: new e1.Uniform4f(t1),
                    u_luminance: new e1.Uniform1f(t1)
                }),
            globeRaster: (t1)=>({
                    u_proj_matrix: new e1.UniformMatrix4f(t1),
                    u_globe_matrix: new e1.UniformMatrix4f(t1),
                    u_normalize_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_matrix: new e1.UniformMatrix4f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_image0: new e1.Uniform1i(t1),
                    u_grid_matrix: new e1.UniformMatrix3f(t1),
                    u_skirt_height: new e1.Uniform1f(t1),
                    u_frustum_tl: new e1.Uniform3f(t1),
                    u_frustum_tr: new e1.Uniform3f(t1),
                    u_frustum_br: new e1.Uniform3f(t1),
                    u_frustum_bl: new e1.Uniform3f(t1),
                    u_globe_pos: new e1.Uniform3f(t1),
                    u_globe_radius: new e1.Uniform1f(t1),
                    u_viewport: new e1.Uniform2f(t1)
                }),
            globeAtmosphere: (t1)=>({
                    u_frustum_tl: new e1.Uniform3f(t1),
                    u_frustum_tr: new e1.Uniform3f(t1),
                    u_frustum_br: new e1.Uniform3f(t1),
                    u_frustum_bl: new e1.Uniform3f(t1),
                    u_horizon: new e1.Uniform1f(t1),
                    u_transition: new e1.Uniform1f(t1),
                    u_fadeout_range: new e1.Uniform1f(t1),
                    u_color: new e1.Uniform4f(t1),
                    u_high_color: new e1.Uniform4f(t1),
                    u_space_color: new e1.Uniform4f(t1),
                    u_star_intensity: new e1.Uniform1f(t1),
                    u_star_density: new e1.Uniform1f(t1),
                    u_star_size: new e1.Uniform1f(t1),
                    u_temporal_offset: new e1.Uniform1f(t1),
                    u_horizon_angle: new e1.Uniform1f(t1),
                    u_rotation_matrix: new e1.UniformMatrix4f(t1)
                })
        };
        let ao;
        function lo(t1, i, o, r, n, s, a) {
            const l = t1.context, c = l.gl, h = t1.transform, u = t1.useProgram("collisionBox"), _ = [];
            let d = 0, p = 0;
            for(let m = 0; m < r.length; m++){
                const f = r[m], g = i.getTile(f), v = g.getBucket(o);
                if (!v) continue;
                const x = vt(f, v, h);
                let y = x;
                0 === n[0] && 0 === n[1] || (y = t1.translatePosMatrix(x, g, n, s));
                const b = a ? v.textCollisionBox : v.iconCollisionBox, w = v.collisionCircleArray;
                if (w.length > 0) {
                    const t1 = e1.create(), i = y;
                    e1.mul(t1, v.placementInvProjMatrix, h.glCoordMatrix), e1.mul(t1, t1, v.placementViewportMatrix), _.push({
                        circleArray: w,
                        circleOffset: p,
                        transform: i,
                        invTransform: t1,
                        projection: v.getProjection()
                    }), d += w.length / 4, p = d;
                }
                b && (t1.terrain && t1.terrain.setupElevationDraw(g, u), u.draw(l, c.LINES, e1.DepthMode.disabled, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.disabled, Zi(y, h, g, v.getProjection()), o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, h.zoom, null, [
                    b.collisionVertexBuffer,
                    b.collisionVertexBufferExt
                ]));
            }
            if (!a || !_.length) return;
            const m = t1.useProgram("collisionCircle"), f = new e1.StructArrayLayout2f1f2i16;
            f.resize(4 * d), f._trim();
            let g = 0;
            for (const e1 of _)for(let t1 = 0; t1 < e1.circleArray.length / 4; t1++){
                const i = 4 * t1, o = e1.circleArray[i + 0], r = e1.circleArray[i + 1], n = e1.circleArray[i + 2], s = e1.circleArray[i + 3];
                f.emplace(g++, o, r, n, s, 0), f.emplace(g++, o, r, n, s, 1), f.emplace(g++, o, r, n, s, 2), f.emplace(g++, o, r, n, s, 3);
            }
            (!ao || ao.length < 2 * d) && (ao = function(t1) {
                const i = 2 * t1, o = new e1.StructArrayLayout3ui6;
                o.resize(i), o._trim();
                for(let e1 = 0; e1 < i; e1++){
                    const t1 = 6 * e1;
                    o.uint16[t1 + 0] = 4 * e1 + 0, o.uint16[t1 + 1] = 4 * e1 + 1, o.uint16[t1 + 2] = 4 * e1 + 2, o.uint16[t1 + 3] = 4 * e1 + 2, o.uint16[t1 + 4] = 4 * e1 + 3, o.uint16[t1 + 5] = 4 * e1 + 0;
                }
                return o;
            }(d));
            const v = l.createIndexBuffer(ao, !0), x = l.createVertexBuffer(f, e1.collisionCircleLayout.members, !0);
            for (const i of _){
                const r = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [
                        y.width,
                        y.height
                    ]
                };
                m.draw(l, c.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.disabled, r, o.id, x, v, e1.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            var y;
            x.destroy(), v.destroy();
        }
        const co = e1.create();
        function ho({ width: t1, height: i, anchor: o, textOffset: r, textScale: n }, s) {
            const { horizontalAlign: a, verticalAlign: l } = e1.getAnchorAlignment(o), c = -(a - .5) * t1, h = -(l - .5) * i, u = e1.evaluateVariableOffset(o, r);
            return new e1.Point((c / n + u[0]) * s, (h / n + u[1]) * s);
        }
        function uo(t1, i, o, r, n, s, a, l, c, h, u) {
            const _ = t1.text.placedSymbolArray, d = t1.text.dynamicLayoutVertexArray, p = t1.icon.dynamicLayoutVertexArray, m = {}, f = t1.getProjection(), g = xt(l, f, s), v = s.elevation, x = f.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;
            d.clear();
            for(let p = 0; p < _.length; p++){
                const y = _.get(p), { tileAnchorX: b, tileAnchorY: w, numGlyphs: T } = y, E = y.hidden || !y.crossTileID || t1.allowVerticalPlacement && !y.placedOrientation ? null : r[y.crossTileID];
                if (E) {
                    let r = 0, _ = 0, p = 0;
                    if (v) {
                        const e1 = v ? v.getAtTileOffset(l, b, w) : 0, [t1, i, o] = f.upVector(l.canonical, b, w);
                        r = e1 * t1 * x, _ = e1 * i * x, p = e1 * o * x;
                    }
                    let [C, M, I, P] = ot(y.projectedAnchorX + r, y.projectedAnchorY + _, y.projectedAnchorZ + p, o ? g : a);
                    const S = rt(s.getCameraToCenterDistance(f), P);
                    let D = n.evaluateSizeForFeature(t1.textSizeData, h, y) * S / e1.ONE_EM;
                    o && (D *= t1.tilePixelRatio / c);
                    const L = ho(E, D);
                    o ? ({ x: C, y: M, z: I } = f.projectTilePoint(b + L.x, w + L.y, l.canonical), [C, M, I] = ot(C + r, M + _, I + p, a)) : (i && L._rotate(-s.angle), C += L.x, M += L.y, I = 0);
                    const A = t1.allowVerticalPlacement && y.placedOrientation === e1.WritingMode.vertical ? Math.PI / 2 : 0;
                    for(let t1 = 0; t1 < T; t1++)e1.addDynamicAttributes(d, C, M, I, A);
                    u && y.associatedIconIndex >= 0 && (m[y.associatedIconIndex] = {
                        x: C,
                        y: M,
                        z: I,
                        angle: A
                    });
                } else dt(T, d);
            }
            if (u) {
                p.clear();
                const i = t1.icon.placedSymbolArray;
                for(let t1 = 0; t1 < i.length; t1++){
                    const o = i.get(t1), { numGlyphs: r } = o, n = m[t1];
                    if (o.hidden || !n) dt(r, p);
                    else {
                        const { x: t1, y: i, z: o, angle: s } = n;
                        for(let n = 0; n < r; n++)e1.addDynamicAttributes(p, t1, i, o, s);
                    }
                }
                t1.icon.dynamicLayoutVertexBuffer.updateData(p);
            }
            t1.text.dynamicLayoutVertexBuffer.updateData(d);
        }
        function _o(e1, t1, i) {
            return i.iconsInText && t1 ? "symbolTextAndIcon" : e1 ? "symbolSDF" : "symbolIcon";
        }
        function po(t1, i, o, r, n, s, a, l, c, h, u, _) {
            const d = t1.context, p = d.gl, m = t1.transform, f = "map" === l, g = "map" === c, v = f && "point" !== o.layout.get("symbol-placement"), x = f && !g && !v, y = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
            let b = !1;
            const w = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), T = [
                e1.mercatorXfromLng(m.center.lng),
                e1.mercatorYfromLat(m.center.lat)
            ], E = o.layout.get("text-variable-anchor"), C = "globe" === m.projection.name, M = [], I = [
                0,
                -1,
                0
            ];
            let P = I;
            !C && !m.mercatorFromTransition || f || (P = function(t1) {
                const i = t1._camera.getWorldToCamera(t1.worldSize, 1), o = e1.multiply([], i, t1.globeMatrix);
                e1.invert(o, o);
                const r = [
                    0,
                    0,
                    0
                ], n = [
                    0,
                    1,
                    0,
                    0
                ];
                return e1.transformMat4$1(n, n, o), r[0] = n[0], r[1] = n[1], r[2] = n[2], e1.normalize(r, r), r;
            }(m));
            for (const l of r){
                const r = i.getTile(l), c = r.getBucket(o);
                if (!c) continue;
                if ("mercator" === c.projection.name && C) continue;
                const u = n ? c.text : c.icon;
                if (!u || c.fullyClipped || !u.segments.get().length) continue;
                const _ = u.programConfigurations.get(o.id), d = n || c.sdfIcons, w = n ? c.textSizeData : c.iconSizeData, S = g || 0 !== m.pitch, D = e1.evaluateSizeForZoom(w, m.zoom);
                let L, A, z, R, O = [
                    0,
                    0
                ], B = null;
                if (n) A = r.glyphAtlasTexture, z = p.LINEAR, L = r.glyphAtlasTexture.size, c.iconsInText && (O = r.imageAtlasTexture.size, B = r.imageAtlasTexture, R = S || t1.options.rotating || t1.options.zooming || "composite" === w.kind || "camera" === w.kind ? p.LINEAR : p.NEAREST);
                else {
                    const e1 = 1 !== o.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                    A = r.imageAtlasTexture, z = d || t1.options.rotating || t1.options.zooming || e1 || S ? p.LINEAR : p.NEAREST, L = r.imageAtlasTexture.size;
                }
                const k = "globe" === c.projection.name, F = k ? P : I, U = k ? e1.globeToMercatorTransition(m.zoom) : 0, N = xt(l, c.getProjection(), m), j = m.calculatePixelsToTileUnitsMatrix(r), G = et(N, r.tileID.canonical, g, f, m, c.getProjection(), j), Z = t1.terrain && g && v ? e1.invert(e1.create(), G) : co, V = it(N, r.tileID.canonical, g, f, m, c.getProjection(), j), W = E && c.hasTextData(), X = "none" !== o.layout.get("icon-text-fit") && W && c.hasIconData();
                if (v) {
                    const e1 = m.elevation, i = e1 ? e1.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, c.getProjection()) : null, o = tt(N, r.tileID.canonical, g, f, m, c.getProjection(), j);
                    st(c, N, t1, n, o, V, g, h, i, l);
                }
                const q = v || n && E || X, $ = t1.translatePosMatrix(N, r, s, a), H = q ? co : G, Y = t1.translatePosMatrix(V, r, s, a, !0), K = c.getProjection().createInversionMatrix(m, l.canonical), J = [];
                t1.terrainRenderModeElevated() && g && J.push("PITCH_WITH_MAP_TERRAIN"), k && J.push("PROJECTION_GLOBE_VIEW"), q && J.push("PROJECTED_POS_ON_VIEWPORT");
                const Q = d && 0 !== o.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1);
                let ee;
                ee = d ? c.iconsInText ? oo(w.kind, D, x, g, t1, $, H, Y, L, O, l, U, T, K, F, c.getProjection()) : io(w.kind, D, x, g, t1, $, H, Y, n, L, !0, l, U, T, K, F, c.getProjection()) : to(w.kind, D, x, g, t1, $, H, Y, n, L, l, U, T, K, F, c.getProjection());
                const te = {
                    program: t1.useProgram(_o(d, n, c), _, J),
                    buffers: u,
                    uniformValues: ee,
                    atlasTexture: A,
                    atlasTextureIcon: B,
                    atlasInterpolation: z,
                    atlasInterpolationIcon: R,
                    isSDF: d,
                    hasHalo: Q,
                    tile: r,
                    labelPlaneMatrixInv: Z
                };
                if (y && c.canOverlap) {
                    b = !0;
                    const t1 = u.segments.get();
                    for (const i of t1)M.push({
                        segments: new e1.SegmentVector([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: te
                    });
                } else M.push({
                    segments: u.segments,
                    sortKey: 0,
                    state: te
                });
            }
            b && M.sort((e1, t1)=>e1.sortKey - t1.sortKey);
            for (const e1 of M){
                const i = e1.state;
                if (t1.terrain && t1.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: !C,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {
                    const r = i.uniformValues;
                    i.hasHalo && (r.u_is_halo = 1, mo(i.buffers, e1.segments, o, t1, i.program, w, u, _, r)), r.u_is_halo = 0;
                }
                mo(i.buffers, e1.segments, o, t1, i.program, w, u, _, i.uniformValues);
            }
        }
        function mo(t1, i, o, r, n, s, a, l, c) {
            const h = r.context, u = [
                t1.dynamicLayoutVertexBuffer,
                t1.opacityVertexBuffer,
                t1.globeExtVertexBuffer
            ];
            n.draw(h, h.gl.TRIANGLES, s, a, l, e1.CullFaceMode.disabled, c, o.id, t1.layoutVertexBuffer, t1.indexBuffer, i, o.paint, r.transform.zoom, t1.programConfigurations.get(o.id), u);
        }
        function fo(t1, i, o, r, n, s, a) {
            const l = t1.context.gl, c = o.paint.get("fill-pattern"), h = c && c.constantOr(1);
            let u, _, d, p, m;
            a ? (_ = h && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u = l.LINES) : (_ = h ? "fillPattern" : "fill", u = l.TRIANGLES);
            for (const f of r){
                const r = i.getTile(f);
                if (h && !r.patternsLoaded()) continue;
                const g = r.getBucket(o);
                if (!g) continue;
                t1.prepareDrawTile();
                const v = g.programConfigurations.get(o.id), x = t1.useProgram(_, v);
                h && (t1.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers());
                const y = c.constantOr(null);
                if (y && r.imageAtlas) {
                    const e1 = r.imageAtlas.patternPositions[y.toString()];
                    e1 && v.setConstantPatternPositions(e1);
                }
                const b = t1.translatePosMatrix(f.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
                if (a) {
                    p = g.indexBuffer2, m = g.segments2;
                    const e1 = t1.terrain && t1.terrain.renderingToTexture ? t1.terrain.drapeBufferSize : [
                        l.drawingBufferWidth,
                        l.drawingBufferHeight
                    ];
                    d = "fillOutlinePattern" === _ && h ? Ui(b, t1, r, e1) : Fi(b, e1);
                } else p = g.indexBuffer, m = g.segments, d = h ? ki(b, t1, r) : Bi(b);
                t1.prepareDrawProgram(t1.context, x, f.toUnwrapped()), x.draw(t1.context, u, n, t1.stencilModeForClipping(f), s, e1.CullFaceMode.disabled, d, o.id, g.layoutVertexBuffer, p, m, o.paint, t1.transform.zoom, v);
            }
        }
        function go(t1, i, o, r, n, s, a) {
            const l = t1.context, c = l.gl, h = t1.transform, u = o.paint.get("fill-extrusion-pattern"), _ = u.constantOr(1), d = o.paint.get("fill-extrusion-opacity"), p = [
                o.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                o.paint.get("fill-extrusion-ambient-occlusion-radius")
            ], m = o.layout.get("fill-extrusion-edge-radius"), f = m > 0 && !o.paint.get("fill-extrusion-rounded-roof"), g = f ? 0 : m, v = "globe" === h.projection.name ? e1.fillExtrusionHeightLift() : 0, x = "globe" === h.projection.name, y = x ? e1.globeToMercatorTransition(h.zoom) : 0, b = [
                e1.mercatorXfromLng(h.center.lng),
                e1.mercatorYfromLat(h.center.lat)
            ], w = [];
            x && w.push("PROJECTION_GLOBE_VIEW"), p[0] > 0 && w.push("FAUX_AO"), f && w.push("ZERO_ROOF_RADIUS");
            for (const m of r){
                const r = i.getTile(m), f = r.getBucket(o);
                if (!f || f.projection.name !== h.projection.name) continue;
                const T = f.programConfigurations.get(o.id), E = t1.useProgram(_ ? "fillExtrusionPattern" : "fillExtrusion", T, w);
                if (t1.terrain) {
                    const e1 = t1.terrain;
                    if (t1.style.terrainSetForDrapingOnly()) e1.setupElevationDraw(r, E, {
                        useMeterToDem: !0
                    });
                    else {
                        if (!f.enableTerrain) continue;
                        if (e1.setupElevationDraw(r, E, {
                            useMeterToDem: !0
                        }), vo(l, i, m, f, o, e1), !f.centroidVertexBuffer) {
                            const e1 = E.attributes.a_centroid_pos;
                            void 0 !== e1 && c.vertexAttrib2f(e1, 0, 0);
                        }
                    }
                }
                _ && (t1.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), T.updatePaintBuffers());
                const C = u.constantOr(null);
                if (C && r.imageAtlas) {
                    const e1 = r.imageAtlas.patternPositions[C.toString()];
                    e1 && T.setConstantPatternPositions(e1);
                }
                const M = t1.translatePosMatrix(m.projMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), I = h.projection.createInversionMatrix(h, m.canonical), P = o.paint.get("fill-extrusion-vertical-gradient"), S = _ ? Oi(M, t1, P, d, p, g, m, r, v, y, b, I) : Ri(M, t1, P, d, p, g, m, v, y, b, I);
                t1.prepareDrawProgram(l, E, m.toUnwrapped());
                const D = [];
                t1.terrain && D.push(f.centroidVertexBuffer), x && D.push(f.layoutVertexExtBuffer), E.draw(l, l.gl.TRIANGLES, n, s, a, e1.CullFaceMode.backCCW, S, o.id, f.layoutVertexBuffer, f.indexBuffer, f.segments, o.paint, t1.transform.zoom, T, D);
            }
        }
        function vo(t1, i, o, r, n, s) {
            const a = [
                (t1)=>{
                    let i = t1.canonical.x - 1, o = t1.wrap;
                    return i < 0 && (i = (1 << t1.canonical.z) - 1, o--), new e1.OverscaledTileID(t1.overscaledZ, o, t1.canonical.z, i, t1.canonical.y);
                },
                (t1)=>{
                    let i = t1.canonical.x + 1, o = t1.wrap;
                    return i === 1 << t1.canonical.z && (i = 0, o++), new e1.OverscaledTileID(t1.overscaledZ, o, t1.canonical.z, i, t1.canonical.y);
                },
                (t1)=>new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, (0 === t1.canonical.y ? 1 << t1.canonical.z : t1.canonical.y) - 1),
                (t1)=>new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y === (1 << t1.canonical.z) - 1 ? 0 : t1.canonical.y + 1)
            ], l = (e1)=>{
                const t1 = i.getSource().minzoom, o = (e1)=>{
                    const t1 = i.getTileByID(e1);
                    if (t1 && t1.hasData()) return t1.getBucket(n);
                }, r = [
                    0,
                    -1,
                    1
                ];
                for (const i of r){
                    if (e1.overscaledZ + i < t1) continue;
                    const r = o(e1.calculateScaledKey(e1.overscaledZ + i));
                    if (r) return r;
                }
            }, c = [
                0,
                0,
                0
            ], h = (t1, i)=>(c[0] = Math.min(t1.min.y, i.min.y), c[1] = Math.max(t1.max.y, i.max.y), c[2] = e1.EXTENT - i.min.x > t1.max.x ? i.min.x - e1.EXTENT : t1.max.x, c), u = (t1, i)=>(c[0] = Math.min(t1.min.x, i.min.x), c[1] = Math.max(t1.max.x, i.max.x), c[2] = e1.EXTENT - i.min.y > t1.max.y ? i.min.y - e1.EXTENT : t1.max.y, c), _ = [
                (e1, t1)=>h(e1, t1),
                (e1, t1)=>h(t1, e1),
                (e1, t1)=>u(e1, t1),
                (e1, t1)=>u(t1, e1)
            ], d = new e1.Point(0, 0);
            let p, m, f;
            const g = (t1, i, r, n, a)=>{
                const l = [
                    [
                        n ? r : t1,
                        n ? t1 : r,
                        0
                    ],
                    [
                        n ? r : i,
                        n ? i : r,
                        0
                    ]
                ], c = a < 0 ? e1.EXTENT + a : a, h = [
                    n ? c : (t1 + i) / 2,
                    n ? (t1 + i) / 2 : c,
                    0
                ];
                return 0 === r && a < 0 || 0 !== r && a > 0 ? s.getForTilePoints(f, [
                    h
                ], !0, m) : l.push(h), s.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration();
            };
            for(let t1 = 0; t1 < 4; t1++){
                const i = (t1 < 2 ? 1 : 5) - t1, n = r.borders[t1];
                if (0 === n.length) continue;
                const c = f = a[t1](o), h = l(c);
                if (!(h && h instanceof e1.FillExtrusionBucket && h.enableTerrain)) continue;
                if (r.borderDoneWithNeighborZ[t1] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;
                if (m = s.findDEMTileFor(c), !m || !m.dem) continue;
                if (!p) {
                    const e1 = s.findDEMTileFor(o);
                    if (!e1 || !e1.dem) return;
                    p = e1;
                }
                const u = h.borders[i];
                let v = 0;
                const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;
                if (r.canonical.z === h.canonical.z) {
                    for(let o = 0; o < n.length; o++){
                        const s = r.featuresOnBorder[n[o]], a = s.borders[t1];
                        let l;
                        for(; v < u.length && (l = h.featuresOnBorder[u[v]], !(l.borders[i][1] > a[0] + 3));)x && h.encodeCentroid(void 0, l, !1), v++;
                        if (l && v < u.length) {
                            const o = v;
                            let n = 0;
                            for(; !(l.borders[i][0] > a[1] - 3) && (n++, ++v !== u.length);)l = h.featuresOnBorder[u[v]];
                            if (l = h.featuresOnBorder[u[o]], s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {
                                1 !== n && (v = o), r.encodeCentroid(void 0, s, !1), x && h.encodeCentroid(void 0, l, !1);
                                continue;
                            }
                            const c = _[t1](s, l), p = t1 % 2 ? e1.EXTENT - 1 : 0;
                            d.x = g(c[0], Math.min(e1.EXTENT - 1, c[1]), p, t1 < 2, c[2]), d.y = 0, r.encodeCentroid(d, s, !1), x && h.encodeCentroid(d, l, !1);
                        } else r.encodeCentroid(void 0, s, !1);
                    }
                    r.borderDoneWithNeighborZ[t1] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);
                } else {
                    for (const e1 of n)r.encodeCentroid(void 0, r.featuresOnBorder[e1], !1);
                    if (x) {
                        for (const e1 of u)h.encodeCentroid(void 0, h.featuresOnBorder[e1], !1);
                        h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;
                    }
                    r.borderDoneWithNeighborZ[t1] = h.canonical.z, r.needsCentroidUpdate = !0;
                }
            }
            (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t1);
        }
        const xo = new e1.Color(1, 0, 0, 1), yo = new e1.Color(0, 1, 0, 1), bo = new e1.Color(0, 0, 1, 1), wo = new e1.Color(1, 0, 1, 1), To = new e1.Color(0, 1, 1, 1);
        function Eo(t1, i, o) {
            const r = t1.context, n = t1.transform, s = r.gl, a = "globe" === n.projection.name, l = a ? [
                "PROJECTION_GLOBE_VIEW"
            ] : null;
            let c = o.projMatrix;
            if (a && e1.globeToMercatorTransition(n.zoom) > 0) {
                const t1 = e1.transitionTileAABBinECEF(o.canonical, n), i = e1.globeDenormalizeECEF(t1);
                c = e1.multiply(new Float32Array(16), n.globeMatrix, i), e1.multiply(c, n.projMatrix, c);
            }
            const h = t1.useProgram("debug", null, l), u = i.getTileByID(o.key);
            t1.terrain && t1.terrain.setupElevationDraw(u, h);
            const _ = e1.DepthMode.disabled, d = e1.StencilMode.disabled, p = t1.colorModeForRenderPass(), m = "$debug";
            r.activeTexture.set(s.TEXTURE0), t1.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), a ? u._makeGlobeTileDebugBuffers(t1.context, n) : u._makeDebugTileBoundsBuffers(t1.context, n.projection);
            const f = u._tileDebugBuffer || t1.debugBuffer, g = u._tileDebugIndexBuffer || t1.debugIndexBuffer, v = u._tileDebugSegments || t1.debugSegments;
            h.draw(r, s.LINE_STRIP, _, d, p, e1.CullFaceMode.disabled, Vi(c, e1.Color.red), m, f, g, v, null, null, null, [
                u._globeTileDebugBorderBuffer
            ]);
            const x = u.latestRawTileData, y = Math.floor((x && x.byteLength || 0) / 1024), b = i.getTile(o).tileSize, w = 512 / Math.min(b, 512) * (o.overscaledZ / n.zoom) * .5;
            let T = o.canonical.toString();
            o.overscaledZ !== o.canonical.z && (T += ` => ${o.overscaledZ}`), T += ` ${y}kb`, function(e1, t1) {
                e1.initDebugOverlayCanvas();
                const i = e1.debugOverlayCanvas, o = e1.context.gl, r = e1.debugOverlayCanvas.getContext("2d");
                r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t1, 5, 5), r.strokeText(t1, 5, 5), e1.debugOverlayTexture.update(i), e1.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }(t1, T);
            const E = u._tileDebugTextBuffer || t1.debugBuffer, C = u._tileDebugTextIndexBuffer || t1.quadTriangleIndexBuffer, M = u._tileDebugTextSegments || t1.debugSegments;
            h.draw(r, s.TRIANGLES, _, d, e1.ColorMode.alphaBlended, e1.CullFaceMode.disabled, Vi(c, e1.Color.transparent, w), m, E, C, M, null, null, null, [
                u._globeTileDebugTextBuffer
            ]);
        }
        function Co(e1, t1, i, o) {
            Io(e1, 0, t1 + i / 2, e1.transform.width, i, o);
        }
        function Mo(e1, t1, i, o) {
            Io(e1, t1 - i / 2, 0, i, e1.transform.height, o);
        }
        function Io(t1, i, o, r, n, s) {
            const a = t1.context, l = a.gl;
            l.enable(l.SCISSOR_TEST), l.scissor(i * e1.exported.devicePixelRatio, o * e1.exported.devicePixelRatio, r * e1.exported.devicePixelRatio, n * e1.exported.devicePixelRatio), a.clear({
                color: s
            }), l.disable(l.SCISSOR_TEST);
        }
        const Po = e1.createLayout([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: So } = Po;
        function Do(e1, t1, i, o) {
            e1.emplaceBack(t1, i, o);
        }
        class Lo {
            constructor(t1){
                this.vertexArray = new e1.StructArrayLayout3f12, this.indices = new e1.StructArrayLayout3ui6, Do(this.vertexArray, -1, -1, 1), Do(this.vertexArray, 1, -1, 1), Do(this.vertexArray, -1, 1, 1), Do(this.vertexArray, 1, 1, 1), Do(this.vertexArray, -1, -1, -1), Do(this.vertexArray, 1, -1, -1), Do(this.vertexArray, -1, 1, -1), Do(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, So), this.indexBuffer = t1.createIndexBuffer(this.indices), this.segment = e1.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
        }
        function Ao(t1, i, o, r, n, s) {
            const a = t1.gl, l = i.paint.get("sky-atmosphere-color"), c = i.paint.get("sky-atmosphere-halo-color"), h = i.paint.get("sky-atmosphere-sun-intensity"), u = ((e1, t1, i, o, r)=>({
                    u_matrix_3f: e1,
                    u_sun_direction: t1,
                    u_sun_intensity: i,
                    u_color_tint_r: [
                        o.r,
                        o.g,
                        o.b,
                        o.a
                    ],
                    u_color_tint_m: [
                        r.r,
                        r.g,
                        r.b,
                        r.a
                    ],
                    u_luminance: 5e-5
                }))(e1.fromMat4(e1.create$1(), r), n, h, l, c);
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0), o.draw(t1, a.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, e1.ColorMode.unblended, e1.CullFaceMode.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const zo = e1.createLayout([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class Ro {
            constructor(t1){
                const i = new e1.StructArrayLayout5f20;
                i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
                const o = new e1.StructArrayLayout3ui6;
                o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t1.createVertexBuffer(i, zo.members), this.indexBuffer = t1.createIndexBuffer(o), this.segments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const Oo = {
            symbol: function(t1, i, o, r, n) {
                if ("translucent" !== t1.renderPass) return;
                const s = e1.StencilMode.disabled, a = t1.colorModeForRenderPass();
                o.layout.get("text-variable-anchor") && function(t1, i, o, r, n, s, a) {
                    const l = i.transform, c = "map" === n, h = "map" === s;
                    for (const i of t1){
                        const t1 = r.getTile(i), n = t1.getBucket(o);
                        if (!n || !n.text || !n.text.segments.get().length) continue;
                        const s = e1.evaluateSizeForZoom(n.textSizeData, l.zoom), u = xt(i, n.getProjection(), l), _ = l.calculatePixelsToTileUnitsMatrix(t1), d = et(u, t1.tileID.canonical, h, c, l, n.getProjection(), _), p = "none" !== o.layout.get("icon-text-fit") && n.hasIconData();
                        if (s) {
                            const o = Math.pow(2, l.zoom - t1.tileID.overscaledZ);
                            uo(n, c, h, a, e1.symbolSize, l, d, i, o, s, p);
                        }
                    }
                }(r, t1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), n), 0 !== o.paint.get("icon-opacity").constantOr(1) && po(t1, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), s, a), 0 !== o.paint.get("text-opacity").constantOr(1) && po(t1, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), s, a), i.map.showCollisionBoxes && (lo(t1, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), lo(t1, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const n = o.paint.get("circle-opacity"), s = o.paint.get("circle-stroke-width"), a = o.paint.get("circle-stroke-opacity"), l = void 0 !== o.layout.get("circle-sort-key").constantOr(1);
                if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1))) return;
                const c = t1.context, h = c.gl, u = t1.transform, _ = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), d = e1.StencilMode.disabled, p = t1.colorModeForRenderPass(), m = "globe" === u.projection.name, f = [
                    e1.mercatorXfromLng(u.center.lng),
                    e1.mercatorYfromLat(u.center.lat)
                ], g = [];
                for(let n = 0; n < r.length; n++){
                    const s = r[n], a = i.getTile(s), c = a.getBucket(o);
                    if (!c || c.projection.name !== u.projection.name) continue;
                    const h = c.programConfigurations.get(o.id), _ = Gi(o);
                    m && _.push("PROJECTION_GLOBE_VIEW");
                    const d = t1.useProgram("circle", h, _), p = c.layoutVertexBuffer, v = c.globeExtVertexBuffer, x = c.indexBuffer, y = u.projection.createInversionMatrix(u, s.canonical), b = {
                        programConfiguration: h,
                        program: d,
                        layoutVertexBuffer: p,
                        globeExtVertexBuffer: v,
                        indexBuffer: x,
                        uniformValues: ji(t1, s, a, y, f, o),
                        tile: a
                    };
                    if (l) {
                        const t1 = c.segments.get();
                        for (const i of t1)g.push({
                            segments: new e1.SegmentVector([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: b
                        });
                    } else g.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: b
                    });
                }
                l && g.sort((e1, t1)=>e1.sortKey - t1.sortKey);
                const v = {
                    useDepthForOcclusion: !m
                };
                for (const i of g){
                    const { programConfiguration: r, program: n, layoutVertexBuffer: s, globeExtVertexBuffer: a, indexBuffer: l, uniformValues: m, tile: f } = i.state, g = i.segments;
                    t1.terrain && t1.terrain.setupElevationDraw(f, n, v), t1.prepareDrawProgram(c, n, f.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, _, d, p, e1.CullFaceMode.disabled, m, o.id, s, l, g, o.paint, u.zoom, r, [
                        a
                    ]);
                }
            },
            heatmap: function(t1, i, o, r) {
                if (0 !== o.paint.get("heatmap-opacity")) {
                    if ("offscreen" === t1.renderPass) {
                        const n = t1.context, s = n.gl, a = e1.StencilMode.disabled, l = new e1.ColorMode([
                            s.ONE,
                            s.ONE
                        ], e1.Color.transparent, [
                            !0,
                            !0,
                            !0,
                            !0
                        ]);
                        !function(e1, t1, i, o) {
                            const r = e1.gl, n = t1.width * o, s = t1.height * o;
                            e1.activeTexture.set(r.TEXTURE1), e1.viewport.set([
                                0,
                                0,
                                n,
                                s
                            ]);
                            let a = i.heatmapFbo;
                            if (!a || a && (a.width !== n || a.height !== s)) {
                                a && a.destroy();
                                const t1 = r.createTexture();
                                r.bindTexture(r.TEXTURE_2D, t1), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e1.createFramebuffer(n, s, !1), function(e1, t1, i, o, r, n) {
                                    const s = e1.gl;
                                    s.texImage2D(s.TEXTURE_2D, 0, e1.isWebGL2 && e1.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, r, n, 0, s.RGBA, e1.extRenderToTextureHalfFloat ? e1.isWebGL2 ? s.HALF_FLOAT : e1.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                                }(e1, 0, t1, a, n, s);
                            } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e1.bindFramebuffer.set(a.framebuffer);
                        }(n, t1, o, "globe" === t1.transform.projection.name ? .5 : .25), n.clear({
                            color: e1.Color.transparent
                        });
                        const c = t1.transform, h = "globe" === c.projection.name, u = h ? [
                            "PROJECTION_GLOBE_VIEW"
                        ] : null, _ = h ? e1.CullFaceMode.frontCCW : e1.CullFaceMode.disabled, d = [
                            e1.mercatorXfromLng(c.center.lng),
                            e1.mercatorYfromLat(c.center.lat)
                        ];
                        for(let p = 0; p < r.length; p++){
                            const m = r[p];
                            if (i.hasRenderableParent(m)) continue;
                            const f = i.getTile(m), g = f.getBucket(o);
                            if (!g || g.projection.name !== c.projection.name) continue;
                            const v = g.programConfigurations.get(o.id), x = t1.useProgram("heatmap", v, u), { zoom: y } = t1.transform;
                            t1.terrain && t1.terrain.setupElevationDraw(f, x), t1.prepareDrawProgram(n, x, m.toUnwrapped());
                            const b = c.projection.createInversionMatrix(c, m.canonical);
                            x.draw(n, s.TRIANGLES, e1.DepthMode.disabled, a, l, _, Xi(t1, m, f, b, d, y, o.paint.get("heatmap-intensity")), o.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, o.paint, t1.transform.zoom, v, h ? [
                                g.globeExtVertexBuffer
                            ] : null);
                        }
                        n.viewport.set([
                            0,
                            0,
                            t1.width,
                            t1.height
                        ]);
                    } else "translucent" === t1.renderPass && (t1.context.setColorMode(t1.colorModeForRenderPass()), function(t1, i) {
                        const o = t1.context, r = o.gl, n = i.heatmapFbo;
                        if (!n) return;
                        o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);
                        let s = i.colorRampTexture;
                        s || (s = i.colorRampTexture = new e1.Texture(o, i.colorRamp, r.RGBA)), s.bind(r.LINEAR, r.CLAMP_TO_EDGE), t1.useProgram("heatmapTexture").draw(o, r.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.disabled, ((e1, t1, i, o)=>({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: t1.paint.get("heatmap-opacity")
                            }))(0, i), i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments, i.paint, t1.transform.zoom);
                    }(t1, o));
                }
            },
            line: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const n = o.paint.get("line-opacity"), s = o.paint.get("line-width");
                if (0 === n.constantOr(1) || 0 === s.constantOr(1)) return;
                const a = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), l = t1.colorModeForRenderPass(), c = t1.terrain && t1.terrain.renderingToTexture ? 1 : e1.exported.devicePixelRatio, h = o.paint.get("line-dasharray"), u = h.constantOr(1), _ = o.layout.get("line-cap"), d = o.paint.get("line-pattern"), p = d.constantOr(1), m = o.paint.get("line-gradient"), f = p ? "linePattern" : "line", g = t1.context, v = g.gl, x = ((e1)=>{
                    const t1 = [];
                    Ki(e1) && t1.push("RENDER_LINE_DASH"), e1.paint.get("line-gradient") && t1.push("RENDER_LINE_GRADIENT");
                    const i = e1.paint.get("line-trim-offset");
                    0 === i[0] && 0 === i[1] || t1.push("RENDER_LINE_TRIM_OFFSET");
                    const o = e1.paint.get("line-pattern").constantOr(1), r = 1 !== e1.paint.get("line-opacity").constantOr(1);
                    return !o && r && t1.push("RENDER_LINE_ALPHA_DISCARD"), t1;
                })(o);
                let y = x.includes("RENDER_LINE_ALPHA_DISCARD");
                t1.terrain && t1.terrain.clipOrMaskOverlapStencilType() && (y = !1);
                for (const n of r){
                    const r = i.getTile(n);
                    if (p && !r.patternsLoaded()) continue;
                    const s = r.getBucket(o);
                    if (!s) continue;
                    t1.prepareDrawTile();
                    const b = s.programConfigurations.get(o.id), w = t1.useProgram(f, b, x), T = d.constantOr(null);
                    if (T && r.imageAtlas) {
                        const e1 = r.imageAtlas.patternPositions[T.toString()];
                        e1 && b.setConstantPatternPositions(e1);
                    }
                    const E = h.constantOr(null), C = _.constantOr(null);
                    if (!p && E && C && r.lineAtlas) {
                        const e1 = r.lineAtlas.getDash(E, C);
                        e1 && b.setConstantPatternPositions(e1);
                    }
                    let [M, I] = o.paint.get("line-trim-offset");
                    if ("round" === C || "square" === C) {
                        const e1 = 1;
                        M !== I && (0 === M && (M -= e1), 1 === I && (I += e1));
                    }
                    const P = t1.terrain ? n.projMatrix : null, S = p ? $i(t1, r, o, P, c) : qi(t1, r, o, P, s.lineClipsArray.length, c, [
                        M,
                        I
                    ]);
                    if (m) {
                        const r = s.gradients[o.id];
                        let a = r.texture;
                        if (o.gradientVersion !== r.version) {
                            let l = 256;
                            if (o.stepInterpolant) {
                                const o = i.getSource().maxzoom, r = n.canonical.z === o ? Math.ceil(1 << t1.transform.maxZoom - n.canonical.z) : 1;
                                l = e1.clamp(e1.nextPowerOfTwo(s.maxLineLength / e1.EXTENT * 1024 * r), 256, g.maxTextureSize);
                            }
                            r.gradient = e1.renderColorRamp({
                                expression: o.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: l,
                                image: r.gradient || void 0,
                                clips: s.lineClipsArray
                            }), r.texture ? r.texture.update(r.gradient) : r.texture = new e1.Texture(g, r.gradient, v.RGBA), r.version = o.gradientVersion, a = r.texture;
                        }
                        g.activeTexture.set(v.TEXTURE1), a.bind(o.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE);
                    }
                    u && (g.activeTexture.set(v.TEXTURE0), r.lineAtlasTexture.bind(v.LINEAR, v.REPEAT), b.updatePaintBuffers()), p && (g.activeTexture.set(v.TEXTURE0), r.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), b.updatePaintBuffers()), t1.prepareDrawProgram(g, w, n.toUnwrapped());
                    const D = (i)=>{
                        w.draw(g, v.TRIANGLES, a, i, l, e1.CullFaceMode.disabled, S, o.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, o.paint, t1.transform.zoom, b, [
                            s.layoutVertexBuffer2
                        ]);
                    };
                    if (y) {
                        const i = t1.stencilModeForClipping(n).ref;
                        0 === i && t1.terrain && g.clear({
                            stencil: 0
                        });
                        const o = {
                            func: v.EQUAL,
                            mask: 255
                        };
                        S.u_alpha_discard_threshold = .8, D(new e1.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.INVERT)), S.u_alpha_discard_threshold = 0, D(new e1.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.KEEP));
                    } else D(t1.stencilModeForClipping(n));
                }
                y && (t1.resetStencilClippingMasks(), t1.terrain && g.clear({
                    stencil: 0
                }));
            },
            fill: function(t1, i, o, r) {
                const n = o.paint.get("fill-color"), s = o.paint.get("fill-opacity");
                if (0 === s.constantOr(1)) return;
                const a = t1.colorModeForRenderPass(), l = o.paint.get("fill-pattern"), c = t1.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e1.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";
                if (t1.renderPass === c) {
                    const n = t1.depthModeForSublayer(1, "opaque" === t1.renderPass ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly);
                    fo(t1, i, o, r, n, a, !1);
                }
                if ("translucent" === t1.renderPass && o.paint.get("fill-antialias")) {
                    const n = t1.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, e1.DepthMode.ReadOnly);
                    fo(t1, i, o, r, n, a, !0);
                }
            },
            "fill-extrusion": function(t1, i, o, r) {
                const n = o.paint.get("fill-extrusion-opacity");
                if (0 !== n && "translucent" === t1.renderPass) {
                    const s = new e1.DepthMode(t1.context.gl.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                    if (1 !== n || o.paint.get("fill-extrusion-pattern").constantOr(1)) go(t1, i, o, r, s, e1.StencilMode.disabled, e1.ColorMode.disabled), go(t1, i, o, r, s, t1.stencilModeFor3D(), t1.colorModeForRenderPass()), t1.resetStencilClippingMasks();
                    else {
                        const n = t1.colorModeForRenderPass();
                        go(t1, i, o, r, s, e1.StencilMode.disabled, n);
                    }
                }
            },
            hillshade: function(t1, i, o, r) {
                if ("offscreen" !== t1.renderPass && "translucent" !== t1.renderPass) return;
                const n = t1.context, s = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), a = t1.colorModeForRenderPass(), l = t1.terrain && t1.terrain.renderingToTexture, [c, h] = "translucent" !== t1.renderPass || l ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r);
                for (const r of h){
                    const n = i.getTile(r);
                    if (n.needsHillshadePrepare && "offscreen" === t1.renderPass) fi(t1, n, o, s, e1.StencilMode.disabled, a);
                    else if ("translucent" === t1.renderPass) {
                        const e1 = l && t1.terrain ? t1.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];
                        pi(t1, r, n, o, s, e1, a);
                    }
                }
                n.viewport.set([
                    0,
                    0,
                    t1.width,
                    t1.height
                ]), t1.resetStencilClippingMasks();
            },
            raster: function(t1, i, o, r, n, s) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === o.paint.get("raster-opacity")) return;
                if (!r.length) return;
                const a = t1.context, l = a.gl, c = i.getSource(), h = t1.useProgram("raster"), u = t1.colorModeForRenderPass(), _ = t1.terrain && t1.terrain.renderingToTexture, [d, p] = c instanceof Pe || _ ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r), m = p[p.length - 1].overscaledZ, f = !t1.options.moving;
                for (const r of p){
                    const n = _ ? e1.DepthMode.disabled : t1.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get("raster-opacity") ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly, l.LESS), p = r.toUnwrapped(), g = i.getTile(r);
                    if (_ && (!g || !g.hasData())) continue;
                    const v = _ ? r.projMatrix : t1.transform.calculateProjMatrix(p, f), x = t1.terrain && _ ? t1.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ], y = s ? 0 : o.paint.get("raster-fade-duration");
                    g.registerFadeDuration(y);
                    const b = i.findLoadedParent(r, 0), w = Mi(g, b, i, t1.transform, y);
                    let T, E;
                    t1.terrain && t1.terrain.prepareDrawTile();
                    const C = "nearest" === o.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
                    a.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), a.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [
                        g.tileID.canonical.x * T % 1,
                        g.tileID.canonical.y * T % 1
                    ]) : g.texture.bind(C, l.CLAMP_TO_EDGE), g.texture.useMipmap && a.extTextureFilterAnisotropic && t1.transform.pitch > 20 && l.texParameterf(l.TEXTURE_2D, a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a.extTextureFilterAnisotropicMax);
                    const M = Ji(v, E || [
                        0,
                        0
                    ], T || 1, w, o, c instanceof Pe ? c.perspectiveTransform : [
                        0,
                        0
                    ]);
                    if (t1.prepareDrawProgram(a, h, p), c instanceof Pe) c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, n, e1.StencilMode.disabled, u, e1.CullFaceMode.disabled, M, o.id, c.boundsBuffer, t1.quadTriangleIndexBuffer, c.boundsSegments);
                    else {
                        const { tileBoundsBuffer: i, tileBoundsIndexBuffer: r, tileBoundsSegments: s } = t1.getTileBoundsBuffers(g);
                        h.draw(a, l.TRIANGLES, n, x, u, e1.CullFaceMode.disabled, M, o.id, i, r, s);
                    }
                }
                t1.resetStencilClippingMasks();
            },
            background: function(t1, i, o, r) {
                const n = o.paint.get("background-color"), s = o.paint.get("background-opacity");
                if (0 === s) return;
                const a = t1.context, l = a.gl, c = t1.transform, h = c.tileSize, u = o.paint.get("background-pattern");
                if (t1.isPatternMissing(u)) return;
                const _ = !u && 1 === n.a && 1 === s && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== _) return;
                const d = e1.StencilMode.disabled, p = t1.depthModeForSublayer(0, "opaque" === _ ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly), m = t1.colorModeForRenderPass(), f = t1.useProgram(u ? "backgroundPattern" : "background");
                let g, v = r;
                v || (g = t1.getBackgroundTiles(), v = Object.values(g).map((e1)=>e1.tileID)), u && (a.activeTexture.set(l.TEXTURE0), t1.imageManager.bind(t1.context));
                for (const _ of v){
                    const v = _.toUnwrapped(), x = r ? _.projMatrix : t1.transform.calculateProjMatrix(v);
                    t1.prepareDrawTile();
                    const y = i ? i.getTile(_) : g ? g[_.key] : new e1.Tile(_, h, c.zoom, t1), b = u ? no(x, s, t1, u, {
                        tileID: _,
                        tileSize: h
                    }) : ro(x, s, n);
                    t1.prepareDrawProgram(a, f, v);
                    const { tileBoundsBuffer: w, tileBoundsIndexBuffer: T, tileBoundsSegments: E } = t1.getTileBoundsBuffers(y);
                    f.draw(a, l.TRIANGLES, p, d, m, e1.CullFaceMode.disabled, b, o.id, w, T, E);
                }
            },
            sky: function(t1, i, o) {
                const r = t1.transform, n = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : e1.smoothstep(7, 8, r.zoom), s = o.paint.get("sky-opacity") * n;
                if (0 === s) return;
                const a = t1.context, l = o.paint.get("sky-type"), c = new e1.DepthMode(a.gl.LEQUAL, e1.DepthMode.ReadOnly, [
                    0,
                    1
                ]), h = t1.frameCounter / 1e3 % 1;
                "atmosphere" === l ? "offscreen" === t1.renderPass ? o.needsSkyboxCapture(t1) && (function(t1, i, o, r) {
                    const n = t1.context, s = n.gl;
                    let a = i.skyboxFbo;
                    if (!a) {
                        a = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new Lo(n), i.skyboxTexture = n.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
                        for(let e1 = 0; e1 < 6; ++e1)s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e1, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);
                    }
                    n.bindFramebuffer.set(a.framebuffer), n.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const l = i.getCenter(t1, !0), c = t1.useProgram("skyboxCapture"), h = new Float64Array(16);
                    e1.identity(h), e1.rotateY(h, h, .5 * -Math.PI), Ao(n, i, c, h, l, 0), e1.identity(h), e1.rotateY(h, h, .5 * Math.PI), Ao(n, i, c, h, l, 1), e1.identity(h), e1.rotateX(h, h, .5 * -Math.PI), Ao(n, i, c, h, l, 2), e1.identity(h), e1.rotateX(h, h, .5 * Math.PI), Ao(n, i, c, h, l, 3), e1.identity(h), Ao(n, i, c, h, l, 4), e1.identity(h), e1.rotateY(h, h, Math.PI), Ao(n, i, c, h, l, 5), n.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                }(t1, o), o.markSkyboxValid(t1)) : "sky" === t1.renderPass && function(t1, i, o, r, n) {
                    const s = t1.context, a = s.gl, l = t1.transform, c = t1.useProgram("skybox");
                    s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);
                    const h = ((e1, t1, i, o, r)=>({
                            u_matrix: e1,
                            u_sun_direction: t1,
                            u_cubemap: 0,
                            u_opacity: o,
                            u_temporal_offset: r
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), 0, r, n);
                    t1.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, c, s, h) : "gradient" === l && "sky" === t1.renderPass && function(t1, i, o, r, n) {
                    const s = t1.context, a = s.gl, l = t1.transform, c = t1.useProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new Lo(s)), s.activeTexture.set(a.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new e1.Texture(s, i.colorRamp, a.RGBA)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    const u = ((t1, i, o, r, n)=>({
                            u_matrix: t1,
                            u_color_ramp: 0,
                            u_center_direction: i,
                            u_radius: e1.degToRad(o),
                            u_opacity: r,
                            u_temporal_offset: n
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), i.paint.get("sky-gradient-radius"), r, n);
                    t1.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, c, s, h);
            },
            debug: function(e1, t1, i) {
                for(let o = 0; o < i.length; o++)Eo(e1, t1, i[o]);
            },
            custom: function(t1, i, o, r) {
                const n = t1.context, s = o.implementation;
                if (!t1.transform.projection.unsupportedLayers || !t1.transform.projection.unsupportedLayers.includes("custom") || t1.terrain && (t1.terrain.renderingToTexture || "offscreen" === t1.renderPass) && o.isLayerDraped()) {
                    if ("offscreen" === t1.renderPass) {
                        const i = s.prerender;
                        if (i) {
                            if (t1.setCustomLayerDefaults(), n.setColorMode(t1.colorModeForRenderPass()), "globe" === t1.transform.projection.name) {
                                const o = t1.transform.pointMerc;
                                i.call(s, n.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e1.globeToMercatorTransition(t1.transform.zoom), [
                                    o.x,
                                    o.y
                                ], t1.transform.pixelsPerMeterRatio);
                            } else i.call(s, n.gl, t1.transform.customLayerMatrix());
                            n.setDirty(), t1.setBaseState();
                        }
                    } else if ("translucent" === t1.renderPass) {
                        if (t1.terrain && t1.terrain.renderingToTexture) {
                            const i = s.renderToTile;
                            if (i) {
                                const o = r[0].canonical, a = new e1.MercatorCoordinate(o.x + r[0].wrap * (1 << o.z), o.y, o.z);
                                n.setDepthMode(e1.DepthMode.disabled), n.setStencilMode(e1.StencilMode.disabled), n.setColorMode(t1.colorModeForRenderPass()), t1.setCustomLayerDefaults(), i.call(s, n.gl, a), n.setDirty(), t1.setBaseState();
                            }
                            return;
                        }
                        t1.setCustomLayerDefaults(), n.setColorMode(t1.colorModeForRenderPass()), n.setStencilMode(e1.StencilMode.disabled);
                        const i = "3d" === s.renderingMode ? new e1.DepthMode(t1.context.gl.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly);
                        if (n.setDepthMode(i), "globe" === t1.transform.projection.name) {
                            const i = t1.transform.pointMerc;
                            s.render(n.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e1.globeToMercatorTransition(t1.transform.zoom), [
                                i.x,
                                i.y
                            ], t1.transform.pixelsPerMeterRatio);
                        } else s.render(n.gl, t1.transform.customLayerMatrix());
                        n.setDirty(), t1.setBaseState(), n.bindFramebuffer.set(null);
                    }
                } else e1.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            }
        };
        class Bo {
            constructor(t1, i, o = !1){
                this.context = new Ee(t1, o), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e1.SourceCache.maxUnderzooming + e1.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
            }
            updateTerrain(e1, t1) {
                const i = !!e1 && !!e1.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new Di(this, e1));
                const o = this._terrain;
                this.transform.elevation = i ? o : null, o.update(e1, this.transform, t1);
            }
            _updateFog(e1) {
                const t1 = e1.fog;
                if (!t1 || "globe" === this.transform.projection.name || t1.getOpacity(this.transform.pitch) < 1 || t1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                const [i, o] = t1.getFovAdjustedRange(this.transform._fov);
                if (i > o) return void (this.transform.fogCullDistSq = null);
                const r = i + .78 * (o - i);
                this.transform.fogCullDistSq = r * r;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
            }
            resize(t1, i) {
                if (this.width = t1 * e1.exported.devicePixelRatio, this.height = i * e1.exported.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e1 of this.style.order)this.style._layers[e1].resize();
            }
            setup() {
                const t1 = this.context, i = new e1.StructArrayLayout2i4;
                i.emplaceBack(0, 0), i.emplaceBack(e1.EXTENT, 0), i.emplaceBack(0, e1.EXTENT), i.emplaceBack(e1.EXTENT, e1.EXTENT), this.tileExtentBuffer = t1.createVertexBuffer(i, e1.posAttributes.members), this.tileExtentSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const o = new e1.StructArrayLayout2i4;
                o.emplaceBack(0, 0), o.emplaceBack(e1.EXTENT, 0), o.emplaceBack(0, e1.EXTENT), o.emplaceBack(e1.EXTENT, e1.EXTENT), this.debugBuffer = t1.createVertexBuffer(o, e1.posAttributes.members), this.debugSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 5);
                const r = new e1.StructArrayLayout2i4;
                r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t1.createVertexBuffer(r, e1.posAttributes.members), this.viewportSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const n = new e1.StructArrayLayout4i8;
                n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e1.EXTENT, 0, e1.EXTENT, 0), n.emplaceBack(0, e1.EXTENT, 0, e1.EXTENT), n.emplaceBack(e1.EXTENT, e1.EXTENT, e1.EXTENT, e1.EXTENT), this.mercatorBoundsBuffer = t1.createVertexBuffer(n, e1.boundsAttributes.members), this.mercatorBoundsSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const s = new e1.StructArrayLayout3ui6;
                s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t1.createIndexBuffer(s);
                const a = new e1.StructArrayLayout1ui2;
                for (const e1 of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])a.emplaceBack(e1);
                this.debugIndexBuffer = t1.createIndexBuffer(a), this.emptyTexture = new e1.Texture(t1, new e1.RGBAImage({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t1.gl.RGBA), this.identityMat = e1.create();
                const l = this.context.gl;
                this.stencilClearMode = new e1.StencilMode({
                    func: l.ALWAYS,
                    mask: 0
                }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e1.window.performance.now()), this.atmosphereBuffer = new Ro(this.context);
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e1) {
                return e1._makeTileBoundsBuffers(this.context, this.transform.projection), e1._tileBoundsBuffer ? {
                    tileBoundsBuffer: e1._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e1._tileBoundsIndexBuffer,
                    tileBoundsSegments: e1._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const t1 = this.context, i = t1.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t1, i.TRIANGLES, e1.DepthMode.disabled, this.stencilClearMode, e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ci(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(t1, i, o) {
                if (!i || this.currentStencilSource === i.id || !t1.isTileClipped() || !o || 0 === o.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e1 = !1;
                    for (const t1 of o)if (void 0 === this._tileClippingMaskIDs[t1.key]) {
                        e1 = !0;
                        break;
                    }
                    if (!e1) return;
                }
                this.currentStencilSource = i.id;
                const r = this.context, n = r.gl;
                this.nextStencilID + o.length > 256 && this.clearStencil(), r.setColorMode(e1.ColorMode.disabled), r.setDepthMode(e1.DepthMode.disabled);
                const s = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const t1 of o){
                    const o = i.getTile(t1), a = this._tileClippingMaskIDs[t1.key] = this.nextStencilID++, { tileBoundsBuffer: l, tileBoundsIndexBuffer: c, tileBoundsSegments: h } = this.getTileBoundsBuffers(o);
                    s.draw(r, n.TRIANGLES, e1.DepthMode.disabled, new e1.StencilMode({
                        func: n.ALWAYS,
                        mask: 0
                    }, a, 255, n.KEEP, n.KEEP, n.REPLACE), e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ci(t1.projMatrix), "$clipping", l, c, h);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const t1 = this.nextStencilID++, i = this.context.gl;
                return new e1.StencilMode({
                    func: i.NOTEQUAL,
                    mask: 255
                }, t1, 255, i.KEEP, i.KEEP, i.REPLACE);
            }
            stencilModeForClipping(t1) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t1);
                const i = this.context.gl;
                return new e1.StencilMode({
                    func: i.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[t1.key], 0, i.KEEP, i.KEEP, i.REPLACE);
            }
            stencilConfigForOverlap(t1) {
                const i = this.context.gl, o = t1.sort((e1, t1)=>t1.overscaledZ - e1.overscaledZ), r = o[o.length - 1].overscaledZ, n = o[0].overscaledZ - r + 1;
                if (n > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();
                    const t1 = {};
                    for(let o = 0; o < n; o++)t1[o + r] = new e1.StencilMode({
                        func: i.GEQUAL,
                        mask: 255
                    }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
                    return this.nextStencilID += n, [
                        t1,
                        o
                    ];
                }
                return [
                    {
                        [r]: e1.StencilMode.disabled
                    },
                    o
                ];
            }
            colorModeForRenderPass() {
                const t1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new e1.ColorMode([
                        t1.CONSTANT_COLOR,
                        t1.ONE
                    ], new e1.Color(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? e1.ColorMode.unblended : e1.ColorMode.alphaBlended;
            }
            depthModeForSublayer(t1, i, o) {
                if (!this.opaquePassEnabledForLayer()) return e1.DepthMode.disabled;
                const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t1) * this.depthEpsilon;
                return new e1.DepthMode(o || this.context.gl.LEQUAL, i, [
                    r,
                    r
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            render(t1, i) {
                this.style = t1, this.options = i, this.imageManager = t1.imageManager, this.glyphManager = t1.glyphManager, this.symbolFadeChange = t1.placement.symbolFadeChange(e1.exported.now()), this.imageManager.beginFrame();
                const o = this.style.order, r = this.style._sourceCaches;
                for(const e1 in r){
                    const t1 = r[e1];
                    t1.used && t1.prepare(this.context);
                }
                const n = {}, s = {}, a = {};
                for(const e1 in r){
                    const t1 = r[e1];
                    n[e1] = t1.getVisibleCoordinates(), s[e1] = n[e1].slice().reverse(), a[e1] = t1.getVisibleCoordinates(!0).reverse();
                }
                this.opaquePassCutoff = 1 / 0;
                for(let e1 = 0; e1 < o.length; e1++)if (this.style._layers[o[e1]].is3D()) {
                    this.opaquePassCutoff = e1;
                    break;
                }
                if (this.terrain && (this.terrain.updateTileBinding(a), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e1.GlobeSharedBuffers(this.context)), !e1.isMapAuthenticated(this.context.gl)) return;
                this.renderPass = "offscreen";
                for (const e1 of o){
                    const i = this.style._layers[e1], o = t1._getLayerSourceCache(i);
                    if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;
                    const r = o ? s[o.id] : void 0;
                    ("custom" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);
                }
                this.depthRangeFor3D = [
                    0,
                    1 - (t1.order.length + 2) * this.numSublayers * this.depthEpsilon
                ];
                const l = this.terrain;
                if (l && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.clear({
                    color: i.showOverdrawInspector ? e1.Color.black : e1.Color.transparent,
                    depth: 1
                }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for(this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--){
                    const e1 = this.style._layers[o[this.currentLayer]], i = t1._getLayerSourceCache(e1);
                    if (e1.isSky()) continue;
                    const r = i ? s[i.id] : void 0;
                    this._renderTileClippingMasks(e1, i, r), this.renderLayer(this, i, e1, r);
                }
                if (this.style.fog && this.transform.projection.supportsFog && function(t1, i) {
                    const o = t1.context, r = o.gl, n = t1.transform, s = new e1.DepthMode(r.LEQUAL, e1.DepthMode.ReadOnly, [
                        0,
                        1
                    ]), a = t1.useProgram("globeAtmosphere", null, "globe" === n.projection.name ? [
                        "PROJECTION_GLOBE_VIEW",
                        "FOG"
                    ] : [
                        "FOG"
                    ]), l = e1.globeToMercatorTransition(n.zoom), c = i.properties.get("color").toArray01(), h = i.properties.get("high-color").toArray01(), u = i.properties.get("space-color").toArray01PremultipliedAlpha(), _ = e1.identity$1([]);
                    e1.rotateY$1(_, _, -e1.degToRad(n._center.lng)), e1.rotateX$1(_, _, e1.degToRad(n._center.lat)), e1.rotateZ$1(_, _, n.angle), e1.rotateX$1(_, _, -n._pitch);
                    const d = e1.fromQuat(new Float32Array(16), _), p = e1.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25), m = 5e-4, f = e1.mapValue(i.properties.get("horizon-blend"), 0, 1, m, .25), g = e1.globeUseCustomAntiAliasing(t1, o, n) && f === m ? n.worldSize / (2 * Math.PI * 1.025) - 1 : n.globeRadius, v = t1.frameCounter / 1e3 % 1, x = e1.length(n.globeCenterInViewSpace), y = Math.sqrt(Math.pow(x, 2) - Math.pow(g, 2)), b = Math.acos(y / x), w = ((t1, i, o, r, n, s, a, l, c, h, u, _, d, p)=>({
                            u_frustum_tl: t1,
                            u_frustum_tr: i,
                            u_frustum_br: o,
                            u_frustum_bl: r,
                            u_horizon: n,
                            u_transition: s,
                            u_fadeout_range: a,
                            u_color: l,
                            u_high_color: c,
                            u_space_color: h,
                            u_star_intensity: u,
                            u_star_size: 5 * e1.exported.devicePixelRatio,
                            u_star_density: 0,
                            u_temporal_offset: _,
                            u_horizon_angle: d,
                            u_rotation_matrix: p
                        }))(n.frustumCorners.TL, n.frustumCorners.TR, n.frustumCorners.BR, n.frustumCorners.BL, n.frustumCorners.horizon, l, f, c, h, u, p, v, b, d);
                    t1.prepareDrawProgram(o, a);
                    const T = t1.atmosphereBuffer;
                    T && a.draw(o, r.TRIANGLES, s, e1.StencilMode.disabled, e1.ColorMode.alphaBlended, e1.CullFaceMode.backCW, w, "skybox", T.vertexBuffer, T.indexBuffer, T.segments);
                }(this, this.style.fog), this.renderPass = "sky", (e1.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for(this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++){
                    const e1 = this.style._layers[o[this.currentLayer]], i = t1._getLayerSourceCache(e1);
                    e1.isSky() && this.renderLayer(this, i, e1, i ? s[i.id] : void 0);
                }
                for(this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length;){
                    const e1 = this.style._layers[o[this.currentLayer]], i = t1._getLayerSourceCache(e1);
                    if (e1.isSky()) {
                        ++this.currentLayer;
                        continue;
                    }
                    if (this.terrain && this.style.isLayerDraped(e1)) {
                        if (e1.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue;
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                        continue;
                    }
                    const r = i ? ("symbol" === e1.type ? a : s)[i.id] : void 0;
                    this._renderTileClippingMasks(e1, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e1, r), ++this.currentLayer;
                }
                if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                    let i = null;
                    e1.values(this.style._layers).forEach((e1)=>{
                        const o = t1._getLayerSourceCache(e1);
                        o && !e1.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                    }), i && this.options.showTileBoundaries && Oo.debug(this, i, i.getVisibleCoordinates());
                }
                this.options.showPadding && function(e1) {
                    const t1 = e1.transform.padding;
                    Co(e1, e1.transform.height - (t1.top || 0), 3, xo), Co(e1, t1.bottom || 0, 3, yo), Mo(e1, t1.left || 0, 3, bo), Mo(e1, e1.transform.width - (t1.right || 0), 3, wo);
                    const i = e1.transform.centerPoint;
                    !function(e1, t1, i, o) {
                        Io(e1, t1 - 1, i - 10, 2, 20, o), Io(e1, t1 - 10, i - 1, 20, 2, o);
                    }(e1, i.x, e1.transform.height - i.y, To);
                }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e1.window.performance.now()), this.saveCanvasCopy());
            }
            renderLayer(e1, t1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), (!e1.transform.projection.unsupportedLayers || !e1.transform.projection.unsupportedLayers.includes(i.type) || e1.terrain && "custom" === i.type) && Oo[i.type](e1, t1, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e1) {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery;
                let i = this.gpuTimers[e1.id];
                i || (i = this.gpuTimers[e1.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: t1.createQueryEXT()
                }), i.calls++, t1.beginQueryEXT(t1.TIME_ELAPSED_EXT, i.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e1 = this.context.extTimerQuery, t1 = e1.createQueryEXT();
                    this.deferredRenderGpuTimeQueries.push(t1), e1.beginQueryEXT(e1.TIME_ELAPSED_EXT, t1);
                }
            }
            gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender) return;
                const e1 = this.context.extTimerQuery;
                e1.endQueryEXT(e1.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const e1 = this.context.extTimerQuery;
                e1.endQueryEXT(e1.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e1 = this.gpuTimers;
                return this.gpuTimers = {}, e1;
            }
            collectDeferredRenderGpuQueries() {
                const e1 = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e1;
            }
            queryGpuTimers(e1) {
                const t1 = {};
                for(const i in e1){
                    const o = e1[i], r = this.context.extTimerQuery, n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;
                    r.deleteQueryEXT(o.query), t1[i] = n;
                }
                return t1;
            }
            queryGpuTimeDeferredRender(e1) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t1 = this.context.extTimerQuery;
                let i = 0;
                for (const o of e1)i += t1.getQueryObjectEXT(o, t1.QUERY_RESULT_EXT) / 1e6, t1.deleteQueryEXT(o);
                return i;
            }
            translatePosMatrix(t1, i, o, r, n) {
                if (!o[0] && !o[1]) return t1;
                const s = n ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                if (s) {
                    const e1 = Math.sin(s), t1 = Math.cos(s);
                    o = [
                        o[0] * t1 - o[1] * e1,
                        o[0] * e1 + o[1] * t1
                    ];
                }
                const a = [
                    n ? o[0] : D(i, o[0], this.transform.zoom),
                    n ? o[1] : D(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return e1.translate(l, t1, a), l;
            }
            saveTileTexture(e1) {
                const t1 = this._tileTextures[e1.size[0]];
                t1 ? t1.push(e1) : this._tileTextures[e1.size[0]] = [
                    e1
                ];
            }
            getTileTexture(e1) {
                const t1 = this._tileTextures[e1];
                return t1 && t1.length > 0 ? t1.pop() : null;
            }
            isPatternMissing(e1) {
                return null === e1 || void 0 !== e1 && !this.imageManager.getPattern(e1.toString());
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
            }
            currentGlobalDefines() {
                const e1 = this.terrain && this.terrain.renderingToTexture, t1 = this.terrain && 0 === this.terrain.exaggeration(), i = this.style && this.style.fog, o = [];
                return this.terrainRenderModeElevated() && o.push("TERRAIN"), "globe" === this.transform.projection.name && o.push("GLOBE"), t1 && o.push("ZERO_EXAGGERATION"), i && !e1 && 0 !== i.getOpacity(this.transform.pitch) && o.push("FOG"), e1 && o.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o.push("OVERDRAW_INSPECTOR"), o;
            }
            useProgram(e1, t1, i) {
                this.cache = this.cache || {};
                const o = i || [], r = this.currentGlobalDefines().concat(o), n = Li.cacheKey(ci[e1], e1, r, t1);
                return this.cache[n] || (this.cache[n] = new Li(this.context, e1, ci[e1], t1, so[e1], r)), this.cache[n];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e1 = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e1.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e1.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e1.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            prepareDrawProgram(t1, i, o) {
                if (this.terrain && this.terrain.renderingToTexture) return;
                const r = this.style.fog;
                if (r) {
                    const n = r.getOpacity(this.transform.pitch), s = ((t1, i, o, r, n, s, a, l, c, h, u)=>{
                        const _ = t1.transform, d = i.properties.get("color").toArray01();
                        d[3] = r;
                        const p = t1.frameCounter / 1e3 % 1;
                        return {
                            u_fog_matrix: o ? _.calculateFogTileMatrix(o) : t1.identityMat,
                            u_fog_range: i.getFovAdjustedRange(_._fov),
                            u_fog_color: d,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_temporal_offset: p,
                            u_frustum_tl: n,
                            u_frustum_tr: s,
                            u_frustum_br: a,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: u,
                            u_globe_transition: e1.globeToMercatorTransition(_.zoom),
                            u_is_globe: +("globe" === _.projection.name)
                        };
                    })(this, r, o, n, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e1.exported.devicePixelRatio,
                        this.transform.height * e1.exported.devicePixelRatio
                    ]);
                    i.setFogUniformValues(t1, s);
                }
            }
            setTileLoadedFlag(e1) {
                this.tileLoaded = e1;
            }
            saveCanvasCopy() {
                const e1 = this.canvasCopy();
                e1 && (this.frameCopies.push(e1), this.tileLoaded = !1);
            }
            canvasCopy() {
                const e1 = this.context.gl, t1 = e1.createTexture();
                return e1.bindTexture(e1.TEXTURE_2D, t1), e1.copyTexImage2D(e1.TEXTURE_2D, 0, e1.RGBA, 0, 0, e1.drawingBufferWidth, e1.drawingBufferHeight, 0), t1;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e1 = this.style && this.style.fog;
                return !!e1 && 0 !== e1.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const t1 = this._backgroundTiles, i = this._backgroundTiles = {}, o = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const r of o)i[r.key] = t1[r.key] || new e1.Tile(r, 512, this.transform.tileZoom, this);
                return i;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
        }
        class ko {
            constructor(e1 = 0, t1 = 0, i = 0, o = 0){
                if (isNaN(e1) || e1 < 0 || isNaN(t1) || t1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e1, this.bottom = t1, this.left = i, this.right = o;
            }
            interpolate(t1, i, o) {
                return null != i.top && null != t1.top && (this.top = e1.number(t1.top, i.top, o)), null != i.bottom && null != t1.bottom && (this.bottom = e1.number(t1.bottom, i.bottom, o)), null != i.left && null != t1.left && (this.left = e1.number(t1.left, i.left, o)), null != i.right && null != t1.right && (this.right = e1.number(t1.right, i.right, o)), this;
            }
            getCenter(t1, i) {
                const o = e1.clamp((this.left + t1 - this.right) / 2, 0, t1), r = e1.clamp((this.top + i - this.bottom) / 2, 0, i);
                return new e1.Point(o, r);
            }
            equals(e1) {
                return this.top === e1.top && this.bottom === e1.bottom && this.left === e1.left && this.right === e1.right;
            }
            clone() {
                return new ko(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        function Fo(t1, i) {
            const o = e1.getColumn(t1, 3);
            e1.fromQuat(t1, i), e1.setColumn(t1, 3, o);
        }
        function Uo(t1, i) {
            const o = e1.identity$1([]);
            return e1.rotateZ$1(o, o, -i), e1.rotateX$1(o, o, -t1), o;
        }
        function No(t1, i) {
            const o = [
                t1[0],
                t1[1],
                0
            ], r = [
                i[0],
                i[1],
                0
            ];
            if (e1.length(o) >= 1e-15) {
                const t1 = e1.normalize([], o);
                e1.scale$2(r, t1, e1.dot(r, t1)), i[0] = r[0], i[1] = r[1];
            }
            const n = e1.cross([], i, t1);
            if (e1.len(n) < 1e-15) return null;
            const s = Math.atan2(-n[1], n[0]);
            return Uo(Math.atan2(Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]), -t1[2]), s);
        }
        class jo {
            constructor(e1, t1){
                this.position = e1, this.orientation = t1;
            }
            get position() {
                return this._position;
            }
            set position(t1) {
                if (t1) {
                    const i = t1 instanceof e1.MercatorCoordinate ? t1 : new e1.MercatorCoordinate(t1[0], t1[1], t1[2]);
                    this._renderWorldCopies && (i.x = e1.wrap(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }
            lookAtPoint(t1, i) {
                if (this.orientation = null, !this.position) return;
                const o = this.position, r = this._elevation ? this._elevation.getAtPointOrZero(e1.MercatorCoordinate.fromLngLat(t1)) : 0, n = e1.MercatorCoordinate.fromLngLat(t1, r), s = [
                    n.x - o.x,
                    n.y - o.y,
                    n.z - o.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = No(s, i);
            }
            setPitchBearing(t1, i) {
                this.orientation = Uo(e1.degToRad(t1), e1.degToRad(-i));
            }
        }
        class Go {
            constructor(t1, i){
                this._transform = e1.identity([]), this.orientation = i, this.position = t1;
            }
            get mercatorPosition() {
                const t1 = this.position;
                return new e1.MercatorCoordinate(t1[0], t1[1], t1[2]);
            }
            get position() {
                const t1 = e1.getColumn(this._transform, 3);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            set position(t1) {
                var i;
                t1 && e1.setColumn(this._transform, 3, [
                    (i = t1)[0],
                    i[1],
                    i[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t1) {
                this._orientation = t1 || e1.identity$1([]), t1 && Fo(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e1 = this.forward(), t1 = this.right();
                return {
                    bearing: Math.atan2(-t1[1], t1[0]),
                    pitch: Math.atan2(Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]), -e1[2])
                };
            }
            setPitchBearing(e1, t1) {
                this._orientation = Uo(e1, t1), Fo(this._transform, this._orientation);
            }
            forward() {
                const t1 = e1.getColumn(this._transform, 2);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            up() {
                const t1 = e1.getColumn(this._transform, 1);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            right() {
                const t1 = e1.getColumn(this._transform, 0);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            getCameraToWorld(t1, i) {
                const o = new Float64Array(16);
                return e1.invert(o, this.getWorldToCamera(t1, i)), o;
            }
            getWorldToCameraPosition(t1, i, o) {
                const r = this.position;
                e1.scale$2(r, r, -t1);
                const n = new Float64Array(16);
                return e1.fromScaling(n, [
                    o,
                    o,
                    o
                ]), e1.translate(n, n, r), n[10] *= i, n;
            }
            getWorldToCamera(t1, i) {
                const o = new Float64Array(16), r = new Float64Array(4), n = this.position;
                return e1.conjugate(r, this._orientation), e1.scale$2(n, n, -t1), e1.fromQuat(o, r), e1.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }
            getCameraToClipPerspective(t1, i, o, r) {
                const n = new Float64Array(16);
                return e1.perspective(n, t1, i, o, r), n;
            }
            getDistanceToElevation(t1, i = !1) {
                const o = 0 === t1 ? 0 : e1.mercatorZfromAltitude(t1, i ? e1.latFromMercatorY(this.position[1]) : this.position[1]), r = this.forward();
                return (o - this.position[2]) / r[2];
            }
            clone() {
                return new Go([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        function Zo(t1, i) {
            const o = Wo(t1.projection, t1.zoom, t1.width, t1.height), r = function(t1, i, o, r, n) {
                const s = new e1.LngLat(o.lng - 180 * Xo, o.lat), a = new e1.LngLat(o.lng + 180 * Xo, o.lat), l = t1.project(s.lng, s.lat), c = t1.project(a.lng, a.lat), h = -Math.atan2(c.y - l.y, c.x - l.x), u = e1.MercatorCoordinate.fromLngLat(o);
                u.y = e1.clamp(u.y, -1 + Xo, 1 - Xo);
                const _ = u.toLngLat(), d = t1.project(_.lng, _.lat), p = e1.MercatorCoordinate.fromLngLat(_);
                p.x += Xo;
                const m = p.toLngLat(), f = t1.project(m.lng, m.lat), g = $o(f.x - d.x, f.y - d.y, h), v = e1.MercatorCoordinate.fromLngLat(_);
                v.y += Xo;
                const x = v.toLngLat(), y = t1.project(x.lng, x.lat), b = $o(y.x - d.x, y.y - d.y, h), w = Math.abs(g.x) / Math.abs(b.y), T = e1.identity([]);
                e1.rotateZ(T, T, -h * (1 - (n ? 0 : r)));
                const E = e1.identity([]);
                return e1.scale(E, E, [
                    1,
                    1 - (1 - w) * r,
                    1
                ]), E[4] = -b.x / b.y * r, e1.rotateZ(E, E, h), e1.multiply(E, T, E), E;
            }(t1.projection, 0, t1.center, o, i), n = Vo(t1);
            return e1.scale(r, r, [
                n,
                n,
                1
            ]), r;
        }
        function Vo(t1) {
            const i = t1.projection, o = Wo(t1.projection, t1.zoom, t1.width, t1.height), r = qo(i, t1.center), n = qo(i, e1.LngLat.convert(i.center));
            return Math.pow(2, r * o + (1 - o) * n);
        }
        function Wo(t1, i, o, r, n = 1 / 0) {
            const s = t1.range;
            if (!s) return 0;
            const a = Math.min(n, Math.max(o, r)), l = Math.log(a / 1024) / Math.LN2;
            return e1.smoothstep(s[0] + l, s[1] + l, i);
        }
        const Xo = 1 / 4e4;
        function qo(t1, i) {
            const o = e1.clamp(i.lat, -e1.MAX_MERCATOR_LATITUDE, e1.MAX_MERCATOR_LATITUDE), r = new e1.LngLat(i.lng - 180 * Xo, o), n = new e1.LngLat(i.lng + 180 * Xo, o), s = t1.project(r.lng, o), a = t1.project(n.lng, o), l = e1.MercatorCoordinate.fromLngLat(r), c = e1.MercatorCoordinate.fromLngLat(n), h = a.x - s.x, u = a.y - s.y, _ = c.x - l.x, d = c.y - l.y, p = Math.sqrt((_ * _ + d * d) / (h * h + u * u));
            return Math.log(p) / Math.LN2;
        }
        function $o(e1, t1, i) {
            const o = Math.cos(i), r = Math.sin(i);
            return {
                x: e1 * o - t1 * r,
                y: e1 * r + t1 * o
            };
        }
        class Ho {
            constructor(t1, i, o, r, n, s, a){
                this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t1 || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(s), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e1.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ko, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Go, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._horizonShift = .1;
            }
            clone() {
                const e1 = new Ho(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
                return e1._elevation = this._elevation, e1._centerAltitude = this._centerAltitude, e1._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e1.tileSize = this.tileSize, e1.mercatorFromTransition = this.mercatorFromTransition, e1.width = this.width, e1.height = this.height, e1.cameraElevationReference = this.cameraElevationReference, e1._center = this._center, e1._setZoom(this.zoom), e1._seaLevelZoom = this._seaLevelZoom, e1.angle = this.angle, e1._fov = this._fov, e1._pitch = this._pitch, e1._nearZ = this._nearZ, e1._farZ = this._farZ, e1._averageElevation = this._averageElevation, e1._unmodified = this._unmodified, e1._edgeInsets = this._edgeInsets.clone(), e1._camera = this._camera.clone(), e1._calcMatrices(), e1.freezeTileCoverage = this.freezeTileCoverage, e1.frustumCorners = this.frustumCorners, e1;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e1) {
                this._elevation !== e1 && (this._elevation = e1, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            updateElevation(e1, t1 = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e1 || i) && this._constrainCamera(t1), this._calcMatrices();
            }
            getProjection() {
                return e1.pick(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(i) {
                this.projectionOptions = i || {
                    name: "mercator"
                };
                const o = this.projection ? this.getProjection() : void 0;
                this.projection = e1.getProjection(this.projectionOptions);
                const r = !t1(o, this.getProjection());
                return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;
            }
            setMercatorFromTransition() {
                const t1 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e1.getProjection({
                    name: "mercator"
                });
                const i = t1 !== this.projection.name;
                return i && this._calcMatrices(), i;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e1) {
                this._minZoom !== e1 && (this._minZoom = e1, this.zoom = Math.max(this.zoom, e1));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e1) {
                this._maxZoom !== e1 && (this._maxZoom = e1, this.zoom = Math.min(this.zoom, e1));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e1) {
                this._minPitch !== e1 && (this._minPitch = e1, this.pitch = Math.max(this.pitch, e1));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e1) {
                this._maxPitch !== e1 && (this._maxPitch = e1, this.pitch = Math.min(this.pitch, e1));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e1) {
                void 0 === e1 ? e1 = !0 : null === e1 && (e1 = !1), this._renderWorldCopies = e1;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e1 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e1));
            }
            get cameraWorldSize() {
                const e1 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e1));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e1.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e1.Point(this.width, this.height);
            }
            get bearing() {
                return e1.wrap(this.rotation, -180, 180);
            }
            set bearing(e1) {
                this.rotation = e1;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t1) {
                const i = -t1 * Math.PI / 180;
                var o;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e1.ARRAY_TYPE(4), e1.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function(e1, t1, i) {
                    var o = t1[0], r = t1[1], n = t1[2], s = t1[3], a = Math.sin(i), l = Math.cos(i);
                    e1[0] = o * l + n * a, e1[1] = r * l + s * a, e1[2] = o * -a + n * l, e1[3] = r * -a + s * l;
                }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t1) {
                const i = e1.clamp(t1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fov() {
                return this._fov / Math.PI * 180;
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e1 = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e1);
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = e1.degToRad(t1), this._calcMatrices());
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e1) {
                this._averageElevation = e1, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e1) {
                const t1 = Math.min(Math.max(e1, this.minZoom), this.maxZoom);
                this._zoom !== t1 && (this._unmodified = !1, this._setZoom(t1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e1) {
                this._zoom = e1, this.scale = this.zoomScale(e1), this.tileZoom = Math.floor(e1), this.zoomFraction = e1 - this.tileZoom;
            }
            _updateCameraOnTerrain() {
                if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const e1 = this._elevation;
                this._centerAltitude = e1.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e1.exaggeration(), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t1 = this._elevation, i = [
                    [
                        .5,
                        .2
                    ],
                    [
                        .3,
                        .5
                    ],
                    [
                        .5,
                        .5
                    ],
                    [
                        .7,
                        .5
                    ],
                    [
                        .5,
                        .8
                    ]
                ], o = this.horizonLineFromTop();
                let r = 0, n = 0;
                for(let s = 0; s < i.length; s++){
                    const a = new e1.Point(i[s][0] * this.width, o + i[s][1] * (this.height - o)), l = t1.pointCoordinate(a);
                    if (!l) continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    r += l[3] * c, n += c;
                }
                return 0 === n ? NaN : r / n;
            }
            get center() {
                return this._center;
            }
            set center(e1) {
                e1.lat === this._center.lat && e1.lng === this._center.lng || (this._unmodified = !1, this._center = e1, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e1 = this._seaLevelZoom, t1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i = this.pixelsPerMeter / this.worldSize * t1, o = this._mercatorZfromZoom(e1), r = this._mercatorZfromZoom(this._maxZoom), n = Math.max(o - i, r);
                this._setZoom(this._zoomFromMercatorZ(n));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e1) {
                this._edgeInsets.equals(e1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e1, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t1) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t1.toAltitude()));
                let o;
                o = t1.z < this._camera.position[2] ? [
                    i.x,
                    i.y,
                    i.z
                ] : [
                    t1.x,
                    t1.y,
                    t1.z
                ];
                const r = e1.length(e1.sub([], this._camera.position, o));
                return e1.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t1) {
                if (!this.height) return;
                if (!t1.position && !t1.orientation) return;
                this._updateCameraState();
                let i = !1;
                if (t1.orientation && !e1.exactEquals(t1.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t1.orientation)), t1.position) {
                    const o = [
                        t1.position.x,
                        t1.position.y,
                        t1.position.z
                    ];
                    e1.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }
                i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t1 = this._camera.position, i = new jo;
                return i.position = new e1.MercatorCoordinate(t1[0], t1[1], t1[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }
            _setCameraOrientation(t1) {
                if (!e1.length$1(t1)) return !1;
                e1.normalize$1(t1, t1);
                const i = e1.transformQuat([], [
                    0,
                    0,
                    -1
                ], t1), o = e1.transformQuat([], [
                    0,
                    -1,
                    0
                ], t1);
                if (o[2] < 0) return !1;
                const r = No(i, o);
                return !!r && (this._camera.orientation = r, !0);
            }
            _setCameraPosition(t1) {
                const i = this.zoomScale(this.minZoom) * this.tileSize, o = this.zoomScale(this.maxZoom) * this.tileSize, r = this.cameraToCenterDistance;
                t1[2] = e1.clamp(t1[2], r / o, r / i), this._camera.position = t1;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e1) {
                return this._edgeInsets.equals(e1);
            }
            interpolatePadding(e1, t1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e1, t1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e1) {
                const t1 = (e1.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e1.tileSize));
                return Math.max(0, t1);
            }
            getVisibleUnwrappedCoordinates(t1) {
                const i = [
                    new e1.UnwrappedTileID(0, t1)
                ];
                if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e1.Point(0, 0)), r = this.pointCoordinate(new e1.Point(this.width, 0)), n = this.pointCoordinate(new e1.Point(this.width, this.height)), s = this.pointCoordinate(new e1.Point(0, this.height)), a = Math.floor(Math.min(o.x, r.x, n.x, s.x)), l = Math.floor(Math.max(o.x, r.x, n.x, s.x)), c = 1;
                    for(let o = a - c; o <= l + c; o++)0 !== o && i.push(new e1.UnwrappedTileID(o, t1));
                }
                return i;
            }
            coveringTiles(t1) {
                let i = this.coveringZoomLevel(t1);
                const o = i, r = this.elevation && !t1.isTerrainDEM, n = "mercator" === this.projection.name;
                if (void 0 !== t1.minzoom && i < t1.minzoom) return [];
                void 0 !== t1.maxzoom && i > t1.maxzoom && (i = t1.maxzoom);
                const s = this.locationCoordinate(this.center), a = this.center.lat, l = 1 << i, c = [
                    l * s.x,
                    l * s.y,
                    0
                ], h = "globe" === this.projection.name, u = !h, _ = e1.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u), d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p = l * e1.mercatorZfromAltitude(1, this.center.lat), m = this._camera.position[2] / e1.mercatorZfromAltitude(1, this.center.lat), f = [
                    l * d.x,
                    l * d.y,
                    m * (u ? 1 : p)
                ], g = this.cameraToCenterDistance / t1.tileSize * (t1.roundZoom ? 1 : .502), v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0, x = t1.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y = t1.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b = this.projection.isReprojectedInTileSpace ? Vo(this) : 1, w = (t1)=>{
                    const i = 1 / 4e4, o = new e1.MercatorCoordinate(t1.x + i, t1.y, t1.z), r = new e1.MercatorCoordinate(t1.x, t1.y + i, t1.z), n = t1.toLngLat(), s = o.toLngLat(), a = r.toLngLat(), l = this.locationCoordinate(n), c = this.locationCoordinate(s), h = this.locationCoordinate(a), u = Math.hypot(c.x - l.x, c.y - l.y), _ = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(u * _) * b / i;
                }, T = (t1)=>{
                    const i = x, o = y;
                    return {
                        aabb: e1.tileAABB(this, l, 0, 0, 0, t1, o, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o,
                        maxZ: i,
                        wrap: t1,
                        fullyVisible: !1
                    };
                }, E = [];
                let C = [];
                const M = i, I = t1.reparseOverscaled ? o : i, P = (e1)=>e1 * e1, S = P((m - this._centerAltitude) * p), D = (e1)=>{
                    if (!this._elevation || !e1.tileID || !n) return;
                    const t1 = this._elevation.getMinMaxForTile(e1.tileID), i = e1.aabb;
                    t1 ? (i.min[2] = t1.min, i.max[2] = t1.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e1.shouldSplit = L(e1), e1.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }, L = (t1)=>{
                    if (t1.zoom < v) return !0;
                    if (t1.zoom === M) return !1;
                    if (null != t1.shouldSplit) return t1.shouldSplit;
                    const i = t1.aabb.distanceX(f), n = t1.aabb.distanceY(f);
                    let s = S, l = 1;
                    if (h) {
                        s = P(t1.aabb.distanceZ(f));
                        const i = Math.pow(2, t1.zoom), o = e1.latFromMercatorY((t1.y + 1) / i), r = e1.latFromMercatorY(t1.y / i), n = Math.min(Math.max(a, o), r), c = e1.circumferenceAtLatitude(n) / e1.circumferenceAtLatitude(a);
                        if (l = n === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio), this.zoom <= e1.GLOBE_ZOOM_THRESHOLD_MIN && t1.zoom === M - 1 && c >= .9) return !0;
                    } else if (r && (s = P(t1.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t1.zoom), o = w(new e1.MercatorCoordinate((t1.x + .5) / i, (t1.y + .5) / i));
                        l = o > .85 ? 1 : o;
                    }
                    const c = i * i + n * n + s, u = P((1 << M - t1.zoom) * g * l * ((e1, t1)=>{
                        if (t1 * P(.707) < e1) return 1;
                        const i = Math.sqrt(t1 / e1);
                        return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                    })(Math.max(s, S), c));
                    return c < u;
                };
                if (this.renderWorldCopies) for(let e1 = 1; e1 <= 3; e1++)E.push(T(-e1)), E.push(T(e1));
                for(E.push(T(0)); E.length > 0;){
                    const o = E.pop(), s = o.x, a = o.y;
                    let u = o.fullyVisible;
                    if (!u) {
                        const e1 = o.aabb.intersects(_);
                        if (0 === e1) continue;
                        u = 2 === e1;
                    }
                    if (o.zoom !== M && L(o)) for(let t1 = 0; t1 < 4; t1++){
                        const i = (s << 1) + t1 % 2, c = (a << 1) + (t1 >> 1), _ = {
                            aabb: n ? o.aabb.quadrant(t1) : e1.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection),
                            zoom: o.zoom + 1,
                            x: i,
                            y: c,
                            wrap: o.wrap,
                            fullyVisible: u,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o.minZ,
                            maxZ: o.maxZ
                        };
                        r && !h && (_.tileID = new e1.OverscaledTileID(o.zoom + 1 === M ? I : o.zoom + 1, o.wrap, o.zoom + 1, i, c), D(_)), E.push(_);
                    }
                    else {
                        const r = o.zoom === M ? I : o.zoom;
                        if (t1.minzoom && t1.minzoom > r) continue;
                        const n = c[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom), l = c[1] - .5 - a, h = o.tileID ? o.tileID : new e1.OverscaledTileID(r, o.wrap, o.zoom, s, a);
                        C.push({
                            tileID: h,
                            distanceSq: n * n + l * l
                        });
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq, o = this.horizonLineFromTop();
                    C = C.filter((r)=>{
                        const n = [
                            0,
                            0,
                            0,
                            1
                        ], s = [
                            e1.EXTENT,
                            e1.EXTENT,
                            0,
                            1
                        ], a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                        e1.transformMat4$1(n, n, a), e1.transformMat4$1(s, s, a);
                        const l = e1.getAABBPointSquareDist(n, s);
                        if (0 === l) return !0;
                        let c = !1;
                        const h = this._elevation;
                        if (h && l > i && 0 !== o) {
                            const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
                            let n;
                            t1.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = {
                                min: y,
                                max: x
                            });
                            const s = e1.furthestTileCorner(this.rotation), a = [
                                s[0] * e1.EXTENT,
                                s[1] * e1.EXTENT,
                                n.max
                            ];
                            e1.transformMat4(a, a, i), c = (1 - a[1]) * this.height * .5 < o;
                        }
                        return l < i || c;
                    });
                }
                return C.sort((e1, t1)=>e1.distanceSq - t1.distanceSq).map((e1)=>e1.tileID);
            }
            resize(e1, t1) {
                this.width = e1, this.height = t1, this.pixelsToGLUnits = [
                    2 / e1,
                    -2 / t1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e1) {
                return Math.pow(2, e1);
            }
            scaleZoom(e1) {
                return Math.log(e1) / Math.LN2;
            }
            project(t1) {
                const i = e1.clamp(t1.lat, -e1.MAX_MERCATOR_LATITUDE, e1.MAX_MERCATOR_LATITUDE), o = this.projection.project(t1.lng, i);
                return new e1.Point(o.x * this.worldSize, o.y * this.worldSize);
            }
            unproject(e1) {
                return this.projection.unproject(e1.x / this.worldSize, e1.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            get pointMerc() {
                return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e1.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t1, i) {
                let o, r;
                const n = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e1 = this.worldSize;
                    o = (i.x - n.x) / e1, r = (i.y - n.y) / e1;
                } else {
                    const e1 = this.pointCoordinate(i), t1 = this.pointCoordinate(n);
                    o = e1.x - t1.x, r = e1.y - t1.y;
                }
                const s = this.locationCoordinate(t1);
                this.setLocation(new e1.MercatorCoordinate(s.x - o, s.y - r));
            }
            setLocation(e1) {
                this.center = this.coordinateLocation(e1), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e1) {
                return this.projection.locationPoint(this, e1);
            }
            locationPoint3D(e1) {
                return this.projection.locationPoint(this, e1, !0);
            }
            pointLocation(e1) {
                return this.coordinateLocation(this.pointCoordinate(e1));
            }
            pointLocation3D(e1) {
                return this.coordinateLocation(this.pointCoordinate3D(e1));
            }
            locationCoordinate(t1, i) {
                const o = i ? e1.mercatorZfromAltitude(i, t1.lat) : void 0, r = this.projection.project(t1.lng, t1.lat);
                return new e1.MercatorCoordinate(r.x, r.y, o);
            }
            coordinateLocation(e1) {
                return this.projection.unproject(e1.x, e1.y);
            }
            pointRayIntersection(t1, i) {
                const o = null != i ? i : this._centerAltitude, r = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], n = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e1.transformMat4$1(r, r, this.pixelMatrixInverse), e1.transformMat4$1(n, n, this.pixelMatrixInverse);
                const s = n[3];
                e1.scale$1(r, r, 1 / r[3]), e1.scale$1(n, n, 1 / s);
                const a = r[2], l = n[2];
                return {
                    p0: r,
                    p1: n,
                    t: a === l ? 0 : (o - a) / (l - a)
                };
            }
            screenPointToMercatorRay(t1) {
                const i = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                return e1.transformMat4$1(i, i, this.pixelMatrixInverse), e1.transformMat4$1(o, o, this.pixelMatrixInverse), e1.scale$1(i, i, 1 / i[3]), e1.scale$1(o, o, 1 / o[3]), i[2] = e1.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e1.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e1.scale$1(i, i, 1 / this.worldSize), e1.scale$1(o, o, 1 / this.worldSize), new e1.Ray([
                    i[0],
                    i[1],
                    i[2]
                ], e1.normalize([], e1.sub([], o, i)));
            }
            rayIntersectionCoordinate(t1) {
                const { p0: i, p1: o, t: r } = t1, n = e1.mercatorZfromAltitude(i[2], this._center.lat), s = e1.mercatorZfromAltitude(o[2], this._center.lat);
                return new e1.MercatorCoordinate(e1.number(i[0], o[0], r) / this.worldSize, e1.number(i[1], o[1], r) / this.worldSize, e1.number(n, s, r));
            }
            pointCoordinate(e1, t1 = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e1.x, e1.y, t1);
            }
            pointCoordinate3D(t1) {
                if (!this.elevation) return this.pointCoordinate(t1);
                let i = this.projection.pointCoordinate3D(this, t1.x, t1.y);
                if (i) return new e1.MercatorCoordinate(i[0], i[1], i[2]);
                let o = 0, r = this.horizonLineFromTop();
                if (t1.y > r) return this.pointCoordinate(t1);
                const n = .02 * r, s = t1.clone();
                for(let t1 = 0; t1 < 10 && r - o > n; t1++){
                    s.y = e1.number(o, r, .66);
                    const t1 = this.projection.pointCoordinate3D(this, s.x, s.y);
                    t1 ? (r = s.y, i = t1) : o = s.y;
                }
                return i ? new e1.MercatorCoordinate(i[0], i[1], i[2]) : this.pointCoordinate(t1);
            }
            isPointAboveHorizon(e1) {
                return this.projection.isPointAboveHorizon(this, e1);
            }
            isPointOnSurface(t1) {
                if (t1.y < 0 || t1.y > this.height || t1.x < 0 || t1.x > this.width) return !1;
                if (this.elevation || this.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX) return !this.isPointAboveHorizon(t1);
                const i = this.pointCoordinate(t1);
                return i.y >= 0 && i.y <= 1;
            }
            _coordinatePoint(t1, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t1, this._centerAltitude) : this._centerAltitude, r = [
                    t1.x * this.worldSize,
                    t1.y * this.worldSize,
                    o + t1.toAltitude(),
                    1
                ];
                return e1.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e1.Point(r[0] / r[3], r[1] / r[3]) : new e1.Point(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
                const { top: t1, left: i } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, r = this.width - this._edgeInsets.right, n = this.pointLocation3D(new e1.Point(i, t1)), s = this.pointLocation3D(new e1.Point(r, t1)), a = this.pointLocation3D(new e1.Point(r, o)), l = this.pointLocation3D(new e1.Point(i, o));
                let c = Math.min(n.lng, s.lng, a.lng, l.lng), h = Math.max(n.lng, s.lng, a.lng, l.lng), u = Math.min(n.lat, s.lat, a.lat, l.lat), _ = Math.max(n.lat, s.lat, a.lat, l.lat);
                const d = Math.pow(2, -this.zoom) / 16 * 270, p = "globe" === this.projection.name ? 1 : 4, m = (t1, i, o, r, n)=>{
                    const s = (t1 + o) / 2, a = (i + r) / 2, l = new e1.Point(s, a), { lng: f, lat: g } = this.pointLocation3D(l), v = Math.max(0, c - f, u - g, f - h, g - _);
                    c = Math.min(c, f), h = Math.max(h, f), u = Math.min(u, g), _ = Math.max(_, g), (n < p || v > d) && (m(t1, i, s, a, n + 1), m(s, a, o, r, n + 1));
                };
                if (m(i, t1, r, t1, 1), m(r, t1, r, o, 1), m(r, o, i, o, 1), m(i, o, i, t1, 1), "globe" === this.projection.name) {
                    const [t1, i] = e1.polesInViewport(this);
                    t1 ? (_ = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);
                }
                return new e1.LngLatBounds(new e1.LngLat(c, u), new e1.LngLat(h, _));
            }
            _getBoundsRectangular(t1, i) {
                const { top: o, left: r } = this._edgeInsets, n = this.height - this._edgeInsets.bottom, s = this.width - this._edgeInsets.right, a = new e1.Point(r, o), l = new e1.Point(s, o), c = new e1.Point(s, n), h = new e1.Point(r, n);
                let u = this.pointCoordinate(a, t1), _ = this.pointCoordinate(l, t1);
                const d = this.pointCoordinate(c, i), p = this.pointCoordinate(h, i), m = (e1, t1)=>(t1.y - e1.y) / (t1.x - e1.x);
                return u.y > 1 && _.y >= 0 ? u = new e1.MercatorCoordinate((1 - p.y) / m(p, u) + p.x, 1) : u.y < 0 && _.y <= 1 && (u = new e1.MercatorCoordinate(-p.y / m(p, u) + p.x, 0)), _.y > 1 && u.y >= 0 ? _ = new e1.MercatorCoordinate((1 - d.y) / m(d, _) + d.x, 1) : _.y < 0 && u.y <= 1 && (_ = new e1.MercatorCoordinate(-d.y / m(d, _) + d.x, 0)), (new e1.LngLatBounds).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d));
            }
            _getBoundsRectangularTerrain() {
                const e1 = this.elevation;
                if (!e1.visibleDemTiles.length || e1.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                const t1 = e1.visibleDemTiles.reduce((e1, t1)=>{
                    if (t1.dem) {
                        const i = t1.dem.tree;
                        e1.min = Math.min(e1.min, i.minimums[0]), e1.max = Math.max(e1.max, i.maximums[0]);
                    }
                    return e1;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBoundsRectangular(t1.min * e1.exaggeration(), t1.max * e1.exaggeration());
            }
            getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e1 = !0) {
                const t1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y, i = this.height / 2 - t1 * (1 - this._horizonShift);
                return e1 ? Math.max(0, i) : i;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t1) {
                this.maxBounds = t1, this.minLat = -e1.MAX_MERCATOR_LATITUDE, this.maxLat = e1.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t1 && (this.minLat = t1.getSouth(), this.maxLat = t1.getNorth(), this.minLng = t1.getWest(), this.maxLng = t1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e1.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e1.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e1.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e1.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e1, t1) {
                return this.projection.createTileMatrix(this, t1, e1);
            }
            calculateDistanceTileData(t1) {
                const i = t1.key, o = this._distanceTileDataCache;
                if (o[i]) return o[i];
                const r = t1.canonical, n = 1 / this.height, s = this.cameraWorldSize, a = s / this.zoomScale(r.z), l = (r.x + Math.pow(2, r.z) * t1.wrap) * a, c = r.y * a, h = this.point;
                h.x *= s / this.worldSize, h.y *= s / this.worldSize;
                const u = this.angle, _ = Math.sin(-u), d = -Math.cos(-u);
                return o[i] = {
                    bearing: [
                        _,
                        d
                    ],
                    center: [
                        (h.x - l) * n,
                        (h.y - c) * n
                    ],
                    scale: a / e1.EXTENT * n
                }, o[i];
            }
            calculateFogTileMatrix(t1) {
                const i = t1.key, o = this._fogTileMatrixCache;
                if (o[i]) return o[i];
                const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t1);
                return e1.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
            }
            calculateProjMatrix(t1, i = !1) {
                const o = t1.key, r = i ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (r[o]) return r[o];
                const n = this.calculatePosMatrix(t1, this.worldSize);
                return e1.multiply(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];
            }
            calculatePixelsToTileUnitsMatrix(t1) {
                const i = t1.tileID.key, o = this._pixelsToTileUnitsCache;
                if (o[i]) return o[i];
                const r = function(t1, i) {
                    const { scale: o } = t1.tileTransform, r = o * e1.EXTENT / (t1.tileSize * Math.pow(2, i.zoom - t1.tileID.overscaledZ + t1.tileID.canonical.z));
                    var n, s, a, l, c, h, u, _;
                    return n = new Float32Array(4), l = (s = i.inverseAdjustmentMatrix)[1], c = s[2], h = s[3], _ = (a = [
                        r,
                        r
                    ])[1], n[0] = s[0] * (u = a[0]), n[1] = l * u, n[2] = c * _, n[3] = h * _, n;
                }(t1, this);
                return o[i] = r, o[i];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t1 = 1 / this.worldSize, i = e1.fromScaling([], [
                        t1,
                        t1,
                        t1
                    ]);
                    return e1.multiply(i, i, this.globeMatrix), i;
                }
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t1 = this._elevation;
                this._updateCameraState();
                const i = e1.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o = this._computeCameraPosition(i), r = this._camera.forward(), n = e1.mercatorZfromAltitude(1, this._center.lat);
                o[2] /= n, r[2] /= n, e1.normalize(r, r);
                const s = t1.raycast(o, r, t1.exaggeration());
                if (s) {
                    const t1 = e1.scaleAndAdd([], o, r, s), i = new e1.MercatorCoordinate(t1[0], t1[1], e1.mercatorZfromAltitude(t1[2], e1.latFromMercatorY(t1[1]))), a = (i.z + e1.length([
                        i.x - o[0],
                        i.y - o[1],
                        i.z - o[2] * n
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t1 = !1) {
                if (!this._elevation) return;
                const i = this._elevation, o = e1.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r = this._computeCameraPosition(o), n = i.getAtPointOrZero(new e1.MercatorCoordinate(...r)), s = this.pixelsPerMeter / this.worldSize * n, a = this._minimumHeightOverTerrain(), l = r[2] - s;
                if (l <= a) {
                    if (l < 0 || t1) {
                        const t1 = this.locationCoordinate(this._center, this._centerAltitude), i = [
                            r[0],
                            r[1],
                            t1.z - r[2]
                        ], o = e1.length(i);
                        i[2] -= (a - l) / this._pixelsPerMercatorPixel;
                        const n = e1.length(i);
                        if (0 === n) return;
                        e1.scale$2(i, i, o / n * this._pixelsPerMercatorPixel), this._camera.position = [
                            r[0],
                            r[1],
                            t1.z * this._pixelsPerMercatorPixel - i[2]
                        ], this._updateStateFromCamera();
                    } else this._isCameraConstrained = !0;
                }
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t1 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t1) {
                    const i = this.center;
                    return i.lat = e1.clamp(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t1) && (i.lng = e1.clamp(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }
                const i = this._unmodified, { x: o, y: r } = this.point;
                let n = 0, s = o, a = r;
                const l = this.width / 2, c = this.height / 2, h = this.worldMinY * this.scale, u = this.worldMaxY * this.scale;
                if (r - c < h && (a = h + c), r + c > u && (a = u - c), u - h < this.height && (n = Math.max(n, this.height / (u - h)), a = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e1 = this.worldMinX * this.scale, t1 = this.worldMaxX * this.scale, i = this.worldSize / 2 - (e1 + t1) / 2;
                    s = (o + i + this.worldSize) % this.worldSize - i, s - l < e1 && (s = e1 + l), s + l > t1 && (s = t1 - l), t1 - e1 < this.width && (n = Math.max(n, this.width / (t1 - e1)), s = (t1 + e1) / 2);
                }
                s === o && a === r || (this.center = this.unproject(new e1.Point(s, a))), n && (this.zoom += this.scaleZoom(n)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e1 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e1 = Math.max(e1, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e1;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t1 = this.centerOffset, i = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e1.mercatorZfromAltitude(1, this.center.lat) / e1.mercatorZfromAltitude(1, e1.GLOBE_SCALE_MATCH_LATITUDE));
                const o = Wo(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const r = "meters" === this.projection.zAxisUnit ? i : 1, n = this._camera.getWorldToCamera(this.worldSize, r), s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                s[8] = 2 * -t1.x / this.width, s[9] = 2 * t1.y / this.height;
                let a = e1.mul([], s, n);
                if (this.projection.isReprojectedInTileSpace) {
                    const t1 = this.locationCoordinate(this.center), i = e1.identity([]);
                    e1.translate(i, i, [
                        t1.x * this.worldSize,
                        t1.y * this.worldSize,
                        0
                    ]), e1.multiply(i, i, Zo(this)), e1.translate(i, i, [
                        -t1.x * this.worldSize,
                        -t1.y * this.worldSize,
                        0
                    ]), e1.multiply(a, a, i), this.inverseAdjustmentMatrix = function(e1) {
                        const t1 = Zo(e1, !0);
                        return v([], [
                            t1[0],
                            t1[1],
                            t1[4],
                            t1[5]
                        ]);
                    }(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                this.mercatorMatrix = e1.scale([], a, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / r,
                    1
                ]), this.projMatrix = a, this.invProjMatrix = e1.invert(new Float64Array(16), this.projMatrix);
                const l = e1.invert([], s);
                this.frustumCorners = e1.FrustumCorners.fromInvProjectionMatrix(l, this.horizonLineFromTop(), this.height);
                const c = new Float32Array(16);
                e1.identity(c), e1.scale(c, c, [
                    1,
                    -1,
                    1
                ]), e1.rotateX(c, c, this._pitch), e1.rotateZ(c, c, this.angle);
                const h = e1.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                h[8] = 2 * -t1.x / this.width, h[9] = 2 * (t1.y + u) / this.height, this.skyboxMatrix = e1.multiply(c, h, c);
                const _ = this.point, d = _.x, p = _.y, m = this.width % 2 / 2, f = this.height % 2 / 2, g = Math.cos(this.angle), x = Math.sin(this.angle), y = d - Math.round(d) + g * m + x * f, b = p - Math.round(p) + g * f + x * m, w = new Float64Array(a);
                if (e1.translate(w, w, [
                    y > .5 ? y - 1 : y,
                    b > .5 ? b - 1 : b,
                    0
                ]), this.alignedProjMatrix = w, a = e1.create(), e1.scale(a, a, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e1.translate(a, a, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = a, a = e1.create(), e1.scale(a, a, [
                    1,
                    -1,
                    1
                ]), e1.translate(a, a, [
                    -1,
                    -1,
                    0
                ]), e1.scale(a, a, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = a, this.pixelMatrix = e1.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e1.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = a, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e1.calculateGlobeMatrix(this);
                    const t1 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e1.transformMat4(t1, t1, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = a;
                this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const t1 = this.cameraWorldSizeForFog, i = this.cameraPixelsPerMeter, o = this._camera.position, r = 1 / this.height / this._pixelsPerMercatorPixel, n = [
                    t1,
                    t1,
                    i
                ];
                e1.scale$2(n, n, r), e1.scale$2(o, o, -1), e1.multiply$2(o, o, n);
                const s = e1.create();
                e1.translate(s, s, o), e1.scale(s, s, n), this.mercatorFogMatrix = s, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t1, i, r);
            }
            _computeCameraPosition(e1) {
                const t1 = (e1 = e1 || this.pixelsPerMeter) / this.pixelsPerMeter, i = this._camera.forward(), o = this.point, r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t1 - e1 / this.worldSize * this._centerAltitude;
                return [
                    o.x / this.worldSize - i[0] * r,
                    o.y / this.worldSize - i[1] * r,
                    e1 / this.worldSize * this._centerAltitude - i[2] * r
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t1) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o = this._camera.position[2], r = t1[2];
                let n = 1;
                this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (n = Math.min((i - o) / r, 1)), this._camera.position = e1.scaleAndAdd([], this._camera.position, t1, n), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t1 = this._camera.position, i = this._camera.forward(), { pitch: o, bearing: r } = this._camera.getPitchBearing(), n = e1.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e1.degToRad(this._maxPitch)), a = Math.max((t1[2] - n) / Math.cos(o), s), l = this._zoomFromMercatorZ(a);
                e1.scaleAndAdd(t1, t1, i, a), this._pitch = e1.clamp(o, e1.degToRad(this.minPitch), e1.degToRad(this.maxPitch)), this.angle = e1.wrap(r, -Math.PI, Math.PI), this._setZoom(e1.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e1.MercatorCoordinate(t1[0], t1[1], t1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e1) {
                return Math.pow(2, e1) * this.tileSize;
            }
            _mercatorZfromZoom(e1) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e1);
            }
            _minimumHeightOverTerrain() {
                const e1 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
                return this._mercatorZfromZoom(e1);
            }
            _zoomFromMercatorZ(e1) {
                return this.scaleZoom(this.cameraToCenterDistance / (e1 * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t1) {
                let i = 0, o = e1.GLOBE_ZOOM_THRESHOLD_MAX, r = 0, n = 1 / 0;
                for(; o - i > 1e-6 && o > i;){
                    const e1 = i + .5 * (o - i), s = this.tileSize * Math.pow(2, e1), a = this.getCameraToCenterDistance(this.projection, e1, s), l = this.scaleZoom(a / (t1 * this.tileSize)), c = Math.abs(e1 - l);
                    c < n && (n = c, r = e1), e1 < l ? i = e1 : o = e1;
                }
                return r;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e1.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t1, i) {
                const o = Math.min(t1.x, i.x), r = Math.max(t1.x, i.x), n = Math.min(t1.y, i.y), s = Math.max(t1.y, i.y);
                if (n < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const a = [
                    new e1.Point(o, n),
                    new e1.Point(r, s),
                    new e1.Point(o, s),
                    new e1.Point(r, n)
                ], l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                for (const e1 of a){
                    const t1 = this.pointRayIntersection(e1);
                    if (t1.t < 0) return !0;
                    const i = this.rayIntersectionCoordinate(t1);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e1.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e1.Point(0, 0), new e1.Point(this.width, this.height));
            }
            zoomDeltaToMovement(t1, i) {
                const o = e1.length(e1.sub([], this._camera.position, t1)), r = this._zoomFromMercatorZ(o) + i;
                return o - this._mercatorZfromZoom(r);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t1 = function([t1, i, o], r) {
                        const n = [
                            t1,
                            i,
                            o,
                            1
                        ];
                        e1.transformMat4$1(n, n, r);
                        const s = n[3] = Math.max(n[3], 1e-6);
                        return n[0] /= s, n[1] /= s, n[2] /= s, n;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e1.Point(t1[0], t1[1]);
                }
                {
                    const t1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e1.Point(0, t1));
                }
            }
            getCameraToCenterDistance(e1, t1 = this.zoom, i = this.worldSize) {
                const o = Wo(e1, t1, this.width, this.height, 1024), r = e1.pixelSpaceConversion(this.center.lat, i, o);
                return .5 / Math.tan(.5 * this._fov) * this.height * r;
            }
            getWorldToCameraMatrix() {
                const t1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e1.multiply(t1, t1, this.globeMatrix), t1;
            }
        }
        function Yo(e1, t1) {
            let i = !1, o = null;
            const r = ()=>{
                o = null, i && (e1(), o = setTimeout(r, t1), i = !1);
            };
            return ()=>(i = !0, o || r(), o);
        }
        class Ko {
            constructor(t1){
                this._hashName = t1 && encodeURIComponent(t1), e1.bindAll([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = Yo(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(t1) {
                return this._map = t1, e1.window.addEventListener("hashchange", this._onHashChange, !1), t1.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), e1.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const t1 = this._map;
                if (!t1) return "";
                const i = Jo(t1);
                if (this._hashName) {
                    const t1 = this._hashName;
                    let o = !1;
                    const r = e1.window.location.hash.slice(1).split("&").map((e1)=>{
                        const r = e1.split("=")[0];
                        return r === t1 ? (o = !0, `${r}=${i}`) : e1;
                    }).filter((e1)=>e1);
                    return o || r.push(`${t1}=${i}`), `#${r.join("&")}`;
                }
                return `#${i}`;
            }
            _getCurrentHash() {
                const t1 = e1.window.location.hash.replace("#", "");
                if (this._hashName) {
                    let e1;
                    return t1.split("&").map((e1)=>e1.split("=")).forEach((t1)=>{
                        t1[0] === this._hashName && (e1 = t1);
                    }), (e1 && e1[1] || "").split("/");
                }
                return t1.split("/");
            }
            _onHashChange() {
                const e1 = this._map;
                if (!e1) return !1;
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((e1)=>isNaN(e1))) {
                    const i = e1.dragRotate.isEnabled() && e1.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : e1.getBearing();
                    return e1.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: i,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                const t1 = e1.window.location.href.replace(/(#.+)?$/, this.getHashString());
                e1.window.history.replaceState(e1.window.history.state, null, t1);
            }
        }
        function Jo(e1, t1) {
            const i = e1.getCenter(), o = Math.round(100 * e1.getZoom()) / 100, r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), n = Math.pow(10, r), s = Math.round(i.lng * n) / n, a = Math.round(i.lat * n) / n, l = e1.getBearing(), c = e1.getPitch();
            let h = t1 ? `/${s}/${a}/${o}` : `${o}/${a}/${s}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }
        const Qo = {
            linearity: .3,
            easing: e1.bezier(0, 0, .3, 1)
        }, er = e1.extend({
            deceleration: 2500,
            maxSpeed: 1400
        }, Qo), tr = e1.extend({
            deceleration: 20,
            maxSpeed: 1400
        }, Qo), ir = e1.extend({
            deceleration: 1e3,
            maxSpeed: 360
        }, Qo), or = e1.extend({
            deceleration: 1e3,
            maxSpeed: 90
        }, Qo);
        class rr {
            constructor(e1){
                this._map = e1, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e1.exported.now(),
                    settings: t1
                });
            }
            _drainInertiaBuffer() {
                const t1 = this._inertiaBuffer, i = e1.exported.now();
                for(; t1.length > 0 && i - t1[0].time > 160;)t1.shift();
            }
            _onMoveEnd(t1) {
                if (this._map._prefersReducedMotion()) return;
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e1.Point(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e1 } of this._inertiaBuffer)i.zoom += e1.zoomDelta || 0, i.bearing += e1.bearingDelta || 0, i.pitch += e1.pitchDelta || 0, e1.panDelta && i.pan._add(e1.panDelta), e1.around && (i.around = e1.around), e1.pinchAround && (i.pinchAround = e1.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r = {};
                if (i.pan.mag()) {
                    const n = sr(i.pan.mag(), o, e1.extend({}, er, t1 || {}));
                    r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, nr(r, n);
                }
                if (i.zoom) {
                    const e1 = sr(i.zoom, o, tr);
                    r.zoom = this._map.transform.zoom + e1.amount, nr(r, e1);
                }
                if (i.bearing) {
                    const t1 = sr(i.bearing, o, ir);
                    r.bearing = this._map.transform.bearing + e1.clamp(t1.amount, -179, 179), nr(r, t1);
                }
                if (i.pitch) {
                    const e1 = sr(i.pitch, o, or);
                    r.pitch = this._map.transform.pitch + e1.amount, nr(r, e1);
                }
                if (r.zoom || r.bearing) {
                    const e1 = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    r.around = e1 ? this._map.unproject(e1) : this._map.getCenter();
                }
                return this.clear(), r.noMoveStart = !0, r;
            }
        }
        function nr(e1, t1) {
            (!e1.duration || e1.duration < t1.duration) && (e1.duration = t1.duration, e1.easing = t1.easing);
        }
        function sr(t1, i, o) {
            const { maxSpeed: r, linearity: n, deceleration: s } = o, a = e1.clamp(t1 * n / (i / 1e3), -r, r), l = Math.abs(a) / (s * n);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: a * (l / 2)
            };
        }
        class ar extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o, r = {}){
                const n = p(i.getCanvasContainer(), o), s = i.unproject(n);
                super(t1, e1.extend({
                    point: n,
                    lngLat: s,
                    originalEvent: o
                }, r)), this._defaultPrevented = !1, this.target = i;
            }
        }
        class lr extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o){
                const r = "touchend" === t1 ? o.changedTouches : o.touches, n = m(i.getCanvasContainer(), r), s = n.map((e1)=>i.unproject(e1)), a = n.reduce((e1, t1, i, o)=>e1.add(t1.div(o.length)), new e1.Point(0, 0));
                super(t1, {
                    points: n,
                    point: a,
                    lngLats: s,
                    lngLat: i.unproject(a),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
        }
        class cr extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e1, t1, i){
                super(e1, {
                    originalEvent: i
                }), this._defaultPrevented = !1;
            }
        }
        class hr {
            constructor(e1, t1){
                this._map = e1, this._clickTolerance = t1.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e1) {
                return this._firePreventable(new cr(e1.type, this._map, e1));
            }
            mousedown(e1, t1) {
                return this._mousedownPos = t1, this._firePreventable(new ar(e1.type, this._map, e1));
            }
            mouseup(e1) {
                this._map.fire(new ar(e1.type, this._map, e1));
            }
            preclick(t1) {
                const i = e1.extend({}, t1);
                i.type = "preclick", this._map.fire(new ar(i.type, this._map, i));
            }
            click(e1, t1) {
                this._mousedownPos && this._mousedownPos.dist(t1) >= this._clickTolerance || (this.preclick(e1), this._map.fire(new ar(e1.type, this._map, e1)));
            }
            dblclick(e1) {
                return this._firePreventable(new ar(e1.type, this._map, e1));
            }
            mouseover(e1) {
                this._map.fire(new ar(e1.type, this._map, e1));
            }
            mouseout(e1) {
                this._map.fire(new ar(e1.type, this._map, e1));
            }
            touchstart(e1) {
                return this._firePreventable(new lr(e1.type, this._map, e1));
            }
            touchmove(e1) {
                this._map.fire(new lr(e1.type, this._map, e1));
            }
            touchend(e1) {
                this._map.fire(new lr(e1.type, this._map, e1));
            }
            touchcancel(e1) {
                this._map.fire(new lr(e1.type, this._map, e1));
            }
            _firePreventable(e1) {
                if (this._map.fire(e1), e1.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class ur {
            constructor(e1){
                this._map = e1;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e1) {
                this._map.fire(new ar(e1.type, this._map, e1));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ar("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e1) {
                this._delayContextMenu ? this._contextMenuEvent = e1 : this._map.fire(new ar(e1.type, this._map, e1)), this._map.listens("contextmenu") && e1.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class _r {
            constructor(e1, t1){
                this._map = e1, this._el = e1.getCanvasContainer(), this._container = e1.getContainer(), this._clickTolerance = t1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e1, t1) {
                this.isEnabled() && e1.shiftKey && 0 === e1.button && (h(), this._startPos = this._lastPos = t1, this._active = !0);
            }
            mousemoveWindow(e1, t1) {
                if (!this._active) return;
                const i = t1, o = this._startPos, r = this._lastPos;
                if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
                this._lastPos = i, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e1));
                const s = Math.min(o.x, i.x), a = Math.max(o.x, i.x), l = Math.min(o.y, i.y), c = Math.max(o.y, i.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${s}px,${l}px)`, this._box.style.width = a - s + "px", this._box.style.height = c - l + "px");
                });
            }
            mouseupWindow(t1, i) {
                if (!this._active) return;
                const o = this._startPos, r = i;
                if (o && 0 === t1.button) {
                    if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e1.Event("boxzoomend", {
                        originalEvent: t1
                    })), {
                        cameraAnimation: (e1)=>e1.fitScreenCoordinates(o, r, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t1);
                }
            }
            keydown(e1) {
                this._active && 27 === e1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e1));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t1, i) {
                return this._map.fire(new e1.Event(t1, {
                    originalEvent: i
                }));
            }
        }
        function dr(e1, t1) {
            const i = {};
            for(let o = 0; o < e1.length; o++)i[e1[o].identifier] = t1[o];
            return i;
        }
        class pr {
            constructor(e1){
                this.reset(), this.numTouches = e1.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }
            touchstart(t1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t1.timeStamp), o.length === this.numTouches && (this.centroid = function(t1) {
                    const i = new e1.Point(0, 0);
                    for (const e1 of t1)i._add(e1);
                    return i.div(t1.length);
                }(i), this.touches = dr(o, i)));
            }
            touchmove(e1, t1, i) {
                if (this.aborted || !this.centroid) return;
                const o = dr(i, t1);
                for(const e1 in this.touches){
                    const t1 = o[e1];
                    (!t1 || t1.dist(this.touches[e1]) > 30) && (this.aborted = !0);
                }
            }
            touchend(e1, t1, i) {
                if ((!this.centroid || e1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e1 = !this.aborted && this.centroid;
                    if (this.reset(), e1) return e1;
                }
            }
        }
        class mr {
            constructor(e1){
                this.singleTap = new pr(e1), this.numTaps = e1.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e1, t1, i) {
                this.singleTap.touchstart(e1, t1, i);
            }
            touchmove(e1, t1, i) {
                this.singleTap.touchmove(e1, t1, i);
            }
            touchend(e1, t1, i) {
                const o = this.singleTap.touchend(e1, t1, i);
                if (o) {
                    const t1 = e1.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (t1 && i || this.reset(), this.count++, this.lastTime = e1.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class fr {
            constructor(){
                this._zoomIn = new mr({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new mr({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e1, t1, i) {
                this._zoomIn.touchstart(e1, t1, i), this._zoomOut.touchstart(e1, t1, i);
            }
            touchmove(e1, t1, i) {
                this._zoomIn.touchmove(e1, t1, i), this._zoomOut.touchmove(e1, t1, i);
            }
            touchend(e1, t1, i) {
                const o = this._zoomIn.touchend(e1, t1, i), r = this._zoomOut.touchend(e1, t1, i);
                return o ? (this._active = !0, e1.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() + 1,
                            around: t1.unproject(o)
                        }, {
                            originalEvent: e1
                        })
                }) : r ? (this._active = !0, e1.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() - 1,
                            around: t1.unproject(r)
                        }, {
                            originalEvent: e1
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const gr = {
            0: 1,
            2: 2
        };
        class vr {
            constructor(e1){
                this.reset(), this._clickTolerance = e1.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e1, t1) {
                return !1;
            }
            _move(e1, t1) {
                return {};
            }
            mousedown(e1, t1) {
                if (this._lastPoint) return;
                const i = f(e1);
                this._correctButton(e1, i) && (this._lastPoint = t1, this._eventButton = i);
            }
            mousemoveWindow(e1, t1) {
                const i = this._lastPoint;
                if (i) {
                    if (e1.preventDefault(), null != this._eventButton && function(e1, t1) {
                        const i = gr[t1];
                        return void 0 === e1.buttons || (e1.buttons & i) !== i;
                    }(e1, this._eventButton)) this.reset();
                    else if (this._moved || !(t1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t1, this._move(i, t1);
                }
            }
            mouseupWindow(e1) {
                this._lastPoint && f(e1) === this._eventButton && (this._moved && d(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class xr extends vr {
            mousedown(e1, t1) {
                super.mousedown(e1, t1), this._lastPoint && (this._active = !0);
            }
            _correctButton(e1, t1) {
                return 0 === t1 && !e1.ctrlKey;
            }
            _move(e1, t1) {
                return {
                    around: t1,
                    panDelta: t1.sub(e1)
                };
            }
        }
        class yr extends vr {
            _correctButton(e1, t1) {
                return 0 === t1 && e1.ctrlKey || 2 === t1;
            }
            _move(e1, t1) {
                const i = .8 * (t1.x - e1.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(e1) {
                e1.preventDefault();
            }
        }
        class br extends vr {
            _correctButton(e1, t1) {
                return 0 === t1 && e1.ctrlKey || 2 === t1;
            }
            _move(e1, t1) {
                const i = -0.5 * (t1.y - e1.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(e1) {
                e1.preventDefault();
            }
        }
        class wr {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e1.bindAll([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new e1.Point(0, 0);
            }
            touchstart(e1, t1, i) {
                return this._calculateTransform(e1, t1, i);
            }
            touchmove(t1, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e1.isFullscreen()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t1.cancelable && t1.preventDefault(), this._calculateTransform(t1, i, o);
                }
            }
            touchend(e1, t1, i) {
                this._calculateTransform(e1, t1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t1, i, o) {
                o.length > 0 && (this._active = !0);
                const r = dr(o, i), n = new e1.Point(0, 0), s = new e1.Point(0, 0);
                let a = 0;
                for(const e1 in r){
                    const t1 = r[e1], i = this._touches[e1];
                    i && (n._add(t1), s._add(t1.sub(i)), a++, r[e1] = t1);
                }
                if (this._touches = r, a < this._minTouches || !s.mag()) return;
                const l = s.div(a);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: n.div(a),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 500);
            }
        }
        class Tr {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e1) {}
            _move(e1, t1, i) {
                return {};
            }
            touchstart(e1, t1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t1[0],
                    t1[1]
                ]));
            }
            touchmove(e1, t1, i) {
                const o = this._firstTwoTouches;
                if (!o) return;
                e1.preventDefault();
                const [r, n] = o, s = Er(i, t1, r), a = Er(i, t1, n);
                if (!s || !a) return;
                const l = this._aroundCenter ? null : s.add(a).div(2);
                return this._move([
                    s,
                    a
                ], l, e1);
            }
            touchend(e1, t1, i) {
                if (!this._firstTwoTouches) return;
                const [o, r] = this._firstTwoTouches, n = Er(i, t1, o), s = Er(i, t1, r);
                n && s || (this._active && d(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e1) {
                this._enabled = !0, this._aroundCenter = !!e1 && "center" === e1.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function Er(e1, t1, i) {
            for(let o = 0; o < e1.length; o++)if (e1[o].identifier === i) return t1[o];
        }
        function Cr(e1, t1) {
            return Math.log(e1 / t1) / Math.LN2;
        }
        class Mr extends Tr {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e1) {
                this._startDistance = this._distance = e1[0].dist(e1[1]);
            }
            _move(e1, t1) {
                const i = this._distance;
                if (this._distance = e1[0].dist(e1[1]), this._active || !(Math.abs(Cr(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: Cr(this._distance, i),
                    pinchAround: t1
                };
            }
        }
        function Ir(e1, t1) {
            return 180 * e1.angleWith(t1) / Math.PI;
        }
        class Pr extends Tr {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e1) {
                this._startVector = this._vector = e1[0].sub(e1[1]), this._minDiameter = e1[0].dist(e1[1]);
            }
            _move(e1, t1) {
                const i = this._vector;
                if (this._vector = e1[0].sub(e1[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: Ir(this._vector, i),
                    pinchAround: t1
                };
            }
            _isBelowThreshold(e1) {
                this._minDiameter = Math.min(this._minDiameter, e1.mag());
                const t1 = 25 / (Math.PI * this._minDiameter) * 360, i = this._startVector;
                if (!i) return !1;
                const o = Ir(e1, i);
                return Math.abs(o) < t1;
            }
        }
        function Sr(e1) {
            return Math.abs(e1.y) > Math.abs(e1.x);
        }
        class Dr extends Tr {
            constructor(e1){
                super(), this._map = e1;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e1) {
                this._lastPoints = e1, Sr(e1[0].sub(e1[1])) && (this._valid = !1);
            }
            _move(t1, i, o) {
                const r = this._lastPoints;
                if (!r) return;
                const n = t1[0].sub(r[0]), s = t1[1].sub(r[1]);
                return this._map._cooperativeGestures && !e1.isFullscreen() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n, s, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (n.y + s.y) / 2 * -0.5
                });
            }
            gestureBeginsVertically(e1, t1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = e1.mag() >= 2, r = t1.mag() >= 2;
                if (!o && !r) return;
                if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const n = e1.y > 0 == t1.y > 0;
                return Sr(e1) && Sr(t1) && n;
            }
        }
        const Lr = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class Ar {
            constructor(){
                const e1 = Lr;
                this._panStep = e1.panStep, this._bearingStep = e1.bearingStep, this._pitchStep = e1.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e1) {
                if (e1.altKey || e1.ctrlKey || e1.metaKey) return;
                let t1 = 0, i = 0, o = 0, r = 0, n = 0;
                switch(e1.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t1 = -1;
                        break;
                    case 37:
                        e1.shiftKey ? i = -1 : (e1.preventDefault(), r = -1);
                        break;
                    case 39:
                        e1.shiftKey ? i = 1 : (e1.preventDefault(), r = 1);
                        break;
                    case 38:
                        e1.shiftKey ? o = 1 : (e1.preventDefault(), n = -1);
                        break;
                    case 40:
                        e1.shiftKey ? o = -1 : (e1.preventDefault(), n = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (s)=>{
                        const a = s.getZoom();
                        s.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: zr,
                            zoom: t1 ? Math.round(a) + t1 * (e1.shiftKey ? 2 : 1) : a,
                            bearing: s.getBearing() + i * this._bearingStep,
                            pitch: s.getPitch() + o * this._pitchStep,
                            offset: [
                                -r * this._panStep,
                                -n * this._panStep
                            ],
                            center: s.getCenter()
                        }, {
                            originalEvent: e1
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function zr(e1) {
            return e1 * (2 - e1);
        }
        const Rr = 4.000244140625;
        class Or {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e1.bindAll([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e1) {
                this._defaultZoomRate = e1;
            }
            setWheelZoomRate(e1) {
                this._wheelZoomRate = e1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e1) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e1 && "center" === e1.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t1.ctrlKey || t1.metaKey || this.isZooming() || e1.isFullscreen())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i = t1.deltaMode === e1.window.WheelEvent.DOM_DELTA_LINE ? 40 * t1.deltaY : t1.deltaY;
                const o = e1.exported.now(), r = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % Rr == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t1)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t1, this._delta -= i, this._active || this._start(t1)), t1.preventDefault();
            }
            _onTimeout(e1) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e1);
            }
            _start(e1) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t1 = p(this._el, e1);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t1 = this._map.transform;
                "wheel" === this._type && t1.projection.wrap && (t1._center.lng >= 180 || t1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i = ()=>t1._terrainEnabled() && this._aroundCoord ? t1.computeZoomRelativeTo(this._aroundCoord) : t1.zoom;
                if (0 !== this._delta) {
                    const e1 = "wheel" === this._type && Math.abs(this._delta) > Rr ? this._wheelZoomRate : this._defaultZoomRate;
                    let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e1)));
                    this._delta < 0 && 0 !== o && (o = 1 / o);
                    const r = i(), n = Math.pow(2, r), s = "number" == typeof this._targetZoom ? t1.zoomScale(this._targetZoom) : n;
                    this._targetZoom = Math.min(t1.maxZoom, Math.max(t1.minZoom, t1.scaleZoom(s * o))), "wheel" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._delta = 0;
                }
                const o = "number" == typeof this._targetZoom ? this._targetZoom : i(), r = this._startZoom, n = this._easing;
                let s, a = !1;
                if ("wheel" === this._type && r && n) {
                    const t1 = Math.min((e1.exported.now() - this._lastWheelEventTime) / 200, 1), i = n(t1);
                    s = e1.number(r, o, i), t1 < 1 ? this._frameId || (this._frameId = !0) : a = !0;
                } else s = o, a = !0;
                return this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200)), {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: s - i(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t1) {
                let i = e1.ease;
                if (this._prevEase) {
                    const t1 = this._prevEase, o = (e1.exported.now() - t1.start) / t1.duration, r = t1.easing(o + .01) - t1.easing(o), n = .27 / Math.sqrt(r * r + 1e-4) * .01, s = Math.sqrt(.0729 - n * n);
                    i = e1.bezier(n, s, .25, 1);
                }
                return this._prevEase = {
                    start: e1.exported.now(),
                    duration: t1,
                    easing: i
                }, i;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e1.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 200);
            }
        }
        class Br {
            constructor(e1, t1){
                this._clickZoom = e1, this._tapZoom = t1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class kr {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e1, t1) {
                return e1.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (e1.shiftKey ? -1 : 1),
                            around: i.unproject(t1)
                        }, {
                            originalEvent: e1
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Fr {
            constructor(){
                this._tap = new mr({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e1, t1, i) {
                this._swipePoint || (this._tapTime && e1.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e1, t1, i));
            }
            touchmove(e1, t1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = t1[0], r = o.y - this._swipePoint.y;
                        return this._swipePoint = o, e1.preventDefault(), this._active = !0, {
                            zoomDelta: r / 128
                        };
                    }
                } else this._tap.touchmove(e1, t1, i);
            }
            touchend(e1, t1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e1, t1, i) && (this._tapTime = e1.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Ur {
            constructor(e1, t1, i){
                this._el = e1, this._mousePan = t1, this._touchPan = i;
            }
            enable(e1) {
                this._inertiaOptions = e1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class Nr {
            constructor(e1, t1, i){
                this._pitchWithRotate = e1.pitchWithRotate, this._mouseRotate = t1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class jr {
            constructor(e1, t1, i, o){
                this._el = e1, this._touchZoom = t1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e1) {
                this._touchZoom.enable(e1), this._rotationDisabled || this._touchRotate.enable(e1), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const Gr = (e1)=>e1.zoom || e1.drag || e1.pitch || e1.rotate;
        class Zr extends e1.Event {
        }
        class Vr {
            constructor(){
                this.constants = [
                    1,
                    1,
                    .01
                ], this.radius = 0;
            }
            setup(t1, i) {
                const o = e1.sub([], i, t1);
                this.radius = e1.length(o[2] < 0 ? e1.div([], o, this.constants) : [
                    o[0],
                    o[1],
                    0
                ]);
            }
            projectRay(t1) {
                e1.div(t1, t1, this.constants), e1.normalize(t1, t1), e1.mul$1(t1, t1, this.constants);
                const i = e1.scale$2([], t1, this.radius);
                if (i[2] > 0) {
                    const t1 = e1.scale$2([], [
                        0,
                        0,
                        1
                    ], e1.dot(i, [
                        0,
                        0,
                        1
                    ])), o = e1.scale$2([], e1.normalize([], [
                        i[0],
                        i[1],
                        0
                    ]), this.radius), r = e1.add([], i, e1.scale$2([], e1.sub([], e1.add([], o, t1), i), 2));
                    i[0] = r[0], i[1] = r[1];
                }
                return i;
            }
        }
        function Wr(e1) {
            return e1.panDelta && e1.panDelta.mag() || e1.zoomDelta || e1.bearingDelta || e1.pitchDelta;
        }
        class Xr {
            constructor(t1, i){
                this._map = t1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new rr(t1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Vr, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e1.bindAll([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        e1.window.document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        e1.window.document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        e1.window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [t1, i, o] of this._listeners)t1.addEventListener(i, t1 === e1.window.document ? this.handleWindowEvent : this.handleEvent, o);
            }
            destroy() {
                for (const [t1, i, o] of this._listeners)t1.removeEventListener(i, t1 === e1.window.document ? this.handleWindowEvent : this.handleEvent, o);
            }
            _addDefaultHandlers(e1) {
                const t1 = this._map, i = t1.getCanvasContainer();
                this._add("mapEvent", new hr(t1, e1));
                const o = t1.boxZoom = new _r(t1, e1);
                this._add("boxZoom", o);
                const r = new fr, n = new kr;
                t1.doubleClickZoom = new Br(n, r), this._add("tapZoom", r), this._add("clickZoom", n);
                const s = new Fr;
                this._add("tapDragZoom", s);
                const a = t1.touchPitch = new Dr(t1);
                this._add("touchPitch", a);
                const l = new yr(e1), c = new br(e1);
                t1.dragRotate = new Nr(e1, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new xr(e1), u = new wr(t1, e1);
                t1.dragPan = new Ur(i, h, u), this._add("mousePan", h), this._add("touchPan", u, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const _ = new Pr, d = new Mr;
                t1.touchZoomRotate = new jr(i, d, _, s), this._add("touchRotate", _, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", d, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new ur(t1));
                const p = t1.scrollZoom = new Or(t1, this);
                this._add("scrollZoom", p, [
                    "mousePan"
                ]);
                const m = t1.keyboard = new Ar;
                this._add("keyboard", m);
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e1.interactive && e1[i] && t1[i].enable(e1[i]);
            }
            _add(e1, t1, i) {
                this._handlers.push({
                    handlerName: e1,
                    handler: t1,
                    allowed: i
                }), this._handlersById[e1] = t1;
            }
            stop(e1) {
                if (!this._updatingCamera) {
                    for (const { handler: e1 } of this._handlers)e1.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, e1), this._changes = [];
                }
            }
            isActive() {
                for (const { handler: e1 } of this._handlers)if (e1.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!Gr(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e1, t1, i) {
                for(const o in e1)if (o !== i && (!t1 || t1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e1) {
                this.handleEvent(e1, `${e1.type}Window`);
            }
            _getMapTouches(e1) {
                const t1 = [];
                for (const i of e1)this._el.contains(i.target) && t1.push(i);
                return t1;
            }
            handleEvent(e1, t1) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e1.type, o = i ? void 0 : e1, r = {
                    needsRenderFrame: !1
                }, n = {}, s = {}, a = e1.touches ? this._getMapTouches(e1.touches) : void 0, l = a ? m(this._el, a) : i ? void 0 : p(this._el, e1);
                for (const { handlerName: i, handler: c, allowed: h } of this._handlers){
                    if (!c.isEnabled()) continue;
                    let u;
                    this._blockedByActive(s, h, i) ? c.reset() : c[t1 || e1.type] && (u = c[t1 || e1.type](e1, l, a), this.mergeHandlerResult(r, n, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (s[i] = c);
                }
                const c = {};
                for(const e1 in this._previousActiveHandlers)s[e1] || (c[e1] = o);
                this._previousActiveHandlers = s, (Object.keys(c).length || Wr(r)) && (this._changes.push([
                    r,
                    n,
                    c
                ]), this._triggerRenderFrame()), (Object.keys(s).length || Wr(r)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h } = r;
                h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }
            mergeHandlerResult(t1, i, o, r, n) {
                if (!o) return;
                e1.extend(t1, o);
                const s = {
                    handlerName: r,
                    originalEvent: o.originalEvent || n
                };
                void 0 !== o.zoomDelta && (i.zoom = s), void 0 !== o.panDelta && (i.drag = s), void 0 !== o.pitchDelta && (i.pitch = s), void 0 !== o.bearingDelta && (i.rotate = s);
            }
            _applyChanges() {
                const t1 = {}, i = {}, o = {};
                for (const [r, n, s] of this._changes)r.panDelta && (t1.panDelta = (t1.panDelta || new e1.Point(0, 0))._add(r.panDelta)), r.zoomDelta && (t1.zoomDelta = (t1.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t1.bearingDelta = (t1.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t1.pitchDelta = (t1.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t1.around = r.around), void 0 !== r.aroundCoord && (t1.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t1.pinchAround = r.pinchAround), r.noInertia && (t1.noInertia = r.noInertia), e1.extend(i, n), e1.extend(o, s);
                this._updateMapTransform(t1, i, o), this._changes = [];
            }
            _updateMapTransform(t1, i, o) {
                const r = this._map, n = r.transform, s = (e1)=>[
                        e1.x,
                        e1.y,
                        e1.z
                    ];
                if (((e1)=>{
                    const t1 = this._eventsInProgress.drag;
                    return t1 && !this._handlersById[t1.handlerName].isActive();
                })() && !Wr(t1)) {
                    const e1 = n.zoom;
                    n.cameraElevationReference = "sea", n.recenterOnTerrain(), n.cameraElevationReference = "ground", e1 !== n.zoom && this._map._update(!0);
                }
                if (n._isCameraConstrained && r._stop(!0), !Wr(t1)) return void this._fireEvents(i, o, !0);
                let { panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: u, aroundCoord: _, pinchAround: d } = t1;
                n._isCameraConstrained && (l > 0 && (l = 0), n._isCameraConstrained = !1), void 0 !== d && (u = d), (l || ((e1)=>i[e1] && !this._eventsInProgress[e1])("drag")) && u && (this._dragOrigin = s(n.pointCoordinate3D(u)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = "sea", r._stop(!0), u = u || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();
                const p = [
                    0,
                    0,
                    0
                ];
                if (a) {
                    if ("mercator" === n.projection.name) {
                        const e1 = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir), t1 = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);
                        p[0] = t1[0] - e1[0], p[1] = t1[1] - e1[1];
                    } else {
                        const t1 = n.pointCoordinate(u);
                        if ("globe" === n.projection.name) {
                            a = a.rotate(-n.angle);
                            const i = n._pixelsPerMercatorPixel / n.worldSize;
                            p[0] = -a.x * e1.mercatorScale(e1.latFromMercatorY(t1.y)) * i, p[1] = -a.y * e1.mercatorScale(n.center.lat) * i;
                        } else {
                            const e1 = n.pointCoordinate(u.sub(a));
                            t1 && e1 && (p[0] = e1.x - t1.x, p[1] = e1.y - t1.y);
                        }
                    }
                }
                const m = n.zoom, f = [
                    0,
                    0,
                    0
                ];
                if (l) {
                    const t1 = s(_ || n.pointCoordinate3D(u)), i = {
                        dir: e1.normalize([], e1.sub([], t1, n._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const o = n.zoomDeltaToMovement(t1, l);
                        e1.scale$2(f, i.dir, o);
                    }
                }
                const g = e1.add(p, p, f);
                n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = "ground", this._map._update(), t1.noInertia || this._inertia.record(t1), this._fireEvents(i, o, !0);
            }
            _fireEvents(t1, i, o) {
                const r = Gr(this._eventsInProgress), n = Gr(t1), s = {};
                for(const e1 in t1){
                    const { originalEvent: i } = t1[e1];
                    this._eventsInProgress[e1] || (s[`${e1}start`] = i), this._eventsInProgress[e1] = t1[e1];
                }
                !r && n && this._fireEvent("movestart", n.originalEvent);
                for(const e1 in s)this._fireEvent(e1, s[e1]);
                n && this._fireEvent("move", n.originalEvent);
                for(const e1 in t1){
                    const { originalEvent: i } = t1[e1];
                    this._fireEvent(e1, i);
                }
                const a = {};
                let l;
                for(const e1 in this._eventsInProgress){
                    const { handlerName: t1, originalEvent: o } = this._eventsInProgress[e1];
                    this._handlersById[t1].isActive() || (delete this._eventsInProgress[e1], l = i[t1] || o, a[`${e1}end`] = l);
                }
                for(const e1 in a)this._fireEvent(e1, a[e1]);
                const c = Gr(this._eventsInProgress);
                if (o && (r || n) && !c) {
                    this._updatingCamera = !0;
                    const t1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (e1)=>0 !== e1 && -this._bearingSnap < e1 && e1 < this._bearingSnap;
                    t1 ? (i(t1.bearing || this._map.getBearing()) && (t1.bearing = 0), this._map.easeTo(t1, {
                        originalEvent: l
                    })) : (this._map.fire(new e1.Event("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t1, i) {
                this._map.fire(new e1.Event(t1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e1)=>{
                    this._frameId = void 0, this.handleEvent(new Zr("renderFrame", {
                        timeStamp: e1
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const qr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class $r extends e1.Evented {
            constructor(t1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = t1, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e1.bindAll([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e1.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e1, t1) {
                return this.jumpTo({
                    center: e1
                }, t1);
            }
            panBy(t1, i, o) {
                return t1 = e1.Point.convert(t1).mult(-1), this.panTo(this.transform.center, e1.extend({
                    offset: t1
                }, i), o);
            }
            panTo(t1, i, o) {
                return this.easeTo(e1.extend({
                    center: t1
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e1, t1) {
                return this.jumpTo({
                    zoom: e1
                }, t1), this;
            }
            zoomTo(t1, i, o) {
                return this.easeTo(e1.extend({
                    zoom: t1
                }, i), o);
            }
            zoomIn(e1, t1) {
                return this.zoomTo(this.getZoom() + 1, e1, t1), this;
            }
            zoomOut(e1, t1) {
                return this.zoomTo(this.getZoom() - 1, e1, t1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e1, t1) {
                return this.jumpTo({
                    bearing: e1
                }, t1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e1, t1) {
                return this.jumpTo({
                    padding: e1
                }, t1), this;
            }
            rotateTo(t1, i, o) {
                return this.easeTo(e1.extend({
                    bearing: t1
                }, i), o);
            }
            resetNorth(t1, i) {
                return this.rotateTo(0, e1.extend({
                    duration: 1e3
                }, t1), i), this;
            }
            resetNorthPitch(t1, i) {
                return this.easeTo(e1.extend({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, t1), i), this;
            }
            snapToNorth(e1, t1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e1, t1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e1, t1) {
                return this.jumpTo({
                    pitch: e1
                }, t1), this;
            }
            cameraForBounds(t1, i) {
                t1 = e1.LngLatBounds.convert(t1);
                const o = i && i.bearing || 0, r = i && i.pitch || 0, n = t1.getNorthWest(), s = t1.getSouthEast();
                return this._cameraForBounds(this.transform, n, s, o, r, i);
            }
            _extendCameraOptions(t1) {
                const i = {
                    top: 0,
                    bottom: 0,
                    right: 0,
                    left: 0
                };
                if ("number" == typeof (t1 = e1.extend({
                    padding: i,
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, t1)).padding) {
                    const e1 = t1.padding;
                    t1.padding = {
                        top: e1,
                        bottom: e1,
                        right: e1,
                        left: e1
                    };
                }
                return t1.padding = e1.extend(i, t1.padding), t1;
            }
            _minimumAABBFrustumDistance(e1, t1) {
                const i = t1.max[0] - t1.min[0], o = t1.max[1] - t1.min[1];
                return i / o > e1.aspect ? i / (2 * Math.tan(.5 * e1.fovX) * e1.aspect) : o / (2 * Math.tan(.5 * e1.fovY) * e1.aspect);
            }
            _cameraForBoundsOnGlobe(t1, i, o, r, n, s) {
                const a = t1.clone(), l = this._extendCameraOptions(s);
                a.bearing = r, a.pitch = n;
                const c = e1.LngLat.convert(i), h = e1.LngLat.convert(o), u = .5 * (c.lat + h.lat), _ = .5 * (c.lng + h.lng), d = e1.latLngToECEF(u, _), p = e1.normalize([], d), m = e1.normalize([], e1.cross([], p, [
                    0,
                    1,
                    0
                ])), f = e1.cross([], m, p), g = [
                    m[0],
                    m[1],
                    m[2],
                    0,
                    f[0],
                    f[1],
                    f[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v = [
                    d,
                    e1.latLngToECEF(c.lat, c.lng),
                    e1.latLngToECEF(h.lat, c.lng),
                    e1.latLngToECEF(h.lat, h.lng),
                    e1.latLngToECEF(c.lat, h.lng),
                    e1.latLngToECEF(u, c.lng),
                    e1.latLngToECEF(u, h.lng),
                    e1.latLngToECEF(c.lat, _),
                    e1.latLngToECEF(h.lat, _)
                ];
                let x = e1.Aabb.fromPoints(v.map((t1)=>[
                        e1.dot(m, t1),
                        e1.dot(f, t1),
                        e1.dot(p, t1)
                    ]));
                const y = e1.transformMat4([], x.center, g);
                0 === e1.squaredLength(y) && e1.set(y, 0, 0, 1), e1.normalize(y, y), e1.scale$2(y, y, e1.GLOBE_RADIUS), a.center = e1.ecefToLatLng(y);
                const b = a.getWorldToCameraMatrix(), w = e1.invert(new Float64Array(16), b);
                x = e1.Aabb.applyTransform(x, e1.multiply([], b, g)), e1.transformMat4(y, y, b);
                const T = .5 * (x.max[2] - x.min[2]), E = this._minimumAABBFrustumDistance(a, x), C = e1.scale$2([], [
                    0,
                    0,
                    1
                ], T), M = e1.add(C, y, C), I = E + (0 === a.pitch ? 0 : e1.distance(y, M)), P = a.globeCenterInViewSpace, S = e1.sub([], y, [
                    P[0],
                    P[1],
                    P[2]
                ]);
                e1.normalize(S, S), e1.scale$2(S, S, I);
                const D = e1.add([], y, S);
                e1.transformMat4(D, D, w);
                const L = e1.earthRadius / e1.GLOBE_RADIUS, A = e1.length(D), z = e1.mercatorZfromAltitude(Math.max(A * L - e1.earthRadius, Number.EPSILON), 0), R = Math.min(a.zoomFromMercatorZAdjusted(z), l.maxZoom);
                return R > .5 * (e1.GLOBE_ZOOM_THRESHOLD_MIN + e1.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                    name: "mercator"
                }), a.zoom = R, this._cameraForBounds(a, i, o, r, n, s)) : {
                    center: a.center,
                    zoom: R,
                    bearing: r,
                    pitch: n
                };
            }
            queryTerrainElevation(t1, i) {
                const o = this.transform.elevation;
                return o ? (i = e1.extend({}, {
                    exaggerated: !0
                }, i), o.getAtPoint(e1.MercatorCoordinate.fromLngLat(t1), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t1, i, o, r, n, s) {
                if ("globe" === t1.projection.name) return this._cameraForBoundsOnGlobe(t1, i, o, r, n, s);
                const a = t1.clone(), l = this._extendCameraOptions(s), c = a.padding;
                a.bearing = r, a.pitch = n;
                const h = e1.LngLat.convert(i), u = e1.LngLat.convert(o), _ = new e1.LngLat(h.lng, u.lat), d = new e1.LngLat(u.lng, h.lat), p = a.project(h), m = a.project(u), f = this.queryTerrainElevation(h), g = this.queryTerrainElevation(u), v = this.queryTerrainElevation(_), x = this.queryTerrainElevation(d), y = [
                    [
                        p.x,
                        p.y,
                        Math.min(f || 0, g || 0, v || 0, x || 0)
                    ],
                    [
                        m.x,
                        m.y,
                        Math.max(f || 0, g || 0, v || 0, x || 0)
                    ]
                ];
                let b = e1.Aabb.fromPoints(y);
                const w = a.getWorldToCameraMatrix(), T = e1.invert(new Float64Array(16), w);
                b = e1.Aabb.applyTransform(b, w);
                const E = e1.sub([], b.max, b.min), C = c.left || 0, M = c.right || 0, I = c.bottom || 0, P = c.top || 0, { left: S, right: D, top: L, bottom: A } = l.padding, z = .5 * (C + M), R = .5 * (P + I), O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + M + S + D)) / E[0], (a.height - (I + P + A + L)) / E[1])), l.maxZoom), B = a.scale / a.zoomScale(O);
                b = new e1.Aabb([
                    b.min[0] - (S + z) * B,
                    b.min[1] - (A + R) * B,
                    b.min[2]
                ], [
                    b.max[0] + (D + z) * B,
                    b.max[1] + (L + R) * B,
                    b.max[2]
                ]);
                const k = .5 * E[2], F = this._minimumAABBFrustumDistance(a, b), U = [
                    0,
                    0,
                    1,
                    0
                ];
                e1.transformMat4$1(U, U, w), e1.normalize$2(U, U);
                const N = e1.scale$2([], U, F + k), j = e1.add([], b.center, N), G = ("number" == typeof l.offset.x && "number" == typeof l.offset.y ? new e1.Point(l.offset.x, l.offset.y) : e1.Point.convert(l.offset)).rotate(-e1.degToRad(r));
                b.center[0] -= G.x * B, b.center[1] += G.y * B, e1.transformMat4(b.center, b.center, T), e1.transformMat4(j, j, T);
                const Z = [
                    b.center[0],
                    b.center[1],
                    j[2] * a.pixelsPerMeter
                ];
                e1.scale$2(Z, Z, 1 / a.worldSize);
                const V = e1.lngFromMercatorX(Z[0]), W = e1.latFromMercatorY(Z[1]), X = Math.min(a._zoomFromMercatorZ(Z[2]), l.maxZoom), q = new e1.LngLat(V, W);
                return a.mercatorFromTransition && X < .5 * (e1.GLOBE_ZOOM_THRESHOLD_MIN + e1.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                    name: "globe"
                }), a.zoom = X, this._cameraForBounds(a, i, o, r, n, s)) : {
                    center: q,
                    zoom: X,
                    bearing: r,
                    pitch: n
                };
            }
            fitBounds(e1, t1, i) {
                const o = this.cameraForBounds(e1, t1);
                return this._fitInternal(o, t1, i);
            }
            fitScreenCoordinates(t1, i, o, r, n) {
                const s = e1.Point.convert(t1), a = e1.Point.convert(i), l = new e1.Point(Math.min(s.x, a.x), Math.min(s.y, a.y)), c = new e1.Point(Math.max(s.x, a.x), Math.max(s.y, a.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a)) return this;
                const h = this.transform.pointLocation3D(l), u = this.transform.pointLocation3D(c), _ = this.transform.pointLocation3D(new e1.Point(l.x, c.y)), d = this.transform.pointLocation3D(new e1.Point(c.x, l.y)), p = [
                    Math.min(h.lng, u.lng, _.lng, d.lng),
                    Math.min(h.lat, u.lat, _.lat, d.lat)
                ], m = [
                    Math.max(h.lng, u.lng, _.lng, d.lng),
                    Math.max(h.lat, u.lat, _.lat, d.lat)
                ], f = r && r.pitch ? r.pitch : this.getPitch(), g = this._cameraForBounds(this.transform, p, m, o, f, r);
                return this._fitInternal(g, r, n);
            }
            _fitInternal(t1, i, o) {
                return t1 ? (delete (i = e1.extend(t1, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
            }
            jumpTo(t1, i) {
                this.stop();
                const o = t1.preloadOnly ? this.transform.clone() : this.transform;
                let r = !1, n = !1, s = !1;
                return "zoom" in t1 && o.zoom !== +t1.zoom && (r = !0, o.zoom = +t1.zoom), void 0 !== t1.center && (o.center = e1.LngLat.convert(t1.center)), "bearing" in t1 && o.bearing !== +t1.bearing && (n = !0, o.bearing = +t1.bearing), "pitch" in t1 && o.pitch !== +t1.pitch && (s = !0, o.pitch = +t1.pitch), null == t1.padding || o.isPaddingEqual(t1.padding) || (o.padding = t1.padding), t1.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e1.Event("movestart", i)).fire(new e1.Event("move", i)), r && this.fire(new e1.Event("zoomstart", i)).fire(new e1.Event("zoom", i)).fire(new e1.Event("zoomend", i)), n && this.fire(new e1.Event("rotatestart", i)).fire(new e1.Event("rotate", i)).fire(new e1.Event("rotateend", i)), s && this.fire(new e1.Event("pitchstart", i)).fire(new e1.Event("pitch", i)).fire(new e1.Event("pitchend", i)), this.fire(new e1.Event("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e1.warnOnce(qr), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t1, i) {
                const o = this.transform;
                if (!o.projection.supportsFreeCamera) return e1.warnOnce(qr), this;
                this.stop();
                const r = o.zoom, n = o.pitch, s = o.bearing;
                o.setFreeCameraOptions(t1);
                const a = r !== o.zoom, l = n !== o.pitch, c = s !== o.bearing;
                return this.fire(new e1.Event("movestart", i)).fire(new e1.Event("move", i)), a && this.fire(new e1.Event("zoomstart", i)).fire(new e1.Event("zoom", i)).fire(new e1.Event("zoomend", i)), c && this.fire(new e1.Event("rotatestart", i)).fire(new e1.Event("rotate", i)).fire(new e1.Event("rotateend", i)), l && this.fire(new e1.Event("pitchstart", i)).fire(new e1.Event("pitch", i)).fire(new e1.Event("pitchend", i)), this.fire(new e1.Event("moveend", i)), this;
            }
            easeTo(t1, i) {
                this._stop(!1, t1.easeId), (!1 === (t1 = e1.extend({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e1.ease
                }, t1)).animate || this._prefersReducedMotion(t1)) && (t1.duration = 0);
                const o = this.transform, r = this.getZoom(), n = this.getBearing(), s = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? +t1.zoom : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, n) : n, h = "pitch" in t1 ? +t1.pitch : s, u = "padding" in t1 ? t1.padding : o.padding, _ = e1.Point.convert(t1.offset);
                let d, p, m;
                if ("globe" === o.projection.name) {
                    const i = e1.MercatorCoordinate.fromLngLat(o.center), r = _.rotate(-o.angle);
                    i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;
                    const n = i.toLngLat(), s = e1.LngLat.convert(t1.center || n);
                    this._normalizeCenter(s), d = o.centerPoint.add(r), p = new e1.Point(i.x, i.y).mult(o.worldSize), m = new e1.Point(e1.mercatorXfromLng(s.lng), e1.mercatorYfromLat(s.lat)).mult(o.worldSize).sub(p);
                } else {
                    d = o.centerPoint.add(_);
                    const i = o.pointLocation(d), r = e1.LngLat.convert(t1.center || i);
                    this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);
                }
                const f = o.zoomScale(l - r);
                let g, v;
                t1.around && (g = e1.LngLat.convert(t1.around), v = o.locationPoint(g));
                const x = this._zooming || l !== r, y = this._rotating || n !== c, b = this._pitching || h !== s, w = !o.isPaddingEqual(u), T = (o)=>(T)=>{
                        if (x && (o.zoom = e1.number(r, l, T)), y && (o.bearing = e1.number(n, c, T)), b && (o.pitch = e1.number(s, h, T)), w && (o.interpolatePadding(a, u, T), d = o.centerPoint.add(_)), g) o.setLocationAtPoint(g, v);
                        else {
                            const e1 = o.zoomScale(o.zoom - r), t1 = l > r ? Math.min(2, f) : Math.max(.5, f), i = Math.pow(t1, 1 - T), n = o.unproject(p.add(m.mult(T * i)).mult(e1));
                            o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);
                        }
                        return t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e1 = this._emulate(T, t1.duration, o);
                    return this._preloadTiles(e1), this;
                }
                const E = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t1.easeId, this._prepareEase(i, t1.noMoveStart, E), this._ease(T(o), (e1)=>{
                    o.recenterOnTerrain(), this._afterEase(i, e1);
                }, t1), this;
            }
            _prepareEase(t1, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", i || o.moving || this.fire(new e1.Event("movestart", t1)), this._zooming && !o.zooming && this.fire(new e1.Event("zoomstart", t1)), this._rotating && !o.rotating && this.fire(new e1.Event("rotatestart", t1)), this._pitching && !o.pitching && this.fire(new e1.Event("pitchstart", t1));
            }
            _fireMoveEvents(t1) {
                this.fire(new e1.Event("move", t1)), this._zooming && this.fire(new e1.Event("zoom", t1)), this._rotating && this.fire(new e1.Event("rotate", t1)), this._pitching && this.fire(new e1.Event("pitch", t1));
            }
            _afterEase(t1, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o = this._zooming, r = this._rotating, n = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e1.Event("zoomend", t1)), r && this.fire(new e1.Event("rotateend", t1)), n && this.fire(new e1.Event("pitchend", t1)), this.fire(new e1.Event("moveend", t1));
            }
            flyTo(t1, i) {
                if (this._prefersReducedMotion(t1)) {
                    const o = e1.pick(t1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), t1 = e1.extend({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e1.ease
                }, t1);
                const o = this.transform, r = this.getZoom(), n = this.getBearing(), s = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? e1.clamp(+t1.zoom, o.minZoom, o.maxZoom) : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, n) : n, h = "pitch" in t1 ? +t1.pitch : s, u = "padding" in t1 ? t1.padding : o.padding, _ = o.zoomScale(l - r), d = e1.Point.convert(t1.offset);
                let p = o.centerPoint.add(d);
                const m = o.pointLocation(p), f = e1.LngLat.convert(t1.center || m);
                this._normalizeCenter(f);
                const g = o.project(m), v = o.project(f).sub(g);
                let x = t1.curve;
                const y = Math.max(o.width, o.height), b = y / _, w = v.mag();
                if ("minZoom" in t1) {
                    const i = e1.clamp(Math.min(t1.minZoom, r, l), o.minZoom, o.maxZoom), n = y / o.zoomScale(i - r);
                    x = Math.sqrt(n / w * 2);
                }
                const T = x * x;
                function E(e1) {
                    const t1 = (b * b - y * y + (e1 ? -1 : 1) * T * T * w * w) / (2 * (e1 ? b : y) * T * w);
                    return Math.log(Math.sqrt(t1 * t1 + 1) - t1);
                }
                function C(e1) {
                    return (Math.exp(e1) - Math.exp(-e1)) / 2;
                }
                function M(e1) {
                    return (Math.exp(e1) + Math.exp(-e1)) / 2;
                }
                const I = E(0);
                let P = function(e1) {
                    return M(I) / M(I + x * e1);
                }, S = function(e1) {
                    var t1;
                    return y * ((M(I) * (C(t1 = I + x * e1) / M(t1)) - C(I)) / T) / w;
                }, D = (E(1) - I) / x;
                if (Math.abs(w) < 1e-6 || !isFinite(D)) {
                    if (Math.abs(y - b) < 1e-6) return this.easeTo(t1, i);
                    const e1 = b < y ? -1 : 1;
                    D = Math.abs(Math.log(b / y)) / x, S = function() {
                        return 0;
                    }, P = function(t1) {
                        return Math.exp(e1 * x * t1);
                    };
                }
                t1.duration = "duration" in t1 ? +t1.duration : 1e3 * D / ("screenSpeed" in t1 ? +t1.screenSpeed / x : +t1.speed), t1.maxDuration && t1.duration > t1.maxDuration && (t1.duration = 0);
                const L = n !== c, A = h !== s, z = !o.isPaddingEqual(u), R = (o)=>(_)=>{
                        const m = _ * D, x = 1 / P(m);
                        o.zoom = 1 === _ ? l : r + o.scaleZoom(x), L && (o.bearing = e1.number(n, c, _)), A && (o.pitch = e1.number(s, h, _)), z && (o.interpolatePadding(a, u, _), p = o.centerPoint.add(d));
                        const y = 1 === _ ? f : o.unproject(g.add(v.mult(S(m))).mult(x));
                        return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e1 = this._emulate(R, t1.duration, o);
                    return this._preloadTiles(e1), this;
                }
                return this._zooming = !0, this._rotating = L, this._pitching = A, this._padding = z, this._prepareEase(i, !1), this._ease(R(o), ()=>this._afterEase(i), t1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _stop(e1, t1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e1 = this._onEaseEnd;
                    this._onEaseEnd = void 0, e1.call(this, t1);
                }
                if (!e1) {
                    const e1 = this.handlers;
                    e1 && e1.stop(!1);
                }
                return this;
            }
            _ease(t1, i, o) {
                !1 === o.animate || 0 === o.duration ? (t1(1), i()) : (this._easeStart = e1.exported.now(), this._easeOptions = o, this._onEaseFrame = t1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t1 = Math.min((e1.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i = this._onEaseFrame;
                i && i(this._easeOptions.easing(t1)), t1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t1, i) {
                t1 = e1.wrap(t1, -180, 180);
                const o = Math.abs(t1 - i);
                return Math.abs(t1 - 360 - i) < o && (t1 -= 360), Math.abs(t1 + 360 - i) < o && (t1 += 360), t1;
            }
            _normalizeCenter(e1) {
                const t1 = this.transform;
                if (!t1.renderWorldCopies || t1.maxBounds) return;
                const i = e1.lng - t1.center.lng;
                e1.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t1) {
                return this._respectPrefersReducedMotion && e1.exported.prefersReducedMotion && !(t1 && t1.essential);
            }
            _emulate(e1, t1, i) {
                const o = Math.ceil(15 * t1 / 1e3), r = [], n = e1(i.clone());
                for(let e1 = 0; e1 <= o; e1++){
                    const t1 = n(e1 / o);
                    r.push(t1.clone());
                }
                return r;
            }
        }
        class Hr {
            constructor(t1 = {}){
                this.options = t1, e1.bindAll([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e1) {
                const t1 = this.options && this.options.compact;
                return this._map = e1, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e1, t1) {
                const i = this._map._getUIString(`AttributionControl.${t1}`);
                e1.setAttribute("aria-label", i), e1.removeAttribute("title"), e1.firstElementChild && e1.firstElementChild.setAttribute("title", i);
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t1 = this._editLink;
                t1 || (t1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e1.config.ACCESS_TOKEN
                    }
                ];
                if (t1) {
                    const o = i.reduce((e1, t1, o)=>(t1.value && (e1 += `${t1.key}=${t1.value}${o < i.length - 1 ? "&" : ""}`), e1), "?");
                    t1.href = `${e1.config.FEEDBACK_URL}/${o}#${Jo(this._map, !0)}`, t1.rel = "noopener nofollow", this._setElementTitle(t1, "MapFeedback");
                }
            }
            _updateData(e1) {
                !e1 || "metadata" !== e1.sourceDataType && "visibility" !== e1.sourceDataType && "style" !== e1.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e1 = [];
                if (this._map.style.stylesheet) {
                    const e1 = this._map.style.stylesheet;
                    this.styleOwner = e1.owner, this.styleId = e1.id;
                }
                const t1 = this._map.style._sourceCaches;
                for(const i in t1){
                    const o = t1[i];
                    if (o.used) {
                        const t1 = o.getSource();
                        t1.attribution && e1.indexOf(t1.attribution) < 0 && e1.push(t1.attribution);
                    }
                }
                e1.sort((e1, t1)=>e1.length - t1.length), e1 = e1.filter((t1, i)=>{
                    for(let o = i + 1; o < e1.length; o++)if (e1[o].indexOf(t1) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e1 = [
                    ...this.options.customAttribution,
                    ...e1
                ] : e1.unshift(this.options.customAttribution));
                const i = e1.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, e1.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class Yr {
            constructor(){
                e1.bindAll([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e1) {
                this._map = e1, this._container = n("div", "mapboxgl-ctrl");
                const t1 = n("a", "mapboxgl-ctrl-logo");
                return t1.target = "_blank", t1.rel = "noopener nofollow", t1.href = "https://www.mapbox.com/", t1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e1) {
                e1 && "metadata" !== e1.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e1 = this._map.style._sourceCaches;
                if (0 === Object.entries(e1).length) return !0;
                for(const t1 in e1){
                    const i = e1[t1].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e1 = this._container.children;
                if (e1.length) {
                    const t1 = e1[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t1.classList.add("mapboxgl-compact") : t1.classList.remove("mapboxgl-compact");
                }
            }
        }
        class Kr {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e1) {
                const t1 = ++this._id;
                return this._queue.push({
                    callback: e1,
                    id: t1,
                    cancelled: !1
                }), t1;
            }
            remove(e1) {
                const t1 = this._currentlyRunning, i = t1 ? this._queue.concat(t1) : this._queue;
                for (const t1 of i)if (t1.id === e1) return void (t1.cancelled = !0);
            }
            run(e1 = 0) {
                const t1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of t1)if (!i.cancelled && (i.callback(e1), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        function Jr(t1, i, o) {
            if (t1 = new e1.LngLat(t1.lng, t1.lat), i) {
                const r = new e1.LngLat(t1.lng - 360, t1.lat), n = new e1.LngLat(t1.lng + 360, t1.lat), s = 360 * Math.ceil(Math.abs(t1.lng - o.center.lng) / 360), a = o.locationPoint(t1).distSqr(i), l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
                o.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < s) ? t1 = r : o.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - o.center.lng) < s) && (t1 = n);
            }
            for(; Math.abs(t1.lng - o.center.lng) > 180;){
                const e1 = o.locationPoint(t1);
                if (e1.x >= 0 && e1.y >= 0 && e1.x <= o.width && e1.y <= o.height) break;
                t1.lng > o.center.lng ? t1.lng -= 360 : t1.lng += 360;
            }
            return t1;
        }
        const Qr = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class en extends e1.Evented {
            constructor(t1, i){
                if (super(), (t1 instanceof e1.window.HTMLElement || i) && (t1 = e1.extend({
                    element: t1
                }, i)), e1.bindAll([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this), this._anchor = t1 && t1.anchor || "center", this._color = t1 && t1.color || "#3FB1CE", this._scale = t1 && t1.scale || 1, this._draggable = t1 && t1.draggable || !1, this._clickTolerance = t1 && t1.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t1 && t1.rotation || 0, this._rotationAlignment = t1 && t1.rotationAlignment || "auto", this._pitchAlignment = t1 && t1.pitchAlignment && t1.pitchAlignment || "auto", this._updateMoving = ()=>this._update(!0), this._occludedOpacity = t1 && t1.occludedOpacity || .2, t1 && t1.element) this._element = t1.element, this._offset = e1.Point.convert(t1 && t1.offset || [
                    0,
                    0
                ]);
                else {
                    this._defaultMarker = !0, this._element = n("div");
                    const i = 41, o = 27, r = s("svg", {
                        display: "block",
                        height: i * this._scale + "px",
                        width: o * this._scale + "px",
                        viewBox: `0 0 ${o} ${i}`
                    }, this._element), a = s("radialGradient", {
                        id: "shadowGradient"
                    }, s("defs", {}, r));
                    s("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, a), s("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, a), s("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, r), s("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, r), s("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, r), s("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, r), this._offset = e1.Point.convert(t1 && t1.offset || [
                        0,
                        -14
                    ]);
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e1)=>{
                    e1.preventDefault();
                }), this._element.addEventListener("mousedown", (e1)=>{
                    e1.preventDefault();
                });
                const o = this._element.classList;
                for(const e1 in Qr)o.remove(`mapboxgl-marker-anchor-${e1}`);
                o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
            }
            addTo(e1) {
                return e1 === this._map || (this.remove(), this._map = e1, e1.getCanvasContainer().appendChild(this._element), e1.on("move", this._updateMoving), e1.on("moveend", this._update), e1.on("remove", this._clearFadeTimer), e1._addMarker(this), this.setDraggable(this._draggable), this._update(), e1.on("click", this._onMapClick)), this;
            }
            remove() {
                const e1 = this._map;
                return e1 && (e1.off("click", this._onMapClick), e1.off("move", this._updateMoving), e1.off("moveend", this._update), e1.off("mousedown", this._addDragHandler), e1.off("touchstart", this._addDragHandler), e1.off("mouseup", this._onUp), e1.off("touchend", this._onUp), e1.off("mousemove", this._onMove), e1.off("touchmove", this._onMove), e1.off("remove", this._clearFadeTimer), e1._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t1) {
                return this._lngLat = e1.LngLat.convert(t1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            getElement() {
                return this._element;
            }
            setPopup(e1) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e1) {
                    if (!("offset" in e1.options)) {
                        const t1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        e1.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (t1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (t1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (t1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (t1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = e1, e1._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e1) {
                const t1 = e1.code, i = e1.charCode || e1.keyCode;
                "Space" !== t1 && "Enter" !== t1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(e1) {
                const t1 = e1.originalEvent.target, i = this._element;
                this._popup && (t1 === i || i.contains(t1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e1 = this._popup;
                return e1 ? (e1.isOpen() ? (e1.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e1.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e1 = this._map, t1 = this._pos;
                if (!e1 || !t1) return !1;
                const i = e1.unproject(t1), o = e1.getFreeCameraOptions();
                if (!o.position) return !1;
                const r = o.position.toLngLat();
                return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t1 = this._map;
                if (!t1) return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > t1.transform.width || i.y < 0 || i.y > t1.transform.height) return void this._clearFadeTimer();
                const o = t1.unproject(i);
                let r;
                t1._showingGlobe() && e1.isLngLatBehindGlobe(t1.transform, this._lngLat) ? r = 0 : (r = 1 - t1._queryFogOpacity(o), t1.transform._terrainEnabled() && t1.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e1 = this._pos;
                if (!e1 || !this._map) return;
                const t1 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e1.x}px,${e1.y}px)\n            ${Qr[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t1.x}px,${t1.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t1 = this._pos, i = this._map, o = this.getPitchAlignment();
                if (!i || !t1 || "map" !== o) return "";
                if (!i._showingGlobe()) {
                    const e1 = i.getPitch();
                    return e1 ? `rotateX(${e1}deg)` : "";
                }
                const r = e1.radToDeg(e1.globeTiltAtLngLat(i.transform, this._lngLat)), n = t1.sub(e1.globeCenterToScreenPoint(i.transform)), s = Math.abs(n.x) + Math.abs(n.y);
                if (0 === s) return "";
                const a = r / s;
                return `rotateX(${-n.y * a}deg) rotateY(${n.x * a}deg)`;
            }
            _calculateZTransform() {
                const t1 = this._pos, i = this._map;
                if (!i || !t1) return "";
                let o = 0;
                const r = this.getRotationAlignment();
                if ("map" === r) {
                    if (i._showingGlobe()) {
                        const t1 = i.project(new e1.LngLat(this._lngLat.lng, this._lngLat.lat + .001)), r = i.project(new e1.LngLat(this._lngLat.lng, this._lngLat.lat - .001)).sub(t1);
                        o = e1.radToDeg(Math.atan2(r.y, r.x)) - 90;
                    } else o = -i.getBearing();
                } else if ("horizon" === r) {
                    const r = e1.smoothstep(4, 6, i.getZoom()), n = e1.globeCenterToScreenPoint(i.transform);
                    n.y += r * i.transform.height;
                    const s = t1.sub(n), a = e1.radToDeg(Math.atan2(s.y, s.x));
                    o = (a > 90 ? a - 270 : a + 90) * (1 - r);
                }
                return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }
            _update(t1) {
                e1.window.cancelAnimationFrame(this._updateFrameId);
                const i = this._map;
                i && (i.transform.renderWorldCopies && (this._lngLat = Jr(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t1 ? this._updateFrameId = e1.window.requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), i._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t1) {
                return this._offset = e1.Point.convert(t1), this._update(), this;
            }
            _onMove(t1) {
                const i = this._map;
                if (!i) return;
                const o = this._pointerdownPos, r = this._positionDelta;
                if (o && r) {
                    if (!this._isDragging) {
                        const e1 = this._clickTolerance || i._clickTolerance;
                        if (t1.point.dist(o) < e1) return;
                        this._isDragging = !0;
                    }
                    this._pos = t1.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e1.Event("dragstart"))), this.fire(new e1.Event("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t1 = this._map;
                t1 && (t1.off("mousemove", this._onMove), t1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e1.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(e1) {
                const t1 = this._map, i = this._pos;
                t1 && i && this._element.contains(e1.originalEvent.target) && (e1.preventDefault(), this._positionDelta = e1.point.sub(i), this._pointerdownPos = e1.point, this._state = "pending", t1.on("mousemove", this._onMove), t1.on("touchmove", this._onMove), t1.once("mouseup", this._onUp), t1.once("touchend", this._onUp));
            }
            setDraggable(e1) {
                this._draggable = !!e1;
                const t1 = this._map;
                return t1 && (e1 ? (t1.on("mousedown", this._addDragHandler), t1.on("touchstart", this._addDragHandler)) : (t1.off("mousedown", this._addDragHandler), t1.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e1) {
                return this._rotation = e1 || 0, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e1) {
                return this._rotationAlignment = e1 || "auto", this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e1) {
                return this._pitchAlignment = e1 || "auto", this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e1) {
                return this._occludedOpacity = e1 || .2, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const tn = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }, on = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function rn(t1 = new e1.Point(0, 0), i = "bottom") {
            if ("number" == typeof t1) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t1, 2)));
                switch(i){
                    case "top":
                        return new e1.Point(0, t1);
                    case "top-left":
                        return new e1.Point(o, o);
                    case "top-right":
                        return new e1.Point(-o, o);
                    case "bottom":
                        return new e1.Point(0, -t1);
                    case "bottom-left":
                        return new e1.Point(o, -o);
                    case "bottom-right":
                        return new e1.Point(-o, -o);
                    case "left":
                        return new e1.Point(t1, 0);
                    case "right":
                        return new e1.Point(-t1, 0);
                }
                return new e1.Point(0, 0);
            }
            return t1 instanceof e1.Point || Array.isArray(t1) ? e1.Point.convert(t1) : e1.Point.convert(t1[i] || [
                0,
                0
            ]);
        }
        class nn {
            constructor(e1){
                this.jumpTo(e1);
            }
            getValue(t1) {
                if (t1 <= this._startTime) return this._start;
                if (t1 >= this._endTime) return this._end;
                const i = e1.easeCubicInOut((t1 - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i;
            }
            isEasing(e1) {
                return e1 >= this._startTime && e1 <= this._endTime;
            }
            jumpTo(e1) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e1, this._end = e1;
            }
            easeTo(e1, t1, i) {
                this._start = this.getValue(t1), this._end = e1, this._startTime = t1, this._endTime = t1 + i;
            }
        }
        const sn = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox logo",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        }, an = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            optimizeForTerrain: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            respectPrefersReducedMotion: !0,
            crossSourceCollisions: !0
        }, ln = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class cn {
            constructor(t1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new yr({
                    clickTolerance: t1.dragRotate._mouseRotate._clickTolerance
                }), this.map = t1, o && (this.mousePitch = new br({
                    clickTolerance: t1.dragRotate._mousePitch._clickTolerance
                })), e1.bindAll([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }
            down(e1, t1) {
                this.mouseRotate.mousedown(e1, t1), this.mousePitch && this.mousePitch.mousedown(e1, t1), h();
            }
            move(e1, t1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(e1, t1), r = o && o.bearingDelta;
                if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e1, t1), r = o && o.pitchDelta;
                    r && i.setPitch(i.getPitch() + r);
                }
            }
            off() {
                const e1 = this.element;
                e1.removeEventListener("mousedown", this.mousedown), e1.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), e1.removeEventListener("touchmove", this.touchmove), e1.removeEventListener("touchend", this.touchend), e1.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                u(), e1.window.removeEventListener("mousemove", this.mousemove), e1.window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t1) {
                this.down(e1.extend({}, t1, {
                    ctrlKey: !0,
                    preventDefault: ()=>t1.preventDefault()
                }), p(this.element, t1)), e1.window.addEventListener("mousemove", this.mousemove), e1.window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e1) {
                this.move(e1, p(this.element, e1));
            }
            mouseup(e1) {
                this.mouseRotate.mouseupWindow(e1), this.mousePitch && this.mousePitch.mouseupWindow(e1), this.offTemp();
            }
            touchstart(e1) {
                1 !== e1.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e1.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e1.preventDefault()
                }, this._startPos));
            }
            touchmove(e1) {
                1 !== e1.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e1.targetTouches)[0], this.move({
                    preventDefault: ()=>e1.preventDefault()
                }, this._lastPos));
            }
            touchend(e1) {
                0 === e1.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        const hn = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }, un = {
            maxWidth: 100,
            unit: "metric"
        }, _n = {
            kilometer: "km",
            meter: "m",
            mile: "mi",
            foot: "ft",
            "nautical-mile": "nm"
        }, dn = {
            version: e1.version,
            supported: i,
            setRTLTextPlugin: e1.setRTLTextPlugin,
            getRTLTextPluginStatus: e1.getRTLTextPluginStatus,
            Map: class extends $r {
                constructor(t1){
                    if (e1.LivePerformanceUtils.mark(e1.PerformanceMarkers.create), null != (t1 = e1.extend({}, an, t1)).minZoom && null != t1.maxZoom && t1.minZoom > t1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t1.minPitch && null != t1.maxPitch && t1.minPitch > t1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t1.minPitch && t1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t1.maxPitch && t1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1.antialias && e1.isSafariWithAntialiasingBug(e1.window) && (t1.antialias = !1, e1.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ho(t1.minZoom, t1.maxZoom, t1.minPitch, t1.maxPitch, t1.renderWorldCopies), t1), this._interactive = t1.interactive, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t1.preserveDrawingBuffer, this._antialias = t1.antialias, this._useWebGL2 = t1.useWebGL2, this._trackResize = t1.trackResize, this._bearingSnap = t1.bearingSnap, this._refreshExpiredTiles = t1.refreshExpiredTiles, this._fadeDuration = t1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t1.crossSourceCollisions, this._collectResourceTiming = t1.collectResourceTiming, this._optimizeForTerrain = t1.optimizeForTerrain, this._language = this._parseLanguage(t1.language), this._worldview = t1.worldview, this._renderTaskQueue = new Kr, this._domRenderTaskQueue = new Kr, this._controls = [], this._markers = [], this._popups = [], this._mapId = e1.uniqueId(), this._locale = e1.extend({}, sn, t1.locale), this._clickTolerance = t1.clickTolerance, this._cooperativeGestures = t1.cooperativeGestures, this._performanceMetricsCollection = t1.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new nn(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e1.RequestManager(t1.transformRequest, t1.accessToken, t1.testMode), this._silenceAuthErrors = !!t1.testMode, "string" == typeof t1.container) {
                        if (this._container = e1.window.document.getElementById(t1.container), !this._container) throw new Error(`Container '${t1.container}' not found.`);
                    } else {
                        if (!(t1.container instanceof e1.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t1.container;
                    }
                    if (this._container.childNodes.length > 0 && e1.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t1.maxBounds && this.setMaxBounds(t1.maxBounds), e1.bindAll([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), void 0 !== e1.window && (e1.window.addEventListener("online", this._onWindowOnline, !1), e1.window.addEventListener("resize", this._onWindowResize, !1), e1.window.addEventListener("orientationchange", this._onWindowResize, !1), e1.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), e1.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new Xr(this, t1), this._localFontFamily = t1.localFontFamily, this._localIdeographFontFamily = t1.localIdeographFontFamily, t1.style && this.setStyle(t1.style, {
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t1.projection && this.setProjection(t1.projection), this._hash = t1.hash && new Ko("string" == typeof t1.hash && t1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
                        center: t1.center,
                        zoom: t1.zoom,
                        bearing: t1.bearing,
                        pitch: t1.pitch
                    }), t1.bounds && (this.resize(), this.fitBounds(t1.bounds, e1.extend({}, t1.fitBoundsOptions, {
                        duration: 0
                    })))), this.resize(), t1.attributionControl && this.addControl(new Hr({
                        customAttribution: t1.customAttribution
                    })), this._logoControl = new Yr, this.addControl(this._logoControl, t1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                    }), this.on("data", (t1)=>{
                        this._update("style" === t1.dataType), this.fire(new e1.Event(`${t1.dataType}data`, t1));
                    }), this.on("dataloading", (t1)=>{
                        this.fire(new e1.Event(`${t1.dataType}dataloading`, t1));
                    });
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t1, i) {
                    if (void 0 === i && (i = t1.getDefaultPosition ? t1.getDefaultPosition() : "top-right"), !t1 || !t1.onAdd) return this.fire(new e1.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = t1.onAdd(this);
                    this._controls.push(t1);
                    const r = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
                }
                removeControl(t1) {
                    if (!t1 || !t1.onRemove) return this.fire(new e1.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(t1);
                    return i > -1 && this._controls.splice(i, 1), t1.onRemove(this), this;
                }
                hasControl(e1) {
                    return this._controls.indexOf(e1) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t1) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new e1.Event("movestart", t1)).fire(new e1.Event("move", t1)), this.fire(new e1.Event("resize", t1)), i && this.fire(new e1.Event("moveend", t1)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t1) {
                    return this.transform.setMaxBounds(e1.LngLatBounds.convert(t1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = null == t1 ? -2 : t1) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 ? this.setZoom(t1) : this.fire(new e1.Event("zoomstart")).fire(new e1.Event("zoom")).fire(new e1.Event("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = null == t1 ? 22 : t1) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 ? this.setZoom(t1) : this.fire(new e1.Event("zoomstart")).fire(new e1.Event("zoom")).fire(new e1.Event("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = null == t1 ? 0 : t1) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 ? this.setPitch(t1) : this.fire(new e1.Event("pitchstart")).fire(new e1.Event("pitch")).fire(new e1.Event("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = null == t1 ? 85 : t1) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 ? this.setPitch(t1) : this.fire(new e1.Event("pitchstart")).fire(new e1.Event("pitch")).fire(new e1.Event("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e1) {
                    return this.transform.renderWorldCopies = e1, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(t1) {
                    return "auto" === t1 ? e1.window.navigator.language : Array.isArray(t1) ? 0 === t1.length ? void 0 : t1.map((t1)=>"auto" === t1 ? e1.window.navigator.language : t1) : t1;
                }
                setLanguage(e1) {
                    const t1 = this._parseLanguage(e1);
                    if (!this.style || t1 === this._language) return this;
                    this._language = t1, this.style._reloadSources();
                    for (const e1 of this._controls)e1._setLanguage && e1._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e1) {
                    return this.style && e1 !== this._worldview ? (this._worldview = e1, this.style._reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e1) {
                    return this._lazyInitEmptyStyle(), e1 ? "string" == typeof e1 && (e1 = {
                        name: e1
                    }) : e1 = null, this._useExplicitProjection = !!e1, this._prioritizeAndUpdateProjection(e1, this.style.stylesheet ? this.style.stylesheet.projection : null);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t1 = this.transform, i = t1.projection.name;
                    let o;
                    "globe" === i && t1.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX ? (t1.setMercatorFromTransition(), o = !0) : "mercator" === i && t1.zoom < e1.GLOBE_ZOOM_THRESHOLD_MAX && (t1.setProjection({
                        name: "globe"
                    }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
                }
                _prioritizeAndUpdateProjection(e1, t1) {
                    return this._updateProjection(e1 || t1 || {
                        name: "mercator"
                    });
                }
                _updateProjection(t1) {
                    let i;
                    if (i = "globe" === t1.name && this.transform.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t1), this.style.applyProjectionUpdate(), i) {
                        this.painter.clearBackgroundTiles();
                        for(const e1 in this.style._sourceCaches)this.style._sourceCaches[e1].clearTiles();
                        this._update(!0), this._forceMarkerAndPopupUpdate(!0);
                    }
                    return this;
                }
                project(t1) {
                    return this.transform.locationPoint3D(e1.LngLat.convert(t1));
                }
                unproject(t1) {
                    return this.transform.pointLocation3D(e1.Point.convert(t1));
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e1, t1, i) {
                    if ("mouseenter" === e1 || "mouseover" === e1) {
                        let o = !1;
                        const r = (r)=>{
                            const n = t1.filter((e1)=>this.getLayer(e1)), s = n.length ? this.queryRenderedFeatures(r.point, {
                                layers: n
                            }) : [];
                            s.length ? o || (o = !0, i.call(this, new ar(e1, this, r.originalEvent, {
                                features: s
                            }))) : o = !1;
                        }, n = ()=>{
                            o = !1;
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                mousemove: r,
                                mouseout: n
                            }
                        };
                    }
                    if ("mouseleave" === e1 || "mouseout" === e1) {
                        let o = !1;
                        const r = (r)=>{
                            const n = t1.filter((e1)=>this.getLayer(e1));
                            (n.length ? this.queryRenderedFeatures(r.point, {
                                layers: n
                            }) : []).length ? o = !0 : o && (o = !1, i.call(this, new ar(e1, this, r.originalEvent)));
                        }, n = (t1)=>{
                            o && (o = !1, i.call(this, new ar(e1, this, t1.originalEvent)));
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                mousemove: r,
                                mouseout: n
                            }
                        };
                    }
                    {
                        const o = (e1)=>{
                            const o = t1.filter((e1)=>this.getLayer(e1)), r = o.length ? this.queryRenderedFeatures(e1.point, {
                                layers: o
                            }) : [];
                            r.length && (e1.features = r, i.call(this, e1), delete e1.features);
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                [e1]: o
                            }
                        };
                    }
                }
                on(e1, t1, i) {
                    if (void 0 === i) return super.on(e1, t1);
                    Array.isArray(t1) || (t1 = [
                        t1
                    ]);
                    const o = this._createDelegatedListener(e1, t1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e1] = this._delegatedListeners[e1] || [], this._delegatedListeners[e1].push(o);
                    for(const e1 in o.delegates)this.on(e1, o.delegates[e1]);
                    return this;
                }
                once(e1, t1, i) {
                    if (void 0 === i) return super.once(e1, t1);
                    Array.isArray(t1) || (t1 = [
                        t1
                    ]);
                    const o = this._createDelegatedListener(e1, t1, i);
                    for(const e1 in o.delegates)this.once(e1, o.delegates[e1]);
                    return this;
                }
                off(e1, t1, i) {
                    if (void 0 === i) return super.off(e1, t1);
                    t1 = new Set(Array.isArray(t1) ? t1 : [
                        t1
                    ]);
                    const o = (e1, t1)=>{
                        if (e1.size !== t1.size) return !1;
                        for (const i of e1)if (!t1.has(i)) return !1;
                        return !0;
                    }, r = this._delegatedListeners ? this._delegatedListeners[e1] : void 0;
                    return r && ((e1)=>{
                        for(let r = 0; r < e1.length; r++){
                            const n = e1[r];
                            if (n.listener === i && o(n.layers, t1)) {
                                for(const e1 in n.delegates)this.off(e1, n.delegates[e1]);
                                return e1.splice(r, 1), this;
                            }
                        }
                    })(r), this;
                }
                queryRenderedFeatures(t1, i) {
                    return this.style ? (void 0 !== i || void 0 === t1 || t1 instanceof e1.Point || Array.isArray(t1) || (i = t1, t1 = void 0), this.style.queryRenderedFeatures(t1 = t1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], i = i || {}, this.transform)) : [];
                }
                querySourceFeatures(e1, t1) {
                    return this.style.querySourceFeatures(e1, t1);
                }
                isPointOnSurface(t1) {
                    const { name: i } = this.transform.projection;
                    return "globe" !== i && "mercator" !== i && e1.warnOnce(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e1.Point.convert(t1));
                }
                setStyle(t1, i) {
                    return !1 !== (i = e1.extend({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t1 ? (this._diffStyle(t1, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t1, i));
                }
                _getUIString(e1) {
                    const t1 = this._locale[e1];
                    if (null == t1) throw new Error(`Missing UI string '${e1}'`);
                    return t1;
                }
                _updateStyle(e1, t1) {
                    return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e1 && (this.style = new Kt(this, t1 || {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), "string" == typeof e1 ? this.style.loadURL(e1) : this.style.loadJSON(e1)), this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Kt(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                _diffStyle(t1, i) {
                    if ("string" == typeof t1) {
                        const o = this._requestManager.normalizeStyleURL(t1), r = this._requestManager.transformRequest(o, e1.ResourceType.Style);
                        e1.getJSON(r, (t1, o)=>{
                            t1 ? this.fire(new e1.ErrorEvent(t1)) : o && this._updateDiff(o, i);
                        });
                    } else "object" == typeof t1 && this._updateDiff(t1, i);
                }
                _updateDiff(t1, i) {
                    try {
                        this.style.setState(t1) && this._update(!0);
                    } catch (o) {
                        e1.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t1, i);
                    }
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e1.warnOnce("There is no style added to the map."), !1);
                }
                addSource(e1, t1) {
                    return this._lazyInitEmptyStyle(), this.style.addSource(e1, t1), this._update(!0);
                }
                isSourceLoaded(e1) {
                    return !!this.style && this.style._isSourceCacheLoaded(e1);
                }
                areTilesLoaded() {
                    const e1 = this.style && this.style._sourceCaches;
                    for(const t1 in e1){
                        const i = e1[t1]._tiles;
                        for(const e1 in i){
                            const t1 = i[e1];
                            if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                        }
                    }
                    return !0;
                }
                addSourceType(e1, t1, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e1, t1, i);
                }
                removeSource(e1) {
                    return this.style.removeSource(e1), this._updateTerrain(), this._update(!0);
                }
                getSource(e1) {
                    return this.style.getSource(e1);
                }
                addImage(t1, i, { pixelRatio: o = 1, sdf: r = !1, stretchX: n, stretchY: s, content: a } = {}) {
                    if (this._lazyInitEmptyStyle(), i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap) {
                        const { width: l, height: c, data: h } = e1.exported.getImageData(i);
                        this.style.addImage(t1, {
                            data: new e1.RGBAImage({
                                width: l,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: n,
                            stretchY: s,
                            content: a,
                            sdf: r,
                            version: 0
                        });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e1.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: l, height: c } = i, h = i;
                        this.style.addImage(t1, {
                            data: new e1.RGBAImage({
                                width: l,
                                height: c
                            }, new Uint8Array(h.data)),
                            pixelRatio: o,
                            stretchX: n,
                            stretchY: s,
                            content: a,
                            sdf: r,
                            version: 0,
                            userImage: h
                        }), h.onAdd && h.onAdd(this, t1);
                    }
                }
                updateImage(t1, i) {
                    const o = this.style.getImage(t1);
                    if (!o) return void this.fire(new e1.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const r = i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap ? e1.exported.getImageData(i) : i, { width: n, height: s } = r;
                    void 0 !== n && void 0 !== s ? n === o.data.width && s === o.data.height ? (o.data.replace(r.data, !(i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap)), this.style.updateImage(t1, o)) : this.fire(new e1.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`))) : this.fire(new e1.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                }
                hasImage(t1) {
                    return t1 ? !!this.style.getImage(t1) : (this.fire(new e1.ErrorEvent(new Error("Missing required image id"))), !1);
                }
                removeImage(e1) {
                    this.style.removeImage(e1);
                }
                loadImage(t1, i) {
                    e1.getImage(this._requestManager.transformRequest(t1, e1.ResourceType.Image), (t1, o)=>{
                        i(t1, o instanceof e1.window.HTMLImageElement ? e1.exported.getImageData(o) : o);
                    });
                }
                listImages() {
                    return this.style.listImages();
                }
                addLayer(e1, t1) {
                    return this._lazyInitEmptyStyle(), this.style.addLayer(e1, t1), this._update(!0);
                }
                moveLayer(e1, t1) {
                    return this.style.moveLayer(e1, t1), this._update(!0);
                }
                removeLayer(e1) {
                    return this.style.removeLayer(e1), this._update(!0);
                }
                getLayer(e1) {
                    return this.style.getLayer(e1);
                }
                setLayerZoomRange(e1, t1, i) {
                    return this.style.setLayerZoomRange(e1, t1, i), this._update(!0);
                }
                setFilter(e1, t1, i = {}) {
                    return this.style.setFilter(e1, t1, i), this._update(!0);
                }
                getFilter(e1) {
                    return this.style.getFilter(e1);
                }
                setPaintProperty(e1, t1, i, o = {}) {
                    return this.style.setPaintProperty(e1, t1, i, o), this._update(!0);
                }
                getPaintProperty(e1, t1) {
                    return this.style.getPaintProperty(e1, t1);
                }
                setLayoutProperty(e1, t1, i, o = {}) {
                    return this.style.setLayoutProperty(e1, t1, i, o), this._update(!0);
                }
                getLayoutProperty(e1, t1) {
                    return this.style.getLayoutProperty(e1, t1);
                }
                setLight(e1, t1 = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setLight(e1, t1), this._update(!0);
                }
                getLight() {
                    return this.style.getLight();
                }
                setTerrain(e1) {
                    return this._lazyInitEmptyStyle(), !e1 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e1), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e1) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e1), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                _queryFogOpacity(t1) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e1.LngLat.convert(t1), this.transform) : 0;
                }
                setFeatureState(e1, t1) {
                    return this.style.setFeatureState(e1, t1), this._update();
                }
                removeFeatureState(e1, t1) {
                    return this.style.removeFeatureState(e1, t1), this._update();
                }
                getFeatureState(e1) {
                    return this.style.getFeatureState(e1);
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const t1 = this._container.getBoundingClientRect().width || 400, i = this._container.getBoundingClientRect().height || 300;
                    let o, r, n, s = this._container;
                    for(; s && (!r || !n);){
                        const t1 = e1.window.getComputedStyle(s).transform;
                        t1 && "none" !== t1 && (o = t1.match(/matrix.*\((.+)\)/)[1].split(", "), o[0] && "0" !== o[0] && "1" !== o[0] && (r = o[0]), o[3] && "0" !== o[3] && "1" !== o[3] && (n = o[3])), s = s.parentElement;
                    }
                    this._containerWidth = r ? Math.abs(t1 / r) : t1, this._containerHeight = n ? Math.abs(i / n) : i;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== e1.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e1.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e1 = this._container;
                    e1.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e1)).style.visibility = "hidden", this._detectMissingCSS();
                    const t1 = this._canvasContainer = n("div", "mapboxgl-canvas-container", e1);
                    this._interactive && t1.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = n("div", "mapboxgl-control-container", e1), o = this._controlPositions = {};
                    [
                        "top-left",
                        "top-right",
                        "bottom-left",
                        "bottom-right"
                    ].forEach((e1)=>{
                        o[e1] = n("div", `mapboxgl-ctrl-${e1}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t1, i) {
                    const o = e1.exported.devicePixelRatio || 1;
                    this._canvas.width = o * Math.ceil(t1), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e1) {
                    this._markers.push(e1);
                }
                _removeMarker(e1) {
                    const t1 = this._markers.indexOf(e1);
                    -1 !== t1 && this._markers.splice(t1, 1);
                }
                _addPopup(e1) {
                    this._popups.push(e1);
                }
                _removePopup(e1) {
                    const t1 = this._popups.indexOf(e1);
                    -1 !== t1 && this._popups.splice(t1, 1);
                }
                _setupPainter() {
                    const t1 = e1.extend({}, i.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), o = this._useWebGL2 && this._canvas.getContext("webgl2", t1), r = o || this._canvas.getContext("webgl", t1) || this._canvas.getContext("experimental-webgl", t1);
                    r ? (this._useWebGL2 && !o && e1.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e1.storeAuthState(r, !0), this.painter = new Bo(r, this.transform, !!o), this.on("data", (e1)=>{
                        "source" === e1.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e1.exported$1.testSupport(r)) : this.fire(new e1.ErrorEvent(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t1) {
                    t1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e1.Event("webglcontextlost", {
                        originalEvent: t1
                    }));
                }
                _contextRestored(t1) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new e1.Event("webglcontextrestored", {
                        originalEvent: t1
                    }));
                }
                _onMapScroll(e1) {
                    if (e1.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                _update(e1) {
                    return this.style ? (this._styleDirty = this._styleDirty || e1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e1) {
                    return this._update(), this._renderTaskQueue.add(e1);
                }
                _cancelRenderFrame(e1) {
                    this._renderTaskQueue.remove(e1);
                }
                _requestDomTask(e1) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e1() : this._domRenderTaskQueue.add(e1);
                }
                _render(t1) {
                    let i;
                    const o = this.painter.context.extTimerQuery, r = e1.exported.now();
                    if (this.listens("gpu-timing-frame") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e1.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e1.window.performance.now())), this._renderTaskQueue.run(t1), this._domRenderTaskQueue.run(t1), this._removed) return;
                    this._updateProjectionTransition();
                    const n = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t1 = this.transform.zoom, i = this.transform.pitch, o = e1.exported.now(), r = new e1.EvaluationParameters(t1, {
                            now: o,
                            fadeDuration: n,
                            pitch: i,
                            transition: this.style.getTransition()
                        });
                        this.style.update(r);
                    }
                    this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let s = !1;
                    if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showTerrainWireframe: this.showTerrainWireframe,
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: n,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e1.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e1.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {
                        const t1 = e1.exported.now() - r;
                        o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(()=>{
                            const n = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;
                            o.deleteQueryEXT(i), this.fire(new e1.Event("gpu-timing-frame", {
                                cpuTime: t1,
                                gpuTime: n
                            })), e1.window.performance.mark("frame-gpu", {
                                startTime: r,
                                detail: {
                                    gpuTime: n
                                }
                            });
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(t1);
                            this.fire(new e1.Event("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t1 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(t1);
                            this.fire(new e1.Event("gpu-timing-deferred-render", {
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
                    if (a || this._repaint) this.triggerRepaint();
                    else {
                        const t1 = !this.isMoving() && this.loaded();
                        if (t1 && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t1 && (this.fire(new e1.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t1 = this._calculateSpeedIndex();
                            this.fire(new e1.Event("speedindexcompleted", {
                                speedIndex: t1
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0, e1.LivePerformanceUtils.mark(e1.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e1.postPerformanceEvent(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e1) {
                    for (const t1 of this._markers)e1 && !this.getRenderWorldCopies() && (t1._lngLat = t1._lngLat.wrap()), t1._update();
                    for (const t1 of this._popups)!e1 || this.getRenderWorldCopies() || t1._trackPointer || (t1._lngLat = t1._lngLat.wrap()), t1._update();
                }
                _updateAverageElevation(e1, t1 = !1) {
                    const i = (e1)=>(this.transform.averageElevation = e1, this._update(!1), !0);
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
                    if ((t1 || e1 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e1)) {
                        const t1 = this.transform.averageElevation;
                        let o = this.transform.sampleAverageElevation(), r = !1;
                        this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e1;
                        const n = Math.abs(t1 - o);
                        if (n > 1) {
                            if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);
                            this._averageElevation.easeTo(o, e1, 300);
                        } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);
                    }
                    return !!this._averageElevation.isEasing(e1) && i(this._averageElevation.getValue(e1));
                }
                _authenticate() {
                    e1.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t1)=>{
                        if (t1 && (t1.message === e1.AUTH_ERR_MSG || 401 === t1.status)) {
                            const t1 = this.painter.context.gl;
                            e1.storeAuthState(t1, !1), this._logoControl instanceof Yr && this._logoControl._updateLogo(), t1 && t1.clear(t1.DEPTH_BUFFER_BIT | t1.COLOR_BUFFER_BIT | t1.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e1.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), e1.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{});
                }
                _updateTerrain() {
                    const e1 = this._isDragging();
                    this.painter.updateTerrain(this.style, e1);
                }
                _calculateSpeedIndex() {
                    const e1 = this.painter.canvasCopy(), t1 = this.painter.getCanvasCopiesAndTimestamps();
                    t1.timeStamps.push(performance.now());
                    const i = this.painter.context.gl, o = i.createFramebuffer();
                    function r(e1) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e1, 0);
                        const t1 = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t1), t1;
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e1), t1.canvasCopies.map(r), t1.timeStamps);
                }
                _canvasPixelComparison(e1, t1, i) {
                    let o = i[1] - i[0];
                    const r = e1.length / 4;
                    for(let n = 0; n < t1.length; n++){
                        const s = t1[n];
                        let a = 0;
                        for(let t1 = 0; t1 < s.length; t1 += 4)s[t1] === e1[t1] && s[t1 + 1] === e1[t1 + 1] && s[t1 + 2] === e1[t1 + 2] && s[t1 + 3] === e1[t1 + 3] && (a += 1);
                        o += (i[n + 2] - i[n + 1]) * (1 - a / r);
                    }
                    return o;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e1 of this._controls)e1.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e1.window && (e1.window.removeEventListener("resize", this._onWindowResize, !1), e1.window.removeEventListener("orientationchange", this._onWindowResize, !1), e1.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e1.window.removeEventListener("online", this._onWindowOnline, !1), e1.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                    const t1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t1 && t1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e1.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e1.Event("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t1) {
                    this._renderNextFrame = this._renderNextFrame || t1, this.style && !this._frame && (this._frame = e1.exported.frame((e1)=>{
                        const t1 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t1 && this._render(e1);
                    }));
                }
                _preloadTiles(t1) {
                    const i = this.style ? Object.values(this.style._sourceCaches) : [];
                    return e1.asyncAll(i, (e1, i)=>e1._preloadTiles(t1, i), ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e1) {
                    this._trackResize && this.resize({
                        originalEvent: e1
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === e1.window.document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e1) {
                    this._showTileBoundaries !== e1 && (this._showTileBoundaries = e1, this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e1) {
                    this._showTerrainWireframe !== e1 && (this._showTerrainWireframe = e1, this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e1) {
                    this._speedIndexTiming !== e1 && (this._speedIndexTiming = e1, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e1) {
                    this._showPadding !== e1 && (this._showPadding = e1, this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e1) {
                    this._showCollisionBoxes !== e1 && (this._showCollisionBoxes = e1, e1 ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e1) {
                    this._showOverdrawInspector !== e1 && (this._showOverdrawInspector = e1, this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e1) {
                    this._repaint !== e1 && (this._repaint = e1, this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e1) {
                    this._vertices = e1, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e1) {
                    this._showTileAABBs !== e1 && (this._showTileAABBs = e1, e1 && this._update());
                }
                _setCacheLimits(t1, i) {
                    e1.setCacheLimits(t1, i);
                }
                get version() {
                    return e1.version;
                }
            },
            NavigationControl: class {
                constructor(t1){
                    this.options = e1.extend({}, ln, t1), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e1)=>e1.preventDefault()), this.options.showZoom && (e1.bindAll([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e1)=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: e1
                        });
                    }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e1)=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: e1
                        });
                    }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e1.bindAll([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e1)=>{
                        const t1 = this._map;
                        t1 && (this.options.visualizePitch ? t1.resetNorthPitch({}, {
                            originalEvent: e1
                        }) : t1.resetNorth({}, {
                            originalEvent: e1
                        }));
                    }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e1 = this._map;
                    if (!e1) return;
                    const t1 = e1.getZoom(), i = t1 === e1.getMaxZoom(), o = t1 === e1.getMinZoom();
                    this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }
                _rotateCompassArrow() {
                    const e1 = this._map;
                    if (!e1) return;
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e1.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e1.transform.pitch}deg) rotateZ(${e1.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e1.transform.angle * (180 / Math.PI)}deg)`;
                    e1._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t1);
                    });
                }
                onAdd(e1) {
                    return this._map = e1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e1.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e1.on("pitch", this._rotateCompassArrow), e1.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cn(e1, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e1 = this._map;
                    e1 && (this._container.remove(), this.options.showZoom && e1.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e1.off("pitch", this._rotateCompassArrow), e1.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e1, t1) {
                    const i = n("button", e1, this._container);
                    return i.type = "button", i.addEventListener("click", t1), i;
                }
                _setButtonTitle(e1, t1) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t1}`);
                    e1.setAttribute("aria-label", i), e1.firstElementChild && e1.firstElementChild.setAttribute("title", i);
                }
            },
            GeolocateControl: class extends e1.Evented {
                constructor(t1){
                    super(), this.options = e1.extend({
                        geolocation: e1.window.navigator.geolocation
                    }, hn, t1), e1.bindAll([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = Yo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e1) {
                    return this._map = e1, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(t1) {
                    const i = (e1 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = e1, t1(e1);
                    };
                    void 0 !== this._supportsGeolocation ? t1(this._supportsGeolocation) : void 0 !== e1.window.navigator.permissions ? e1.window.navigator.permissions.query({
                        name: "geolocation"
                    }).then((e1)=>i("denied" !== e1.state)).catch(()=>i()) : i();
                }
                _isOutOfMapMaxBounds(e1) {
                    const t1 = this._map.getMaxBounds(), i = e1.coords;
                    return !!t1 && (i.longitude < t1.getWest() || i.longitude > t1.getEast() || i.latitude < t1.getSouth() || i.latitude > t1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t1) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t1)) return this._setErrorState(), this.fire(new e1.Event("outofmaxbounds", t1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t1), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e1.Event("geolocate", t1)), this._finish();
                    }
                }
                _updateCamera(t1) {
                    const i = new e1.LngLat(t1.coords.longitude, t1.coords.latitude), o = t1.coords.accuracy, r = this._map.getBearing(), n = e1.extend({
                        bearing: r
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), n, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t1) {
                    if (t1) {
                        const i = new e1.LngLat(t1.coords.longitude, t1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map.transform, i = e1.mercatorZfromAltitude(1, t1._center.lat) * t1.worldSize, o = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t1) {
                    if (this._map) {
                        if (this.options.trackUserLocation) {
                            if (1 === t1.code) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const e1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", e1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e1), void 0 !== this._geolocationWatchID && this._clearWatch();
                            } else {
                                if (3 === t1.code && this._noTimeout) return;
                                this._setErrorState();
                            }
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e1.Event("error", t1)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(t1) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e1)=>e1.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t1) {
                            e1.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t1);
                        } else {
                            const e1 = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e1);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new en({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new en({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t1)=>{
                            t1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t1.originalEvent && "resize" === t1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e1.Event("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e1) {
                    this._userLocationDotMarker && (e1.webkitCompassHeading ? this._heading = e1.webkitCompassHeading : !0 === e1.absolute && (this._heading = -1 * e1.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e1.warnOnce("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e1.Event("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e1.Event("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e1.Event("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let e1;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e1 = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, this._noTimeout = !0) : (e1 = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e1), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                    return !0;
                }
                _addDeviceOrientationListener() {
                    const t1 = ()=>{
                        e1.window.addEventListener("ondeviceorientationabsolute" in e1.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
                    };
                    void 0 !== e1.window.DeviceMotionEvent && "function" == typeof e1.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e1)=>{
                        "granted" === e1 && t1();
                    }).catch(console.error) : t1();
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), e1.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e1.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: Hr,
            ScaleControl: class {
                constructor(t1){
                    this.options = e1.extend({}, un, t1), this._isNumberFormatSupported = function() {
                        try {
                            return new Intl.NumberFormat("en", {
                                style: "unit",
                                unitDisplay: "short",
                                unit: "meter"
                            }), !0;
                        } catch (e1) {
                            return !1;
                        }
                    }(), e1.bindAll([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e1 = this.options.maxWidth || 100, t1 = this._map, i = t1._containerHeight / 2, o = t1._containerWidth / 2 - e1 / 2, r = t1.unproject([
                        o,
                        i
                    ]), n = t1.unproject([
                        o + e1,
                        i
                    ]), s = r.distanceTo(n);
                    if ("imperial" === this.options.unit) {
                        const t1 = 3.2808 * s;
                        t1 > 5280 ? this._setScale(e1, t1 / 5280, "mile") : this._setScale(e1, t1, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e1, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(e1, s / 1e3, "kilometer") : this._setScale(e1, s, "meter");
                }
                _setScale(e1, t1, i) {
                    this._map._requestDomTask(()=>{
                        const o = function(e1) {
                            const t1 = Math.pow(10, `${Math.floor(e1)}`.length - 1);
                            let i = e1 / t1;
                            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(e1) {
                                const t1 = Math.pow(10, Math.ceil(-Math.log(e1) / Math.LN10));
                                return Math.round(e1 * t1) / t1;
                            }(i), t1 * i;
                        }(t1), r = o / t1;
                        this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "short",
                            unit: i
                        }).format(o) : `${o}&nbsp;${_n[i]}`, this._container.style.width = e1 * r + "px";
                    });
                }
                onAdd(e1) {
                    return this._map = e1, this._language = e1.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e1.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e1) {
                    this._language = e1, this._update();
                }
                setUnit(e1) {
                    this.options.unit = e1, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t1){
                    this._fullscreen = !1, t1 && t1.container && (t1.container instanceof e1.window.HTMLElement ? this._container = t1.container : e1.warnOnce("Full screen control 'container' must be a DOM element.")), e1.bindAll([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in e1.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e1.window.document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t1) {
                    return this._map = t1, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e1.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, e1.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!e1.window.document.fullscreenEnabled && !e1.window.document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const t1 = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    n("span", "mapboxgl-ctrl-icon", t1).setAttribute("aria-hidden", "true"), t1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e1.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e1 = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e1), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e1);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (e1.window.document.fullscreenElement || e1.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? e1.window.document.exitFullscreen ? e1.window.document.exitFullscreen() : e1.window.document.webkitCancelFullScreen && e1.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            Popup: class extends e1.Evented {
                constructor(t1){
                    super(), this.options = e1.extend(Object.create(tn), t1), e1.bindAll([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t1 && t1.className ? t1.className.trim().split(/\s+/) : []);
                }
                addTo(t1) {
                    return this._map && this.remove(), this._map = t1, this.options.closeOnClick && t1.on("preclick", this._onClose), this.options.closeOnMove && t1.on("move", this._onClose), t1.on("remove", this.remove), this._update(), t1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t1.on("mousemove", this._onMouseEvent), t1.on("mouseup", this._onMouseEvent), t1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t1.on("move", this._update), this.fire(new e1.Event("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t1 = this._map;
                    return t1 && (t1.off("move", this._update), t1.off("move", this._onClose), t1.off("preclick", this._onClose), t1.off("click", this._onClose), t1.off("remove", this.remove), t1.off("mousemove", this._onMouseEvent), t1.off("mouseup", this._onMouseEvent), t1.off("drag", this._onMouseEvent), t1._canvasContainer && t1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t1._removePopup(this), this._map = void 0), this.fire(new e1.Event("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t1) {
                    this._lngLat = e1.LngLat.convert(t1), this._pos = null, this._trackPointer = !1, this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e1 = this._map;
                    return e1 && (e1.off("move", this._update), e1.on("mousemove", this._onMouseEvent), e1.on("drag", this._onMouseEvent), e1._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(t1) {
                    return this.setDOMContent(e1.window.document.createTextNode(t1));
                }
                setHTML(t1) {
                    const i = e1.window.document.createDocumentFragment(), o = e1.window.document.createElement("body");
                    let r;
                    for(o.innerHTML = t1; r = o.firstChild, r;)i.appendChild(r);
                    return this.setDOMContent(i);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e1) {
                    return this.options.maxWidth = e1, this._update(), this;
                }
                setDOMContent(e1) {
                    let t1 = this._content;
                    if (t1) for(; t1.hasChildNodes();)t1.firstChild && t1.removeChild(t1.firstChild);
                    else t1 = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t1.appendChild(e1), this.options.closeButton) {
                        const e1 = this._closeButton = n("button", "mapboxgl-popup-close-button", t1);
                        e1.type = "button", e1.setAttribute("aria-label", "Close popup"), e1.setAttribute("aria-hidden", "true"), e1.innerHTML = "&#215;", e1.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e1) {
                    return this._classList.add(e1), this._updateClassList(), this;
                }
                removeClassName(e1) {
                    return this._classList.delete(e1), this._updateClassList(), this;
                }
                setOffset(e1) {
                    return this.options.offset = e1, this._update(), this;
                }
                toggleClassName(e1) {
                    let t1;
                    return this._classList.delete(e1) ? t1 = !1 : (this._classList.add(e1), t1 = !0), this._updateClassList(), t1;
                }
                _onMouseEvent(e1) {
                    this._update(e1.point);
                }
                _getAnchor(e1) {
                    if (this.options.anchor) return this.options.anchor;
                    const t1 = this._map, i = this._container, o = this._pos;
                    if (!t1 || !i || !o) return "bottom";
                    const r = i.offsetWidth, n = i.offsetHeight, s = o.x < r / 2, a = o.x > t1.transform.width - r / 2;
                    if (o.y + e1 < n) return s ? "top-left" : a ? "top-right" : "top";
                    if (o.y > t1.transform.height - n) {
                        if (s) return "bottom-left";
                        if (a) return "bottom-right";
                    }
                    return s ? "left" : a ? "right" : "bottom";
                }
                _updateClassList() {
                    const e1 = this._container;
                    if (!e1) return;
                    const t1 = [
                        ...this._classList
                    ];
                    t1.push("mapboxgl-popup"), this._anchor && t1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t1.push("mapboxgl-popup-track-pointer"), e1.className = t1.join(" ");
                }
                _update(t1) {
                    const i = this._map, o = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !o) return;
                    let r = this._container;
                    if (r || (r = this._container = n("div", "mapboxgl-popup", i.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Jr(this._lngLat, this._pos, i.transform)), !this._trackPointer || t1) {
                        const e1 = this._pos = this._trackPointer && t1 ? t1 : i.project(this._lngLat), o = rn(this.options.offset), r = this._anchor = this._getAnchor(o.y), n = rn(this.options.offset, r), s = e1.add(n).round();
                        i._requestDomTask(()=>{
                            this._container && r && (this._container.style.transform = `${Qr[r]} translate(${s.x}px,${s.y}px)`);
                        });
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const t1 = e1.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t1);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e1 = this._container.querySelector(on);
                    e1 && e1.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e1) {
                    this._container && (this._container.style.opacity = `${e1}`), this._content && (this._content.style.pointerEvents = e1 ? "auto" : "none");
                }
            },
            Marker: en,
            Style: Kt,
            LngLat: e1.LngLat,
            LngLatBounds: e1.LngLatBounds,
            Point: e1.Point,
            MercatorCoordinate: e1.MercatorCoordinate,
            FreeCameraOptions: jo,
            Evented: e1.Evented,
            config: e1.config,
            prewarm: function() {
                Ue().acquire(Be);
            },
            clearPrewarmedResources: function() {
                const e1 = Fe;
                e1 && (e1.isPreloaded() && 1 === e1.numActive() ? (e1.release(Be), Fe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
            },
            get accessToken () {
                return e1.config.ACCESS_TOKEN;
            },
            set accessToken (t){
                e1.config.ACCESS_TOKEN = t;
            },
            get baseApiUrl () {
                return e1.config.API_URL;
            },
            set baseApiUrl (t){
                e1.config.API_URL = t;
            },
            get workerCount () {
                return ke.workerCount;
            },
            set workerCount (e){
                ke.workerCount = e;
            },
            get maxParallelImageRequests () {
                return e1.config.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t){
                e1.config.MAX_PARALLEL_IMAGE_REQUESTS = t;
            },
            clearStorage (t1) {
                e1.clearTileCache(t1);
            },
            workerUrl: "",
            workerClass: null,
            setNow: e1.exported.setNow,
            restoreNow: e1.exported.restoreNow
        };
        return dn;
    });
    //
    // Our custom intro provides a specialized "define()" function, called by the
    // AMD modules below, that sets up the worker blob URL and then executes the
    // main module, storing its exported value as 'mapboxgl'
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
});

},{}],"10tSC":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bookTour", ()=>bookTour);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alerts = require("./alerts");
var _stripeJs = require("@stripe/stripe-js");
const bookTour = async (tourId)=>{
    const stripe = await (0, _stripeJs.loadStripe)("pk_test_51O6dOSSJfU3feLnFqkAZTQ6V1yOmjYmI6p7bci6ZgpyJU54HXYIdsElT88fyvuRboZ5GeK3zYfkpA9FOYzpPNNZj00felEmlKT");
    // console.log(tourId);
    const response = await (0, _axiosDefault.default).get(`/api/v1/booking/checkout-session/${tourId}`);
    const session = response.data.session;
    await stripe.redirectToCheckout({
        sessionId: session.id
    });
};

},{"axios":"jo6P5","./alerts":"6Mcnf","@stripe/stripe-js":"e9NTD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9NTD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadStripe", ()=>loadStripe);
var V3_URL = "https://js.stripe.com/v3";
var V3_URL_REGEX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/;
var EXISTING_SCRIPT_MESSAGE = "loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used";
var findScript = function findScript() {
    var scripts = document.querySelectorAll('script[src^="'.concat(V3_URL, '"]'));
    for(var i = 0; i < scripts.length; i++){
        var script = scripts[i];
        if (!V3_URL_REGEX.test(script.src)) continue;
        return script;
    }
    return null;
};
var injectScript = function injectScript(params) {
    var queryString = params && !params.advancedFraudSignals ? "?advancedFraudSignals=false" : "";
    var script = document.createElement("script");
    script.src = "".concat(V3_URL).concat(queryString);
    var headOrBody = document.head || document.body;
    if (!headOrBody) throw new Error("Expected document.body not to be null. Stripe.js requires a <body> element.");
    headOrBody.appendChild(script);
    return script;
};
var registerWrapper = function registerWrapper(stripe, startTime) {
    if (!stripe || !stripe._registerWrapper) return;
    stripe._registerWrapper({
        name: "stripe-js",
        version: "2.2.0",
        startTime: startTime
    });
};
var stripePromise = null;
var loadScript = function loadScript(params) {
    // Ensure that we only attempt to load Stripe.js at most once
    if (stripePromise !== null) return stripePromise;
    stripePromise = new Promise(function(resolve, reject) {
        if (typeof window === "undefined" || typeof document === "undefined") {
            // Resolve to null when imported server side. This makes the module
            // safe to import in an isomorphic code base.
            resolve(null);
            return;
        }
        if (window.Stripe && params) console.warn(EXISTING_SCRIPT_MESSAGE);
        if (window.Stripe) {
            resolve(window.Stripe);
            return;
        }
        try {
            var script = findScript();
            if (script && params) console.warn(EXISTING_SCRIPT_MESSAGE);
            else if (!script) script = injectScript(params);
            script.addEventListener("load", function() {
                if (window.Stripe) resolve(window.Stripe);
                else reject(new Error("Stripe.js not available"));
            });
            script.addEventListener("error", function() {
                reject(new Error("Failed to load Stripe.js"));
            });
        } catch (error) {
            reject(error);
            return;
        }
    });
    return stripePromise;
};
var initStripe = function initStripe(maybeStripe, args, startTime) {
    if (maybeStripe === null) return null;
    var stripe = maybeStripe.apply(undefined, args);
    registerWrapper(stripe, startTime);
    return stripe;
}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
// own script injection.
var stripePromise$1 = Promise.resolve().then(function() {
    return loadScript(null);
});
var loadCalled = false;
stripePromise$1["catch"](function(err) {
    if (!loadCalled) console.warn(err);
});
var loadStripe = function loadStripe() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    loadCalled = true;
    var startTime = Date.now();
    return stripePromise$1.then(function(maybeStripe) {
        return initStripe(maybeStripe, args, startTime);
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["f2QDv"], "f2QDv", "parcelRequire11c7")

//# sourceMappingURL=index.js.map
